// baea_serializableobjectproxyutil.h                                 -*-C++-*-
#ifndef INCLUDED_BAEA_SERIALIZABLEOBJECTPROXYUTIL
#define INCLUDED_BAEA_SERIALIZABLEOBJECTPROXYUTIL

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")
BDES_IDENT_PRAGMA_ONCE

//@PURPOSE: Provide utilities for configuring a 'baea_SerializableObjectProxy'.
//
//@CLASSES:
//  baea_SerializableObjectProxyUtil: utilities for configuring a proxy object
//
//@AUTHOR: David Schumann (dschumann1), Raymond Chiu (schiu49)
//
//@SEE_ALSO: baea_serializableobjectproxy, bdeat_typecategory, bdem_berencoder
//
//@DESCRIPTION: This component provides a suite of functions for configuring a
// 'baea_SerializableObjectProxy' object so that it represents another object
// (typically an object of a type generated by "bas_codegen.pl") for the
// purpose of encoding or decoding that other object.  Encoding/decoding a
// 'baea_SerializableObjectProxy' using a 'bdeat'-style encoder/decoder
// involves expanding the template functions of that encoder/decoder for only
// 'baea_SerializableObjectProxy' rather than for every complex type in the
// message being encoded and decoded, and thus can be expected to produce
// substantially less object code at a lower compilation cost.  Instead, the
// type-specific logic is supplied by template expansions of functions in this
// component, which are generally much simpler and smaller.
//
// The type categories of the 'bdeat' package are used throughout this
// component.  The terms "Array", "Choice", "Customized", "Enumeration",
// "Nullable", "Sequence", and "Simple" all refer to the corresponding
// 'bdeat' categories.
//
///Proxy Object Structure
///----------------------
// 'baea_SerializableObjectProxyUtil' provides functions that configure a
// 'baea_SerializableObjectProxy' object with the necessary information to
// encode from, or decode into, the supplied 'bdeat'-compliant proxied object.
// If the proxied object holds another object -- as is the case for Sequence,
// Choice, Nullable, and Array objects -- the proxy holds a pointer to a
// function that can populate another a 'baea_SerializableObjectProxy' to
// describe that contained object.
//
// This can be thought of as a form of "lazy evaluation".  An example may
// help illustrate the approach.  We start by outlining the definition of
// a 'MyChoiceType' type generated by "bas_codegen.pl", having 'MySequenceType'
// as one of its selections, that we wish to encode/decode:
//..
//  class MyChoiceType {
//    union {
//      bsls::ObjectBuffer<MySequenceType> d_mySequence;  // selection 0
//      // ...
//    };
//    // ...
//    MySequenceType& makeMySequenceValue();
//    // ...
//  };
//..
// Now we define an object of 'MyChoiceType', 'myChoice', and an initially
// empty 'baea_SerializableObjectProxy', 'myProxy', that we will use for
// encoding 'myChoice'.
//..
//  MyChoiceType myChoice;
//  myChoice.makeMySequenceValue();
//  baea_SerializableObjectProxy myProxy;
//..
// If we then invoke 'baea_SerializableObjectProxyUtil::makeEncodeProxy' on
// 'myChoice', it will populate 'myProxy' in the following way:
//..
//  ,----------------------------------.
//  |  baea_SerializableObjectProxy    |
//  |    void         *d_object_p;   --+-->[ &myChoice.d_mySequence ]
//  |    Variant<...>  d_objectInfo; --+--.
//  `----------------------------------'  |
//                                        |
//                                        V
//  ,--------------------------------------------.
//  |  ChoiceEncodeInfo                          |
//  |    bdeat_SelectionInfo *d_selection;   ----+--> [ selection description ]
//  |    const char          *d_classname_p; ----+--> "MyChoiceType"
//  |    Loader               d_loader;      --. |
//  `------------------------------------------|-'
//                                             |
//                                             V
//  ,-----------------------------------------------------------------------.
//  |  baea_SerializableObjectProxyUtil::makeEncodeProxyRaw<MySequenceType> |
//  |    A function that, when invoked, will configure a                    |
//  |    'baea_SerializableObjectProxy' for 'myChoice.d_mySequence'.        |
//  `-----------------------------------------------------------------------'
//..
// So for a Choice object, the proxy object populated for encoding that Choice
// contains: a pointer to the underlying selection, information about that
// choice, and a pointer to a function that, when invoked, will populate
// another proxy for the selection.  That function is not invoked until the
// object is later encoded.  A similar structure is created for
// encoding/decoding any container type, but the details vary slightly based
// on the type and the direction (encoding/decoding).
//
///Treatment of "Customized" Types
///-------------------------------
// The 'bdeat' package has a concept of Customized type.  Types in this
// category contain a restricted value of some other type.  A common example is
// a string of restricted length.  Customized types are required to have
// conversion methods for their underlying type -- for example, a Customized
// type based on 'bsl::string' is required to have a 'toString' method.
//
// 'baea_SerializableObjectProxyUtil' makes the assumption that such methods
// return 'const' references to a member variable of the underlying type, so
// that it is safe to take the address of the return value and store it for
// later use.  In this way, 'toString' is treated by this component as an
// accessor method for a member variable of type 'bsl::string' assumed to exist
// within the type.  This is not required by the 'bdeat' package -- a
// Customized type based on 'bsl::string' is allowed to return a 'bsl::string'
// by value from 'toString'.  Such types cannot be used with this component, or
// undefined behavior will result.  'bas_codegen.pl' emits Customized types
// that return 'const' references from their conversion methods and are thus
// compatible with this component.
//
///Usage Example
///-------------
// In this section we show the intended usage of this component.
//
///Example 1: Serializing a BAS Request
/// - - - - - - - - - - - - - - - - - -
// In this example, we demonstrate how to encode a BAS message object using
// 'baea_SerializableObjectProxy' to reduce the complexity of the resulting
// object code as compared with encoding and decoding the message object
// directly.
//
// Suppose we are given a BAS message component with a request type named
// 'SimpleRequest' which has the field 'data' of type 'bsl::string' and
// 'responseLength' of type 'int'.  First, we create a 'Request' object named
// 'encodeMessage' that we would like to encode:
//..
//  baea::Request encodeMessage;
//  encodeMessage.makeSimpleRequest();
//  encodeMessage.simpleRequest().data() = "Test message";
//  encodeMessage.simpleRequest().responseLength() = 12;
//..
// Then, we create a proxy object to be used when encoding:
//..
//  baea_SerializableObjectProxy encodeProxy;
//..
// Next, we use the 'makeEncodeProxy' method to populate 'encodeProxy' to
// represent the object that we would like to encode.
//..
//  baea_SerializableObjectProxyUtil::makeEncodeProxy(&encodeProxy,
//                                                    &encodeMessage);
//..
// Now, we setup the encoder and encode the request into a memory stream
// buffer:
//..
//  baexml_EncoderOptions eOptions;
//  baexml_Encoder encoder(&eOptions);
//  bdesb_MemOutStreamBuf osb;
//  encoder.encode(&osb, encodeProxy);
//..
// Finally, we can print out the XML string that is stored in the memory
// buffer:
//..
//  std::cout << osb.data() << std::endl;
//..
//
///Example 2: Decoding an XML String
///- - - - - - - - - - - - - - - - -
// In this example, we demonstrate how to decode a XML string using the
// 'baea_SerializableObjectProxy'.
//
// First, we create the XML string that we would like to decode into a
// 'SimpleRequest' that was described in the previous example:
//..
//  const char *xmlString =
//      "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>"
//          "<Request xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">"
//          "<simpleRequest>"
//              "<data>Hello, world!</data>"
//              "<responseLength>13</responseLength>"
//          "</simpleRequest>"
//      "</Request>";
//..
// Then, we create the request object we would like the XML string to be
// decoded into.
//..
//  baea::Request decodeMessage;
//..
// Now, we create the proxy object to be used when decoding:
//..
//  baea_SerializableObjectProxy decodeProxy;
//..
// Then, we use the 'makeDecodeProxy' method to populate 'decodeProxy' to
// represent the object that we would like to decode to.
//..
//  baea_SerializableObjectProxyUtil::makeDecodeProxy(&decodeProxy,
//                                                    &decodeMessage);
//..
// Next, we setup the decoder and decode the message:
//..
//  baexml_DecoderOptions dOptions;
//  baexml_MiniReader reader;
//  baexml_Decoder decoder(&dOptions, &reader);
//
//  bdesb_FixedMemInStreamBuf isb(xmlString, strlen(xmlString));
//  decoder.decode(&isb, &decodeProxy);
//..
// Finally, we verify the 'decodeMessage' contains the expected values.
//..
//  assert(true == decodeMessage.isSimpleRequestValue());
//  assert("Hello, world!" == decodeMessage.simpleRequest().data());
//  assert(13 == decodeMessage.simpleRequest().responseLength());
//..

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BAEA_SERIALIZABLEOBJECTPROXY
#include <baea_serializableobjectproxy.h>
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include <bslalg_typetraits.h>
#endif

namespace BloombergLP {

class baea_SerializableObjectProxyUtil;
class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy;
class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy;
class baea_SerializableObjectProxyUtil_SequenceAccessorProxy;
class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy;

template <typename TYPE, bool HAS_ELEMENTS>
class baea_SerializableObjectProxyUtil_SequenceLoader;

                     // ==================================
                     // class baea_SerializableObjectProxy
                     // ==================================

class baea_SerializableObjectProxyUtil {
    // This class provides a namespace for utilities that configure
    // 'baea_SerializableObjectProxy' objects to represent a 'bdeat'-compliant
    // object.

    // PRIVATE CLASS METHODS
    template<typename ENUMERATION>
    static int enumSetter(void *object, int intValue);
        // Set the specified Enumeration 'object' (assumed to be of the
        // parameterized 'ENUMERATION') to the specified 'intValue'.  Return 0
        // on success, and a non-zero value otherwise.  The behavior is
        // undefined unless 'object' refers to an object of the parameterized
        // 'ENUMERATION'.  'ENUMERATION' shall be a 'bdeat' Enumeration type.
        // Note that this method is an implementation of
        // 'baea_SerializableObjectProxyFunctions::IntSetter'.

    template<typename ENUMERATION>
    static int enumStringSetter(void       *object,
                                const char *stringValue,
                                int         stringLength);
        // Set the specified Enumeration 'object' (assumed to be of the
        // parameterized 'ENUMERATION') to the specified 'stringValue' of the
        // specified 'stringLength'.  Return 0 on success, and a non-zero value
        // otherwise.  The behavior is undefined unless 'object' refers to an
        // object of the parameterized 'ENUMERATION'.  'ENUMERATION' shall be a
        // 'bdeat' Enumeration type.  Note that this method is an
        // implementation of
        // 'baea_SerializableObjectProxyFunctions::StringSetter'.

    template<typename NULLABLE>
    static void toggleValueFn(void *object);
        // Toggle the null state of the specified 'object' (assumed to be of 
        // the parameterized 'NULLABLE' type), so that if it is currently 
        // null, it is made non-null; and it is made null otherwise.  
        // 'NULLABLE' shall be an instantiation of 'bdeut_NullableValue' or
        // 'bdeut_NullableAllocatedValue'.  The behavior is undefined unless
        // 'object' is the address of a valid 'NULLABLE' object.  Note that
        // this method is an implementation of
        // 'baea_SerializableObjectProxyFunctions::NullToggler'.

    template<typename NULLABLE>
    static void *fetchValueFn(void *object);
        // Return the address of the value contained within the specified
        // 'object' (assumed to be of the parameterized 'NULLABLE' type) if
        // 'object' is not null, and 0 otherwise.  'NULLABLE' shall be a
        // 'bdeat' Nullable type.  The behavior is undefined unless 'NULLABLE'
        // is 'bdeut_NullableValue' or 'bdeut_NullableAllocatedValue' and
        // 'object' refers a 'NULLABLE' object.  Note that this method is an
        // implementation of
        // 'baea_SerializableObjectProxyFunctions::ObjectFetcher'.

    template<typename VECTOR>
    static void vectorResizeFn(void         *object,
                               void        **newBegin,
                               bsl::size_t   newSize);
        // Resize the specified 'object' (assumed to be of the
        // parameterized 'VECTOR' type), to the specified 'newSize', and load,
        // into the specified 'newBegin', the address of the first element in
        // the newly resized vector, or 0 if 'newSize' is 0.  The behavior is
        // undefined unless 'VECTOR' is 'bsl::vector' and 'object' refers to a
        // 'VECTOR' object.  Note that this is an implementation of
        // 'baea_SerializableObjectProxyFunctions::Resizer'.

    template<typename SEQUENCE>
    static void sequenceAccessorFn(
                             baea_SerializableObjectProxy        *proxy,
                             const baea_SerializableObjectProxy&  object,
                             int                                  attributeId);
        // Configure the specified 'proxy' to represent the element with the
        // specified 'attributeId' within the Sequence object (assumed to be of
        // the parameterized 'SEQUENCE') represented by the specified 'object',
        // so that it can be used for encoding.  'SEQUENCE' shall be a 'bdeat'
        // Sequence type.  Note that this is an implementation of
        // 'baea_SerializableObjectProxyFunctions::ElementLoader'.

    template<typename SEQUENCE>
    static void sequenceManipulatorFn(
                             baea_SerializableObjectProxy        *proxy,
                             const baea_SerializableObjectProxy&  object,
                             int                                  attributeId);
        // Configure the specified 'proxy' to represent the element with the
        // specified 'attributeId' within the Sequence object (assumed to of
        // the parameterized 'SEQUENCE') represented by the specified 'object'
        // so that it can be used for decoding.  'SEQUENCE' shall be a 'bdeat'
        // Sequence type.  Note that this is an implementation of
        // 'baea_SerializableObjectProxyFunctions::ElementLoader'.

    template<typename CHOICE>
    static int choiceManipulatorFn(
                            baea_SerializableObjectProxy    *proxy,
                            void                            *object,
                            const bdeat_SelectionInfo      **selectionInfoPtr);
        // Configure the specified 'proxy' to represent the current selection
        // of the specified Choice 'object' (assumed to be of the parameterized
        // 'CHOICE'), and load, into the specified 'selectionInfoPtr', the
        // address of the 'bdeat_SelectionInfo' for that selection.  
        // Return 0 on success, and a non-zero value otherwise.  This operation
        // will not succeed if 'object' is an unselected Choice.  In the case
        // of an error, 'proxy' and 'selectInfoPtr' are left in a valid but
        // unspecified state.  'CHOICE' shall be a 'bdeat' Choice type.  The 
        // behavior is undefined unless 'object' is the address of a valid
        // 'CHOICE' object.  Note that this is an implementation of 
        // 'baea_SerializableObjectProxyFunctions::SelectionLoader'.

    template<typename CHOICE>
    static int choiceChooserFn(void* object, int selectionId);
        // Change the selection of the specified Choice 'object' (assumed to be
        // of the parameterized 'CHOICE') to the specified 'selectionId'.
        // Return 0 on success, and a non-zero value otherwise.  'CHOICE' shall
        // be a 'bdeat' Choice type.  The behavior is undefined unless 'object'
        // refers to a 'CHOICE' object.  Note that this function is an
        // implementation of
        // 'baea_SerializableObjectProxyFunctions::Chooser'.

    // Dispatch functions for makeEncodeProxy

    template<typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy       *proxy,
                                bdeut_NullableAllocatedValue<TYPE> *object,
                                bdeat_TypeCategory::NullableValue);
    template<typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                bdeut_NullableValue<TYPE>    *object,
                                bdeat_TypeCategory::NullableValue);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Enumeration);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::CustomizedType);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Choice);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Sequence);
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                bsl::vector<char>            *object,
                                bdeat_TypeCategory::Array);
    template <typename ELEMENT_TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy   *proxy,
                                bsl::vector<ELEMENT_TYPE>      *object,
                                bdeat_TypeCategory::Array);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Simple);
        // Configure the specified 'proxy' to represent the specified
        // 'object' so that it can be used for encoding based on the type of
        // the unnamed "dispatch" argument.  Note that this method is invoked
        // by 'makeEncodeProxy' or 'makeEncodeProxyRaw'.

    template <typename TYPE>
    static void makeEncodeProxyRaw(baea_SerializableObjectProxy *proxy,
                                   void                         *object);
        // Configure the specified 'proxy' to represent the specified 'object'
        // of the parameterized 'TYPE' so that it can be used for encoding.
        // Note that this function is an implementation of
        // 'baea_SerializableObjectProxyFunctions::Loader'.


    // Dispatch functions for makeDecodeProxy

    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Enumeration);
    template<typename TYPE>
    static void makeDecodeProxy(
                              baea_SerializableObjectProxy       *proxy,
                              bdeut_NullableAllocatedValue<TYPE> *object,
                              bdeat_TypeCategory::NullableValue);
    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                bdeut_NullableValue<TYPE>    *object,
                                bdeat_TypeCategory::NullableValue);
    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Choice);
    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Sequence);
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                bsl::vector<char>       *object,
                                bdeat_TypeCategory::Array);
    template<typename ELEMENT_TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                bsl::vector<ELEMENT_TYPE>    *object,
                                bdeat_TypeCategory::Array);
    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::CustomizedType);
    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Simple);
        // Configure the specified 'proxy' to represent the specified 'object'
        // so that it can be used for decoding based on the type of the unnamed
        // "dispatch" argument.  Note that this method is invoked by
        // 'makeDecodeProxy' or 'makeEncodeProxyRaw'.

    template <typename TYPE>
    static void makeDecodeProxyRaw(baea_SerializableObjectProxy *proxy,
                                   void                         *object);
        // Configure the specified 'proxy' to represent the specified 'object'
        // so that it can be used for decoding.  Note that this function is an
        // implementation of
        // 'baea_SerializableObjectProxyFunctions::Loader'.

    static void makeProxyForEmptySequence(
                                      baea_SerializableObjectProxy *proxy,
                                      const char                   *className);
        // Configure the specified 'proxy' to represent an empty sequence
        // (i.e., one without any elements) having the specified 'className'.

    // FRIENDS
    friend class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy;
    friend class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy;
    friend class baea_SerializableObjectProxyUtil_SequenceAccessorProxy;
    friend class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy;
    template <typename TYPE, bool HAS_ELEMENTS>
    friend class baea_SerializableObjectProxyUtil_SequenceLoader;

  public:
    // CLASS METHODS
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object);
        // Configure the specified 'proxy' to represent the specified
        // 'bdeat'-compliant 'object' of the parameterized 'TYPE' so that it
        // can be used for encoding.  'TYPE' shall be a 'bdeat' type.  The
        // behavior is undefined 'object' refers to a 'TYPE' object.

    template <typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object);
        // Configure the specified 'proxy' to represent the specified
        // 'bdeat'-compliant 'object' of the parameterized 'TYPE' for decoding.
        // The behavior is undefined unless 'object' refers to a 'TYPE' object.
        // 'TYPE' shall be a 'bdeat' type.  Note that 'reset' may need to be
        // invoked on 'object' prior to decoding into it, because the 'reset'
        // method of 'proxy' has no effect.
};

         // ==========================================================
         // class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy
         // ==========================================================

class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy {
    // [!PRIVATE!] This class implements a functor that will populate a
    // 'baea_SerializableObjectProxy' for encoding the current selection of a
    // Choice object.

    baea_SerializableObjectProxy *d_proxy_p;      // proxy to populate
                                                  // (held, not owned)

    const char                   *d_className;    // name of selection

  public:
    // CREATORS
    baea_SerializableObjectProxyUtil_ChoiceAccessorProxy(
                                     baea_SerializableObjectProxy *proxy,
                                     const char                   *className);
        // Create a 'baea_SerializableObjectProxyUtil_ChoiceAccessorProxy'
        // object that will be used to populate the specified 'proxy' with
        // the current selection of a type corresponding to 'className'.

    // MANIPULATORS
    template <typename SELECTED_TYPE>
    int operator()(const SELECTED_TYPE&       selection,
                   const bdeat_SelectionInfo& info);
        // Populate the proxy supplied at construction to represent the
        // specified 'selection' (having the specified 'info') for encoding.
        // Return 0.
};

      // =============================================================
      // class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
      // =============================================================

class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy {
    // [!PRIVATE!] This class implements a functor that will extract the
    // 'bdeat_SelectionInfo' corresponding to the selection of a Choice object,
    // and to populate a 'baea_SerializableObjectProxy' for decoding into that
    // selection.

    baea_SerializableObjectProxy *d_proxy_p;          // proxy to populate
    const bdeat_SelectionInfo    *d_selectionInfo_p;  // info for current
                                                      // selection

  public:
    // CREATORS
    explicit baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy(
                                          baea_SerializableObjectProxy *proxy);
        // Create a 'baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy'
        // object that will be used to populate the specified 'proxy'.

    // MANIPULATORS
    template <typename SELECTED_TYPE>
    int operator()(const SELECTED_TYPE&       selection,
                   const bdeat_SelectionInfo& info);
        // Populate the proxy supplied at construction to represent the
        // specified 'selection' for decoding, and save the address of 'info'
        // as 'selectionInfoPtr' for later use.  Return 0.

    // ACCESSORS
    const bdeat_SelectionInfo *selectionInfoPtr() const;
        // Return the address of the 'bdeat_SelectionInfo' object that was
        // passed to the function-call operator of this object; or 0 if
        // the function-call operator has not been invoked.
};

         // ============================================================
         // class baea_SerializableObjectProxyUtil_SequenceAccessorProxy
         // ============================================================

class baea_SerializableObjectProxyUtil_SequenceAccessorProxy {
    // [!PRIVATE!] This class implements a functor that will populate a
    // 'baea_SerializableObjectProxy' for encoding the elements of a Sequence
    // object.

    baea_SerializableObjectProxy *d_proxy_p;  // proxy to populate (held, not
                                              // owned)

  public:
    // CREATORS
    explicit baea_SerializableObjectProxyUtil_SequenceAccessorProxy(
                                          baea_SerializableObjectProxy *proxy);
        // Create a 'baea_SerializableObjectProxyUtil_SequenceAccessorProxy'
        // object that will be used to populate the specified 'proxy'.

    // MANIPULATORS
    template <typename ELEMENT_TYPE>
    int operator()(const ELEMENT_TYPE& element, const bdeat_AttributeInfo&);
        // Populate the proxy supplied at construction to represent the
        // specified 'element' for encoding.  Return 0.
};

         // ===============================================================
         // class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy
         // ===============================================================

class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy {
    // [!PRIVATE!] This class implements a functor that will populate a
    // baea_SerializableObjectProxy for decoding into the elements of a
    // Sequence object.

    baea_SerializableObjectProxy *d_proxy_p;  // proxy to populate (held, not
                                              // owned)

  public:
    // CREATORS
    explicit baea_SerializableObjectProxyUtil_SequenceManipulatorProxy(
                                          baea_SerializableObjectProxy *proxy);
        // Create a 'baea_SerializableObjectProxyUtil_SequenceManipulatorProxy'
        // object that will be used to populate the specified 'proxy'.

    // MANIPULATORS
    template <typename ELEMENT_TYPE>
    int operator()(const ELEMENT_TYPE& element, const bdeat_AttributeInfo&);
        // Populate the proxy supplied at construction to represent the
        // specified 'element' for decoding.  Return 0.
};

         // =====================================================
         // class baea_SerializableObjectProxyUtil_SequenceLoader
         // =====================================================

template<typename SEQUENCE>
class baea_SerializableObjectProxyUtil_SequenceLoader<SEQUENCE, true> {
    // [!PRIVATE!] This class provides utilities to configure a
    // 'baea_SerializableObjectProxy' object to represent a Sequence object.
    // This specialization is for normal sequences (those that have elements).

  public:
    // CLASS METHODS
    static void loadAccessor(baea_SerializableObjectProxy *proxy,
                             void                         *object);
        // Populate the specified 'proxy' with the specified 'object' for
        // encoding.

    static void loadManipulator(baea_SerializableObjectProxy *proxy,
                                void                         *object);
        // Populate the specified 'proxy' with the specified 'object' for
        // decoding.
};

template <typename SEQUENCE>
class baea_SerializableObjectProxyUtil_SequenceLoader<SEQUENCE, false> {
    // [!PRIVATE!] This class provides utilities to configure a
    // 'baea_SerializableObjectProxy' object to represent a Sequence object.
    // This specialization is for sequences without any elements.  Such
    // sequences may not have an ATTRIBUTE_INFO_ARRAY class member defined, and
    // thus need special handling.
    //
    // Note that the implementation of loadAccessor() and loadManipulator()
    // are identical in this specialization, but not in the general case.

  public:
    // CLASS METHODS
    static void loadAccessor(baea_SerializableObjectProxy *proxy, void *);
        // Populate the specified 'proxy' for encoding.

    static void loadManipulator(baea_SerializableObjectProxy *proxy, void *);
        // Populate the specified 'proxy' for decoding.
};

// ============================================================================
//                  INLINE AND TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

template<typename ENUMERATION>
int baea_SerializableObjectProxyUtil::enumSetter(void *object, int intValue)
{
    return bdeat_BasicEnumerationWrapper<ENUMERATION>::Wrapper::fromInt(
                                   reinterpret_cast<ENUMERATION *>(object),
                                   intValue);

}

template<typename ENUMERATION>
int baea_SerializableObjectProxyUtil::enumStringSetter(
                                                      void       *object,
                                                      const char *stringValue,
                                                      int         stringLength)
{
    return bdeat_BasicEnumerationWrapper<ENUMERATION>::Wrapper::fromString(
                                       reinterpret_cast<ENUMERATION *>(object),
                                       stringValue,
                                       stringLength);
}

template <typename NULLABLE>
void baea_SerializableObjectProxyUtil::toggleValueFn(void *object)
{
    NULLABLE* nullableObj = (NULLABLE*)object;
    if (nullableObj->isNull()) {
        nullableObj->makeValue();
    }
    else {
        nullableObj->reset();
    }
}

template<typename NULLABLE>
void *baea_SerializableObjectProxyUtil::fetchValueFn(void *object)
{
    NULLABLE *nullableValue = (NULLABLE *)object;
    if (nullableValue->isNull()) {
        // We also use this function for testing for null.

        return 0;                                                     // RETURN
    }
    return &nullableValue->value();
}

template<typename TYPE>
void baea_SerializableObjectProxyUtil::sequenceAccessorFn(
                              baea_SerializableObjectProxy        *proxy,
                              const baea_SerializableObjectProxy&  object,
                              int                                  attributeId)
{
    baea_SerializableObjectProxyUtil_SequenceAccessorProxy
                                                          accessorProxy(proxy);
    bdeat_SequenceFunctions::accessAttribute(*(const TYPE *)object.object(),
                                             accessorProxy,
                                             attributeId);
}

template<typename TYPE>
void baea_SerializableObjectProxyUtil::sequenceManipulatorFn(
                              baea_SerializableObjectProxy        *proxy,
                              const baea_SerializableObjectProxy&  object,
                              int                                  attributeId)
{
    baea_SerializableObjectProxyUtil_SequenceManipulatorProxy
                                                      manipulatorProxy(proxy);
    bdeat_SequenceFunctions::accessAttribute(*(const TYPE *)object.object(),
                                             manipulatorProxy,
                                             attributeId);
}

template<typename TYPE>
int baea_SerializableObjectProxyUtil::choiceManipulatorFn(
                               baea_SerializableObjectProxy  *proxy,
                               void                          *object,
                               const bdeat_SelectionInfo    **selectionInfoPtr)
{
    baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
                                                       manipulatorProxy(proxy);

    int rc = bdeat_ChoiceFunctions::accessSelection(*(const TYPE *)object,
                                                    manipulatorProxy);
    *selectionInfoPtr = manipulatorProxy.selectionInfoPtr();
    return rc;
}

template<typename TYPE>
int baea_SerializableObjectProxyUtil::choiceChooserFn(void *object,
                                                      int   selectionId)
{
    return ((TYPE *)object)->makeSelection(selectionId);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Enumeration)
{
    proxy->loadEnumerationForDecoding(
                      object,
                      &enumSetter<TYPE>,
                      &enumStringSetter<TYPE>,
                      bdeat_BasicEnumerationWrapper<TYPE>::Wrapper
                        ::ENUMERATOR_INFO_ARRAY,
                      bdeat_BasicEnumerationWrapper<TYPE>::Wrapper
                        ::NUM_ENUMERATORS);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                    baea_SerializableObjectProxy       *proxy,
                                    bdeut_NullableAllocatedValue<TYPE> *object,
                                    bdeat_TypeCategory::NullableValue)
{
    proxy->loadNullableForEncoding(
                             (void *)(object->isNull() ? 0 : &object->value()),
                             &makeEncodeProxyRaw<TYPE>);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          bdeut_NullableValue<TYPE>    *object,
                                          bdeat_TypeCategory::NullableValue)
{
    proxy->loadNullableForEncoding(
                             (void *)(object->isNull() ? 0 : &object->value()),
                             &makeEncodeProxyRaw<TYPE>);
}


template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                    baea_SerializableObjectProxy       *proxy,
                                    bdeut_NullableAllocatedValue<TYPE> *object,
                                    bdeat_TypeCategory::NullableValue)
{
    proxy->loadNullableForDecoding(
                           object,
                           &makeDecodeProxyRaw<TYPE>,
                           &toggleValueFn<bdeut_NullableAllocatedValue<TYPE> >,
                           &fetchValueFn<bdeut_NullableAllocatedValue<TYPE> >);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          bdeut_NullableValue<TYPE>    *object,
                                          bdeat_TypeCategory::NullableValue)
{
    proxy->loadNullableForDecoding(object,
                                   &makeDecodeProxyRaw<TYPE>,
                                   &toggleValueFn<bdeut_NullableValue<TYPE> >,
                                   &fetchValueFn<bdeut_NullableValue<TYPE> >);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Choice)
{
    proxy->loadChoiceForDecoding(static_cast<int>(TYPE::NUM_SELECTIONS),
                                 object,
                                 TYPE::SELECTION_INFO_ARRAY,
                                 &choiceManipulatorFn<TYPE>,
                                 &choiceChooserFn<TYPE>);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Sequence)
{
    baea_SerializableObjectProxyUtil_SequenceLoader<TYPE,
                                              (TYPE::NUM_ATTRIBUTES > 0)>::
                                                loadManipulator(proxy, object);
}



template<typename VECTOR>
void baea_SerializableObjectProxyUtil::vectorResizeFn(void         *object,
                                                      void        **newBegin,
                                                      bsl::size_t   newSize)
{
    VECTOR *array = (VECTOR *)object;
    array->resize(newSize);
    *newBegin = newSize ? array->data() : 0;
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object)
{
    makeEncodeProxy(proxy,
                    object,
                    typename bdeat_TypeCategory::Select<TYPE>::Type());
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object)
{
    makeDecodeProxy(proxy,
                    object,
                    typename bdeat_TypeCategory::Select<TYPE>::Type());
}

inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          bsl::vector<char>            *object,
                                          bdeat_TypeCategory::Array)
{
    // Our representation for decoding into a vector<char> is the same as
    // encoding into a vector<char> because all we need is the address of the
    // vector.

    makeEncodeProxy(proxy, object, bdeat_TypeCategory::Array());
}

template<typename ELEMENT_TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                        baea_SerializableObjectProxy   *proxy,
                                        bsl::vector<ELEMENT_TYPE>      *object,
                                        bdeat_TypeCategory::Array)
{
    proxy->loadArrayForDecoding(object,
                                static_cast<int>(object->size()),
                                sizeof(ELEMENT_TYPE),
                                object->size() ? object->data() : 0,
                                &vectorResizeFn<bsl::vector<ELEMENT_TYPE> >,
                                &makeDecodeProxyRaw<ELEMENT_TYPE>);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::CustomizedType)
{
    typedef typename bdeat_CustomizedTypeFunctions::BaseType<TYPE>::Type
                                                                      BaseType;

    // 'baea_SerializableObjectProxy' contains references to the proxied
    // object.  We rely on the knowledge that codegen's 'toString', 'toInt',
    // etc methods return references to the underlying base-type member
    // variable, so that we can take the address of that reference safely.

    const BaseType& baseRef =
                     bdeat_CustomizedTypeFunctions::convertToBaseType(*object);

    makeDecodeProxy(proxy, const_cast<BaseType *>(&baseRef));
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Simple)
{
    proxy->loadSimple(object);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Enumeration)
{
    int value;
    bdeat_EnumFunctions::toInt(&value, *object);
    proxy->loadEnumerationForEncoding(
                       value,
                       bdeat_BasicEnumerationWrapper<TYPE>::Wrapper
                         ::ENUMERATOR_INFO_ARRAY,
                       bdeat_BasicEnumerationWrapper<TYPE>::Wrapper
                         ::NUM_ENUMERATORS);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::CustomizedType)
{
    typedef typename
        bdeat_CustomizedTypeFunctions::BaseType<TYPE>::Type BaseType;

    // 'baea_SerializableObjectProxy' contains references to the proxied
    // object.  We rely on the knowledge that codegen's toString(), toInt(),
    // etc methods return references to the underlying base-type member
    // variable, so that we can take the address of that reference safely.

    const BaseType& baseRef =
                     bdeat_CustomizedTypeFunctions::convertToBaseType(*object);

    makeEncodeProxy(proxy, const_cast<BaseType *>(&baseRef));
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Choice)
{
    baea_SerializableObjectProxyUtil_ChoiceAccessorProxy accessorProxy(
                                                         proxy,
                                                         TYPE::CLASS_NAME);

    object->accessSelection(accessorProxy);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Sequence)
{
    baea_SerializableObjectProxyUtil_SequenceLoader<TYPE,
                                                    (TYPE::NUM_ATTRIBUTES > 0)>
                                                 ::loadAccessor(proxy, object);
}

template <typename ELEMENT_TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          bsl::vector<ELEMENT_TYPE>    *object,
                                          bdeat_TypeCategory::Array)
{
    proxy->loadArrayForEncoding(static_cast<int>(object->size()),
                                sizeof(ELEMENT_TYPE),
                                object->size() ? object->data() : 0,
                                &makeEncodeProxyRaw<ELEMENT_TYPE>);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Simple)
{
    proxy->loadSimple(object);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxyRaw(
                                          baea_SerializableObjectProxy *proxy,
                                          void                         *object)
{
    makeEncodeProxy(proxy,
                    reinterpret_cast<TYPE *>(object),
                    typename bdeat_TypeCategory::Select<TYPE>::Type());

    BSLS_ASSERT_SAFE(bdeat_TypeCategory::BDEAT_DYNAMIC_CATEGORY !=
                                                            proxy->category());
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxyRaw(
                                          baea_SerializableObjectProxy *proxy,
                                          void                         *object)
{
    makeDecodeProxy(proxy,
                    (TYPE *)object,
                    typename bdeat_TypeCategory::Select<TYPE>::Type());
    BSLS_ASSERT_SAFE(bdeat_TypeCategory::BDEAT_DYNAMIC_CATEGORY !=
                                                            proxy->category());
}

         // ----------------------------------------------------------
         // class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy
         // ----------------------------------------------------------

// CREATORS
inline
baea_SerializableObjectProxyUtil_ChoiceAccessorProxy
::baea_SerializableObjectProxyUtil_ChoiceAccessorProxy(
                                     baea_SerializableObjectProxy *proxy,
                                     const char                   *className)
: d_proxy_p(proxy)
, d_className(className)
{
}

// MANIPULATORS
template <typename SELECTED_TYPE>
inline
int baea_SerializableObjectProxyUtil_ChoiceAccessorProxy::operator()(
                                          const SELECTED_TYPE&       selection,
                                          const bdeat_SelectionInfo& info)
{
    d_proxy_p->loadChoiceForEncoding((void *) const_cast<SELECTED_TYPE *>(
                                                                   &selection),
                                     &info,
                                     d_className,
                                     &baea_SerializableObjectProxyUtil::
                                            makeEncodeProxyRaw<SELECTED_TYPE>);
    return 0;
}

      // -------------------------------------------------------------
      // class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
      // -------------------------------------------------------------

// CREATORS
inline
baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
::baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy(
                                           baea_SerializableObjectProxy *proxy)
: d_proxy_p(proxy)
, d_selectionInfo_p(0)
{
}

// MANIPULATORS
template <typename SELECTED_TYPE>
inline
int baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy::operator()(
                                          const SELECTED_TYPE&       selection,
                                          const bdeat_SelectionInfo& info)
{
    baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                      d_proxy_p,
                                      const_cast<SELECTED_TYPE *>(&selection));
    d_selectionInfo_p = &info;
    return 0;
}

// ACCESSORS
inline
const bdeat_SelectionInfo *
baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
                                                     ::selectionInfoPtr() const
{
    return d_selectionInfo_p;
}

         // ------------------------------------------------------------
         // class baea_SerializableObjectProxyUtil_SequenceAccessorProxy
         // ------------------------------------------------------------

// CREATORS
inline
baea_SerializableObjectProxyUtil_SequenceAccessorProxy
::baea_SerializableObjectProxyUtil_SequenceAccessorProxy(
                                           baea_SerializableObjectProxy *proxy)
: d_proxy_p(proxy)
{
}

// MANIPULATORS
template <typename ELEMENT_TYPE>
inline
int baea_SerializableObjectProxyUtil_SequenceAccessorProxy::operator()(
                                                   const ELEMENT_TYPE& element,
                                                   const bdeat_AttributeInfo&)
{
    baea_SerializableObjectProxyUtil::makeEncodeProxyRaw<ELEMENT_TYPE>(
                              d_proxy_p,
                              (void *) const_cast<ELEMENT_TYPE *>(&element));
    return 0;
}

         // ---------------------------------------------------------------
         // class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy
         // ---------------------------------------------------------------

// CREATORS
inline
baea_SerializableObjectProxyUtil_SequenceManipulatorProxy
::baea_SerializableObjectProxyUtil_SequenceManipulatorProxy (
                                           baea_SerializableObjectProxy *proxy)
: d_proxy_p(proxy)
{
}

// MANIPULATORS
template <typename ELEMENT_TYPE>
inline
int baea_SerializableObjectProxyUtil_SequenceManipulatorProxy::operator() (
                                                   const ELEMENT_TYPE& element,
                                                   const bdeat_AttributeInfo&)
{
    baea_SerializableObjectProxyUtil::makeDecodeProxyRaw<ELEMENT_TYPE>(
        d_proxy_p,
        (void *) const_cast<ELEMENT_TYPE *>(&element));
    return 0;
}

         // -----------------------------------------------------
         // class baea_SerializableObjectProxyUtil_SequenceLoader
         // -----------------------------------------------------

// CLASS METHODS
template<typename SEQUENCE>
inline
void baea_SerializableObjectProxyUtil_SequenceLoader<SEQUENCE, true>::
                             loadAccessor(baea_SerializableObjectProxy *proxy,
                                          void                         *object)
{
    proxy->loadSequence(
           static_cast<int>(SEQUENCE::NUM_ATTRIBUTES),
           object,
           SEQUENCE::ATTRIBUTE_INFO_ARRAY,
           SEQUENCE::CLASS_NAME,
           &baea_SerializableObjectProxyUtil::sequenceAccessorFn<SEQUENCE>);
}

// MANIPULATORS
template<typename SEQUENCE>
inline
void baea_SerializableObjectProxyUtil_SequenceLoader<SEQUENCE, true>
           ::loadManipulator(baea_SerializableObjectProxy *proxy, void *object)
{
    proxy->loadSequence(
           static_cast<int>(SEQUENCE::NUM_ATTRIBUTES),
           object,
           SEQUENCE::ATTRIBUTE_INFO_ARRAY,
           SEQUENCE::CLASS_NAME,
           &baea_SerializableObjectProxyUtil::sequenceManipulatorFn<SEQUENCE>);
}

template<typename SEQUENCE>
inline
void baea_SerializableObjectProxyUtil_SequenceLoader<SEQUENCE, false>
                    ::loadAccessor(baea_SerializableObjectProxy *proxy, void *)
{
    baea_SerializableObjectProxyUtil::makeProxyForEmptySequence(
                                                         proxy,
                                                         SEQUENCE::CLASS_NAME);
}

template<typename SEQUENCE>
inline
void baea_SerializableObjectProxyUtil_SequenceLoader<SEQUENCE, false>
                 ::loadManipulator(baea_SerializableObjectProxy *proxy, void *)
{
    baea_SerializableObjectProxyUtil::makeProxyForEmptySequence(
                                                         proxy,
                                                         SEQUENCE::CLASS_NAME);
}

}  // close namespace BloombergLP

#endif

// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2011
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ------------------------------ END-OF-FILE ---------------------------------
