// baea_serializableobjectproxyutil.h                                 -*-C++-*-
#ifndef INCLUDED_BAEA_SERIALIZABLEOBJECTPROXYUTIL
#define INCLUDED_BAEA_SERIALIZABLEOBJECTPROXYUTIL

#include <bdes_ident.h>
BDES_IDENT_RCSID(baea_serializableobjectproxyutil_h,"$Id$ $CSID$")
BDES_IDENT_PRAGMA_ONCE

//@PURPOSE: Provide utilities for configuring a 'baea_SerializableObjectProxy'.
//
//@AUTHOR: David Schumann (dschumann1)
//
//@CLASSES:
//  baea_SerializableObjectProxyUtil: utilities for configuring a proxy object
//
//@SEE_ALSO: baea_serializableobjectproxy, bdeat_typecategory, bdem_berencoder
//
//@DESCRIPTION: This component provides a suite of functions for configuring a
// 'baea_SerializableObjectProxy' object so that it represents an object
// generated by "bas_codegen.pl" for the purpose of encoding or decoding a
// represented object.  Encoding/decoding a 'baea_SerializableObjectProxy'
// using a 'bdeat'-style encoder/decoder involves expanding the template
// functions of that encoder/decoder for only one type rather than for many
// types, and thus can be expected to produce substantially less object code at
// a lower compilation cost.  Instead, the type-specific logic is supplied by
// template expansions of functions in this component, which are generally much
// simpler and smaller.
//
// The type categories of the 'bdeat' package are used throughout this
// component.  The terms "Array", "Choice", "Customized", "Enumeration",
// "Nullable", "Sequence", and "Simple" all refer to the corresponding
// 'bdeat' categories.
//
///Proxy Object Structure
///----------------------
// 'baea_SerializableObjectProxyUtil' provides functions that configure a
// 'baea_SerializableObjectProxy' object with the necessary information to
// encode from, or decode into, the supplied 'bdeat'-compliant proxied object.
// If the proxied object holds another object -- as is the case for Sequence,
// Choice, Nullable, and Array objects -- the proxy holds a pointer to a
// function that can populate another a 'baea_SerializableObjectProxy' to
// describe that contained object.
//
// This can be thought of as a form of "lazy evaluation".  An example may
// help illustrate the approach.  We start by outlining the definition of
// a 'MyChoiceType' type generated by "bas_codegen.pl", having 'MySequenceType'
// as one of its selections, that we wish to encode/decode:
//..
//  class MyChoiceType {
//    union {
//      bsls_ObjectBuffer<MySequenceType> d_mySequence;  // selection 0
//      // ...
//    };
//    // ...
//    MySequenceType& makeMySequenceValue();
//    // ...
//  };
//..
// Now we define an instance of 'MyChoiceType', 'myChoice', and an initially
// empty 'baea_SerializableObjectProxy', 'myProxy', that we will use for
// encoding 'myChoice'.
//..
//  MyChoiceType myChoice;
//  myChoice.makeMySequenceValue();
//  baea_SerializableObjectProxy myProxy;
//..
// If we then invoke 'baea_SerializableObjectProxyUtil::makeEncodeProxy' on
// 'myChoice', it will populate 'myProxy' in the following way:
//..
//  ,----------------------------------.
//  |  baea_SerializableObjectProxy    |
//  |    void         *d_object_p;   --+-->[ &myChoice.d_mySequence ]
//  |    Variant<...>  d_objectInfo; --+--.
//  `----------------------------------'  |
//                                        |
//                                        V
//  ,--------------------------------------------.
//  |  ChoiceEncodeInfo                          |
//  |    bdeat_SelectionInfo *d_selection;   ----+--> [ selection description ]
//  |    const char          *d_classname_p; ----+--> "MyChoiceType"
//  |    Loader               d_loader;      --. |
//  `------------------------------------------|-'
//                                             |
//                                             V
//  ,-----------------------------------------------------------------------.
//  |  baea_SerializableObjectProxyUtil::makeEncodeProxyRaw<MySequenceType> |
//  |    A function that, when invoked, will configure a                    |
//  |    'baea_SerializableObjectProxy' for 'myChoice.d_mySequence'.        |
//  `-----------------------------------------------------------------------'
//..
// So for a Choice object, the proxy object populated for encoding that Choice
// contains: a pointer to the underlying selection, information about that
// choice, and a pointer to a function that, when invoked, will populate
// another proxy for the selection.  That function is not invoked until the
// object is later encoded.  A similar structure is created for
// encoding/decoding any container type, but the details vary slightly based
// on the type and the direction (encoding/decoding).
//
///Treatment of "Customized" Types
///-------------------------------
// The 'bdeat' package has a concept of Customized type.  Types in this
// category contain a restricted value of some other type.  A common example is
// a string of restricted length.  Customized types are required to have
// conversion methods for their underlying type -- for example, a Customized
// type based on 'bsl::string' is required to have a 'toString' method.
//
// 'baea_SerializableObjectProxyUtil' makes the assumption that such methods
// return 'const' references to a member variable of the underlying type, so
// that it is safe to take the address of the return value and store it for
// later use.  In this way, 'toString' is treated by this component as an
// accessor method for a member variable of type 'bsl::string' assumed to exist
// within the type.  This is not required by the 'bdeat' package -- a
// Customized type based on 'bsl::string' is allowed to return a 'bsl::string'
// by value from 'toString'.  Such types cannot be used with this component, or
// undefined behavior will result.  'bas_codegen.pl' emits Customized types
// that return 'const' references from their conversion methods and are thus
// compatible with this component.
//
///Usage Example
///-------------
// In this section we show the intended usage of this component.
//
///Example 1: Serializing a BAS Request
/// - - - - - - - - - - - - - - - - - -
// In this example, we demonstrate how to encode a BAS message object using
// 'baea_SerializableObjectProxy' to reduce the complexity of the resulting
// object code as compared with encoding and decoding the message object
// directly.
//
// Suppose we are given a BAS message component with a request type named
// 'SimpleRequest' which has the field 'data' of type 'bsl::string' and
// 'responseLength' of type 'int'.  First, we create a 'Request' object named
// 'encodeMessage' that we would like to encode:
//..
//  baea::Request encodeMessage;
//  encodeMessage.makeSimpleRequest();
//  encodeMessage.simpleRequest().data() = "Test message";
//  encodeMessage.simpleRequest().responseLength() = 12;
//..
// Then, we create a proxy object to be used when encoding:
//..
//  baea_SerializableObjectProxy encodeProxy;
//..
// Next, we use the 'makeEncodeProxy' method to populate 'encodeProxy' to
// represent the object that we would like to encode.
//..
//  baea_SerializableObjectProxyUtil::makeEncodeProxy(&encodeProxy,
//                                                    &encodeMessage);
//..
// Now, we setup the encoder and encode the request into a memory stream
// buffer:
//..
//  baexml_EncoderOptions eOptions;
//  baexml_Encoder encoder(&eOptions);
//  bdesb_MemOutStreamBuf osb;
//  encoder.encode(&osb, encodeProxy);
//..
// Finally, we can print out the XML string that is stored in the memory
// buffer:
//..
//  std::cout << osb.data() << std::endl;
//..
//
///Example 2: Decoding an XML String
///- - - - - - - - - - - - - - - - -
// In this example, we demonstrate how to decode a XML string using the
// 'baea_SerializableObjectProxy'.
//
// First, we create the XML string that we would like to decode into a
// 'SimpleRequest' that was described in the previous example:
//..
//  const char *xmlString =
//      "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>"
//          "<Request xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">"
//          "<simpleRequest>"
//              "<data>Hello, world!</data>"
//              "<responseLength>13</responseLength>"
//          "</simpleRequest>"
//      "</Request>";
//..
// Then, we create the request object we would like the XML string to be
// decoded into.
//..
//  baea::Request decodeMessage;
//..
// Next, we create the proxy object to be used when decoding:
//..
//  baea_SerializableObjectProxy decodeProxy;
//..
// Then, we use the 'makeDecodeProxy' method to populate 'decodeProxy' to
// represent the object that we would like to decode to.
//..
//  baea_SerializableObjectProxyUtil::makeDecodeProxy(&decodeProxy,
//                                                    &decodeMessage);
//..
// Next, we setup the decoder and decode the message:
//..
//  baexml_DecoderOptions dOptions;
//  baexml_MiniReader reader;
//  baexml_Decoder decoder(&dOptions, &reader);
//
//  bdesb_FixedMemInStreamBuf isb(xmlString, strlen(xmlString));
//  decoder.decode(&isb, &decodeProxy);
//..
// Finally, we verify the 'decodeMessage' contains the expected values.
//..
//  assert(true == decodeMessage.isSimpleRequestValue());
//  assert("Hello, world!" == decodeMessage.simpleRequest().data());
//  assert(13 == decodeMessage.simpleRequest().responseLength());
//..

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BAEA_SERIALIZABLEOBJECTPROXY
#include <baea_serializableobjectproxy.h>
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include <bslalg_typetraits.h>
#endif

namespace BloombergLP {

class baea_SerializableObjectProxyUtil;
class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy;
class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy;
class baea_SerializableObjectProxyUtil_SequenceAccessorProxy;
class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy;

template <typename TYPE, bool HAS_ELEMENTS>
class baea_SerializableObjectProxyUtil_SequenceLoader;

                     // ==================================
                     // class baea_SerializableObjectProxy
                     // ==================================

class baea_SerializableObjectProxyUtil {
    // This class provides a namespace for utilities that configure
    // 'baea_SerializableObjectProxy' objects to represent a 'bdeat'-compliant
    // object.

    // PRIVATE CLASS METHODS
    template<typename VALUE_TYPE>
    static int enumSetter(void *object, int intValue);
        // Set the specified Enumeration 'object' (assumed to be of the
        // parameterized 'VALUE_TYPE') to the specified 'intValue'.  Return 0
        // on success, and a non-zero value otherwise.  The behavior is
        // undefined unless 'object' refers to an object of the parameterized
        // 'VALUE_TYPE'.  Note that this method is an implementation of
        // 'baea_SerializableObjectProxyFunctions::IntSetter'.

    template<typename VALUE_TYPE>
    static int enumStringSetter(void       *object,
                                const char *stringValue,
                                int         stringLength);
        // Set the specified Enumeration 'object' (assumed to be of the
        // parameterized 'VALUE_TYPE') to the specified 'stringValue' of the
        // specified 'stringLength'.  Return 0 on success, and a non-zero value
        // otherwise.  The behavior is undefined unless 'object' refers to an
        // object of the parameterized 'VALUE_TYPE'.  Note that this method is
        // an implementation of
        // 'baea_SerializableObjectProxyFunctions::StringSetter'.

    template<typename NULLABLE>
    static void makeValueFn(void *object);
        // Make the specified 'object' (assumed to be of the parameterized
        // 'NULLABLE' type) non-null.  The behavior is undefined unless
        // 'NULLABLE' is 'bdeut_NullableValue' or
        // 'bdeut_NullableAllocatedValue', and 'object' refers to a 'NULLABLE'
        // object.  Note that this method is an implementation of
        // 'baea_SerializableObjectProxyFunctions::ValueMaker'.

    template<typename NULLABLE>
    static void *fetchValueFn(void *object);
        // Return the address of the value contained within the specified
        // 'object' (assumed to be of the parameterized 'NULLABLE' type) if
        // 'object' is not null, and 0 otherwise.  The behavior is undefined
        // unless 'NULLABLE' is 'bdeut_NullableValue' or
        // 'bdeut_NullableAllocatedValue' and 'object' refers a 'NULLABLE'
        // object.  Note that this method is an implementation of
        // 'baea_SerializableObjectProxyFunctions::ObjectFetcher'.

    template<typename VECTOR>
    static void vectorResizeFn(void         *object,
                               void        **newBegin,
                               bsl::size_t   newSize);
        // Resize the specified 'object' (assumed to be of the
        // parameterized 'VECTOR' type), to the specified 'newSize', and load,
        // into the specified 'newBegin', the address of the first element in
        // the newly resized vector, or 0 if 'newSize == 0'.  The behavior is
        // undefined unless 'VECTOR' is 'bsl::vector' and 'object' refers to a
        // 'VECTOR' object.  Note that this is an implementation of
        // 'baea_SerializableObjectProxyFunctions::Resizer'.

    template<typename TYPE>
    static void sequenceAccessorFn(
                             baea_SerializableObjectProxy        *proxy,
                             const baea_SerializableObjectProxy&  object,
                             int                                  attributeId);
        // Configure the specified 'proxy' to represent the element with the
        // specified 'attributeId' within the Sequence object (assumed to be of
        // the parameterized 'TYPE') represented by the specified 'object', so
        // that it can be used for encoding.  Note that this is an
        // implementation of
        // 'baea_SerializableObjectProxyFunctions::ElementLoader'.

    template<typename TYPE>
    static void sequenceManipulatorFn(
                             baea_SerializableObjectProxy        *proxy,
                             const baea_SerializableObjectProxy&  object,
                             int                                  attributeId);
        // Configure the specified 'proxy' to represent the element with the
        // specified 'attributeId' within the Sequence object (assumed to of
        // the parameterized 'TYPE') represented by the specified 'object' so
        // that it can be used for decoding.  Note that this is an
        // implementation of
        // 'baea_SerializableObjectProxyFunctions::ElementLoader'.

    template<typename TYPE>
    static void choiceManipulatorFn(
                            baea_SerializableObjectProxy    *proxy,
                            void                            *object,
                            const bdeat_SelectionInfo      **selectionInfoPtr);
        // Configure the specified 'proxy' to represent the current selection
        // of the specified Choice 'object' (assumed to be of the parameterized
        // 'TYPE'), and load, into the specified 'selectionInfoPtr', the
        // address of the 'bdeat_SelectionInfo' for that selection.  The
        // behavior is undefined unless 'object' refers to a 'TYPE' object.
        // Note that this is an implementation of
        // 'baea_SerializableObjectProxyFunctions::SelectionLoader'.

    template<typename TYPE>
    static int choiceChooserFn(void* object, int selectionId);
        // Change the selection of the specified Choice 'object' (assumed to be
        // of the parameterized 'TYPE') to the specified 'selectionId'.  Return
        // 0 on success, and a non-zero value otherwise.  The behavior is
        // undefined unless 'object' refers to a 'TYPE' object.  Note that this
        // function is an implementation of
        // 'baea_SerializableObjectProxyFunctions::Chooser'.

    // Dispatch functions for makeEncodeProxy

    template<typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy       *proxy,
                                bdeut_NullableAllocatedValue<TYPE> *object,
                                bdeat_TypeCategory::NullableValue);
    template<typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                bdeut_NullableValue<TYPE>    *object,
                                bdeat_TypeCategory::NullableValue);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Enumeration);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::CustomizedType);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Choice);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Sequence);
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                bsl::vector<char>            *object,
                                bdeat_TypeCategory::Array);
    template <typename ELEMENT_TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy   *proxy,
                                bsl::vector<ELEMENT_TYPE>      *object,
                                bdeat_TypeCategory::Array);
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Simple);
        // Configure the specified 'proxy' to represent the specified
        // 'object' so that it can be used for encoding based on the type of
        // the unnamed "dispatch" argument.

    template <typename TYPE>
    static void makeEncodeProxyRaw(baea_SerializableObjectProxy *proxy,
                                   void                         *object);
        // Configure the specified 'proxy' to represent the specified 'object'
        // of the parameterized 'TYPE' so that it can be used for encoding.


    // Dispatch functions for makeDecodeProxy

    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Enumeration);
    template<typename TYPE>
    static void makeDecodeProxy(
                              baea_SerializableObjectProxy       *proxy,
                              bdeut_NullableAllocatedValue<TYPE> *object,
                              bdeat_TypeCategory::NullableValue);
    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                bdeut_NullableValue<TYPE>    *object,
                                bdeat_TypeCategory::NullableValue);
    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Choice);
    template<typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Sequence);
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                bsl::vector<char>       *object,
                                bdeat_TypeCategory::Array);
    template<typename ELEMENT_TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                bsl::vector<ELEMENT_TYPE>    *object,
                                bdeat_TypeCategory::Array);
    template<typename TYPE>
    inline
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::CustomizedType);
    template<typename TYPE>
    inline
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object,
                                bdeat_TypeCategory::Simple);
        // Configure the specified 'proxy' to represent the specified 'object'
        // so that it can be used for decoding based on the type of the unnamed
        // "dispatch" argument.

    template <typename TYPE>
    static void makeDecodeProxyRaw(baea_SerializableObjectProxy *proxy,
                                   void                         *object);
        // Configure the specified 'proxy' to represent the specified 'object'
        // so that it can be used for decoding.

    static void makeProxyForEmptySequence(
                                      baea_SerializableObjectProxy *proxy,
                                      const char                   *className);
        // Configure the specified 'proxy' to represent an empty sequence
        // (i.e., one without any elements) having the specified 'className'.

    // FRIENDS
    friend class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy;
    friend class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy;
    friend class baea_SerializableObjectProxyUtil_SequenceAccessorProxy;
    friend class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy;
    template <typename TYPE, bool HAS_ELEMENTS>
    friend class baea_SerializableObjectProxyUtil_SequenceLoader;

  public:
    // CLASS METHODS
    template <typename TYPE>
    static void makeEncodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object);
        // Configure the specified 'proxy' to represent the specified
        // 'bdeat'-compliant 'object' of the parameterized 'TYPE' so that it
        // can be used for encoding.  The behavior is undefined 'object' refers
        // to a 'TYPE' object.

    template <typename TYPE>
    static void makeDecodeProxy(baea_SerializableObjectProxy *proxy,
                                TYPE                         *object);
        // Configure the specified 'proxy' to represent the specified
        // 'bdeat'-compliant 'object' of the parameterized 'TYPE' for decoding.
        // The behavior is undefined unless 'object' refers to a 'TYPE' object.
        // Note that 'reset' may need to be invoked on 'object' prior to
        // decoding into it, because the 'reset' method of 'proxy' has no
        // effect.
};

         // ==========================================================
         // class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy
         // ==========================================================

class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy {
    // [!PRIVATE!] Provide a type to populate a baea_SerializableObjectProxy
    // for encoding the current selection of a Choice object.

    int                           d_selectionId;  // ID of the current
                                                  // selection

    baea_SerializableObjectProxy *d_proxy_p;      // proxy to populate
                                                  // (held, not owned)

    const char                   *d_className;    // name of selection

  public:
    // CREATORS
    baea_SerializableObjectProxyUtil_ChoiceAccessorProxy(
                                     baea_SerializableObjectProxy *proxy,
                                     int                           selectionId,
                                     const char                   *className);
        // Create a 'baea_SerializableObjectProxyUtil_ChoiceAccessorProxy'
        // object that will be used to populate the specified 'proxy' and
        // 'className' with the selection indicated by the specified
        // 'selectionId'.

    // MANIPULATORS
    template <typename TYPE>
    int operator()(const TYPE& object, const bdeat_SelectionInfo& info);
        // Populate the proxy supplied at construction to represent
        // the specified 'object' (having the specified 'info') for encoding.
        // Return 0.
};

      // =============================================================
      // class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
      // =============================================================

class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy {
    // [!PRIVATE!] Provide a type to extract the 'bdeat_SelectionInfo'
    // corresponding to the selection of a Choice object, and to populate a
    // baea_SerializableObjectProxy for decoding into that selection.

    baea_SerializableObjectProxy *d_proxy_p;          // proxy to populate
    const bdeat_SelectionInfo    *d_selectionInfo_p;  // info for current
                                                      // selection

  public:
    // CREATORS
    explicit baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy(
                                          baea_SerializableObjectProxy* proxy);
        // Create a 'baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy'
        // object that will be used to populate the specified 'proxy'.

    // MANIPULATORS
    template <typename TYPE>
    int operator()(const TYPE& object, const bdeat_SelectionInfo& info);
        // Populate the proxy supplied at construction to represent the
        // specified 'object' for decoding, and save the address of 'info' for
        // later use.  Return 0.

    // ACCESSORS
    const bdeat_SelectionInfo *selectionInfoPtr() const;
        // Return the address of the 'bdeat_SelectionInfo' object that was
        // passed to the function-call operator of this object; or 0 if
        // the function-call operator has not been invoked.
};

         // ============================================================
         // class baea_SerializableObjectProxyUtil_SequenceAccessorProxy
         // ============================================================

class baea_SerializableObjectProxyUtil_SequenceAccessorProxy {
    // [!PRIVATE!] Provide a type to populate a 'baea_SerializableObjectProxy'
    // for encoding the elements of a Sequence object.

    baea_SerializableObjectProxy *d_proxy_p;  // proxy to populate (held, not
                                              // owned)

  public:
    explicit baea_SerializableObjectProxyUtil_SequenceAccessorProxy(
                                          baea_SerializableObjectProxy* proxy);
        // Create a 'baea_SerializableObjectProxyUtil_SequenceAccessorProxy'
        // object that will be used to populate the specified 'proxy'.

    template <typename TYPE>
    int operator()(const TYPE& object, const bdeat_AttributeInfo&);
        // Populate the proxy supplied at construction to represent the
        // specified 'object' for encoding.  Return 0.
};

         // ===============================================================
         // class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy
         // ===============================================================

class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy {
    // [!PRIVATE!] Provide a type to populate a baea_SerializableObjectProxy
    // for decoding into the elements of a Sequence object.

    baea_SerializableObjectProxy *d_proxy_p;  // proxy to populate (held, not
                                              // owned)

  public:
    // CREATORS
    explicit baea_SerializableObjectProxyUtil_SequenceManipulatorProxy(
                                          baea_SerializableObjectProxy* proxy);
        // Create a 'baea_SerializableObjectProxyUtil_SequenceManipulatorProxy'
        // object that will be used to populate the specified 'proxy'.

    template <typename TYPE>
    int operator()(const TYPE& object, const bdeat_AttributeInfo&);
        // Populate the proxy supplied at construction to represent the
        // specified 'object' for decoding.  Return 0.
};

         // =====================================================
         // class baea_SerializableObjectProxyUtil_SequenceLoader
         // =====================================================

template<typename TYPE>
class baea_SerializableObjectProxyUtil_SequenceLoader<TYPE, true> {
    // [!PRIVATE!] This class provides utilities to configure a
    // 'baea_SerializableObjectProxy' object to represent a Sequence object.
    // This specialization is for normal sequences (those that have elements).

  public:
    // CLASS METHODS
    static void loadAccessor(baea_SerializableObjectProxy *proxy,
                             void                         *object);
        // Populate the specified 'proxy' with the specified 'object' for
        // encoding.

    static void loadManipulator(baea_SerializableObjectProxy *proxy,
                                void                         *object);
        // Populate the specified 'proxy' with the specified 'object' for
        // decoding.
};

template <typename TYPE>
class baea_SerializableObjectProxyUtil_SequenceLoader<TYPE, false> {
    // This class provides utilities to configure a
    // 'baea_SerializableObjectProxy' object to represent a Sequence object.
    // This specialization is for sequences without any elements.  Such
    // sequences may not have an ATTRIBUTE_INFO_ARRAY class member defined, and
    // thus need special handling.
    //
    // Note that the implementation of loadAccessor() and loadManipulator()
    // are identical in this specialization, but not in the general case.

  public:
    static void loadAccessor(baea_SerializableObjectProxy* proxy, void *);
        // Populate the specified 'proxy' for encoding.

    static void loadManipulator(baea_SerializableObjectProxy* proxy, void *);
        // Populate the specified 'proxy' for decoding.
};

// ============================================================================
//                  INLINE AND TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

template<typename VALUE_TYPE>
inline
int baea_SerializableObjectProxyUtil::enumSetter(void *object, int intValue)
{
    return bslalg_TypeTraits<VALUE_TYPE>::Wrapper::fromInt(
                                        reinterpret_cast<VALUE_TYPE *>(object),
                                        intValue);
}

template<typename VALUE_TYPE>
inline
int baea_SerializableObjectProxyUtil::enumStringSetter(
                                                      void       *object,
                                                      const char *stringValue,
                                                      int         stringLength)
{
    return bslalg_TypeTraits<VALUE_TYPE>::Wrapper::fromString(
                                        reinterpret_cast<VALUE_TYPE *>(object),
                                        stringValue,
                                        stringLength);
}

template <typename NULLABLE>
inline
void baea_SerializableObjectProxyUtil::makeValueFn(void* object)
{
    ((NULLABLE*)object)->makeValue();
}

template<typename NULLABLE>
void* baea_SerializableObjectProxyUtil::fetchValueFn(void* object)
{
    NULLABLE* nullableValue = (NULLABLE*)object;
    if (nullableValue->isNull()) {
        // We also use this function for testing for null.

        return 0;                                                     // RETURN
    }
    return &nullableValue->value();
}

template<typename TYPE>
void
baea_SerializableObjectProxyUtil::sequenceAccessorFn(
                                  baea_SerializableObjectProxy        *proxy,
                                  const baea_SerializableObjectProxy&  object,
                                  int                             attributeId)
{
    baea_SerializableObjectProxyUtil_SequenceAccessorProxy
                                                          accessorProxy(proxy);
    bdeat_SequenceFunctions::accessAttribute(*(const TYPE*)object.object(),
                                             accessorProxy,
                                             attributeId);
}

template<typename TYPE>
void
baea_SerializableObjectProxyUtil::sequenceManipulatorFn(
                                  baea_SerializableObjectProxy        *proxy,
                                  const baea_SerializableObjectProxy&  object,
                                  int                             attributeId)
{
    baea_SerializableObjectProxyUtil_SequenceManipulatorProxy
                                                      manipulatorProxy(proxy);
    bdeat_SequenceFunctions::accessAttribute(*(const TYPE*)object.object(),
                                             manipulatorProxy,
                                             attributeId);
}

template<typename TYPE>
void
baea_SerializableObjectProxyUtil::choiceManipulatorFn(
                                 baea_SerializableObjectProxy    *proxy,
                                 void                       *object,
                                 const bdeat_SelectionInfo **selectionInfoPtr)
{
    baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
                                                       manipulatorProxy(proxy);
    bdeat_ChoiceFunctions::accessSelection(*(const TYPE*)object,
                                           manipulatorProxy);
    *selectionInfoPtr = manipulatorProxy.selectionInfoPtr();
}

template<typename TYPE>
int
baea_SerializableObjectProxyUtil::choiceChooserFn(void *object,
                                                  int   selectionId)
{
    return ((TYPE*)object)->makeSelection(selectionId);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Enumeration)
{
    proxy->loadEnumerationForDecoding(
                      object,
                      &enumSetter<TYPE>,
                      &enumStringSetter<TYPE>,
                      bslalg_TypeTraits<TYPE>::Wrapper::ENUMERATOR_INFO_ARRAY,
                      bslalg_TypeTraits<TYPE>::Wrapper::NUM_ENUMERATORS);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                    baea_SerializableObjectProxy       *proxy,
                                    bdeut_NullableAllocatedValue<TYPE> *object,
                                    bdeat_TypeCategory::NullableValue)
{
    proxy->loadNullableForEncoding(
                              (void*)(object->isNull() ? 0 : &object->value()),
                              &makeEncodeProxyRaw<TYPE>);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          bdeut_NullableValue<TYPE>    *object,
                                          bdeat_TypeCategory::NullableValue)
{
    proxy->loadNullableForEncoding(
                              (void*)(object->isNull() ? 0 : &object->value()),
                              &makeEncodeProxyRaw<TYPE>);
}


template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                    baea_SerializableObjectProxy       *proxy,
                                    bdeut_NullableAllocatedValue<TYPE> *object,
                                    bdeat_TypeCategory::NullableValue)
{
    proxy->loadNullableForDecoding(
                           object,
                           &makeDecodeProxyRaw<TYPE>,
                           &makeValueFn<bdeut_NullableAllocatedValue<TYPE> >,
                           &fetchValueFn<bdeut_NullableAllocatedValue<TYPE> >);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          bdeut_NullableValue<TYPE>    *object,
                                          bdeat_TypeCategory::NullableValue)
{
    proxy->loadNullableForDecoding(object,
                                   &makeDecodeProxyRaw<TYPE>,
                                   &makeValueFn<bdeut_NullableValue<TYPE> >,
                                   &fetchValueFn<bdeut_NullableValue<TYPE> >);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE*                         object,
                                          bdeat_TypeCategory::Choice)
{
    proxy->loadChoiceForDecoding(static_cast<int>(TYPE::NUM_SELECTIONS),
                                 object,
                                 TYPE::SELECTION_INFO_ARRAY,
                                 &choiceManipulatorFn<TYPE>,
                                 &choiceChooserFn<TYPE>);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Sequence)
{
    baea_SerializableObjectProxyUtil_SequenceLoader<TYPE,
                                              (TYPE::NUM_ATTRIBUTES > 0)>::
                                                loadManipulator(proxy, object);
}



template<typename VECTOR>
void baea_SerializableObjectProxyUtil::vectorResizeFn(void         *object,
                                                      void        **newBegin,
                                                      bsl::size_t   newSize)
{
    VECTOR *array = (VECTOR *)object;
    array->resize(newSize);
    *newBegin = newSize ? &(*array->begin()) : 0;
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object)
{
    makeEncodeProxy(proxy,
                    object,
                    typename bdeat_TypeCategory::Select<TYPE>::Type());
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object)
{
    makeDecodeProxy(proxy,
                    object,
                    typename bdeat_TypeCategory::Select<TYPE>::Type());
}

inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          bsl::vector<char>            *object,
                                          bdeat_TypeCategory::Array)
{
    // Our representation for decoding into a vector<char> is the same as
    // encoding into a vector<char> because all we need is the address of the
    // vector.

    makeEncodeProxy(proxy, object, bdeat_TypeCategory::Array());
}

template<typename ELEMENT_TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                        baea_SerializableObjectProxy   *proxy,
                                        bsl::vector<ELEMENT_TYPE>      *object,
                                        bdeat_TypeCategory::Array)
{
    proxy->loadArrayForDecoding(object,
                                static_cast<int>(object->size()),
                                sizeof(ELEMENT_TYPE),
                                object->size() ? &(*object->begin()) : 0,
                                &vectorResizeFn<bsl::vector<ELEMENT_TYPE> >,
                                &makeDecodeProxyRaw<ELEMENT_TYPE>);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::CustomizedType)
{
    typedef typename bdeat_CustomizedTypeFunctions::BaseType<TYPE>::Type
                                                                      BaseType;

    // We rely on the knowledge that codegen's 'toString', 'toInt', etc methods
    // return references to the underlying base-type member variable, so that
    // we can take the address of that reference safely.  This is white-box
    // knowledge that depends on the implementation of codegen! can we do it
    // differently?

    const BaseType& baseRef =
                     bdeat_CustomizedTypeFunctions::convertToBaseType(*object);

    makeDecodeProxy(proxy, const_cast<BaseType *>(&baseRef));
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Simple)
{
    proxy->loadSimple(object);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Enumeration)
{
    int value;
    bdeat_EnumFunctions::toInt(&value, *object);
    proxy->loadEnumerationForEncoding(
                       value,
                       bslalg_TypeTraits<TYPE>::Wrapper::ENUMERATOR_INFO_ARRAY,
                       bslalg_TypeTraits<TYPE>::Wrapper::NUM_ENUMERATORS);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::CustomizedType)
{
    typedef typename
        bdeat_CustomizedTypeFunctions::BaseType<TYPE>::Type BaseType;

    // We rely on the knowledge that codegen's toString(), toInt(), etc
    // methods return references to the underlying base-type member
    // variable, so that we can take the address of that reference safely.
    // This is white-box knowledge that depends on the implementation of
    // codegen!  can we do it differently?

    const BaseType& baseRef =
        bdeat_CustomizedTypeFunctions::convertToBaseType(*object);

    makeEncodeProxy(proxy, const_cast<BaseType *>(&baseRef));
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Choice)
{
    baea_SerializableObjectProxyUtil_ChoiceAccessorProxy accessorProxy(
                                                         proxy,
                                                         object->selectionId(),
                                                         TYPE::CLASS_NAME);

    object->accessSelection(accessorProxy);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Sequence)
{
    baea_SerializableObjectProxyUtil_SequenceLoader<TYPE,
                                                    (TYPE::NUM_ATTRIBUTES > 0)>
                                                 ::loadAccessor(proxy, object);
}

template <typename ELEMENT_TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          bsl::vector<ELEMENT_TYPE>    *object,
                                          bdeat_TypeCategory::Array)
{
    proxy->loadArrayForEncoding(static_cast<int>(object->size()),
                                sizeof(ELEMENT_TYPE),
                                object->size() ? &(*object->begin()) : 0,
                                &makeEncodeProxyRaw<ELEMENT_TYPE>);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxy(
                                          baea_SerializableObjectProxy *proxy,
                                          TYPE                         *object,
                                          bdeat_TypeCategory::Simple)
{
    proxy->loadSimple(object);
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeEncodeProxyRaw(
                                          baea_SerializableObjectProxy *proxy,
                                          void                         *object)
{
    makeEncodeProxy(proxy,
                    reinterpret_cast<TYPE*>(object),
                    typename bdeat_TypeCategory::Select<TYPE>::Type());

    BSLS_ASSERT_SAFE(bdeat_TypeCategory::BDEAT_DYNAMIC_CATEGORY !=
                                                            proxy->category());
}

template <typename TYPE>
inline
void baea_SerializableObjectProxyUtil::makeDecodeProxyRaw(
                                          baea_SerializableObjectProxy *proxy,
                                          void                         *object)
{
    makeDecodeProxy(proxy,
                    (TYPE*)object,
                    typename bdeat_TypeCategory::Select<TYPE>::Type());
    BSLS_ASSERT_SAFE(bdeat_TypeCategory::BDEAT_DYNAMIC_CATEGORY !=
                                                            proxy->category());
}

         // ----------------------------------------------------------
         // class baea_SerializableObjectProxyUtil_ChoiceAccessorProxy
         // ----------------------------------------------------------

// CREATORS
inline
baea_SerializableObjectProxyUtil_ChoiceAccessorProxy
::baea_SerializableObjectProxyUtil_ChoiceAccessorProxy(
                                     baea_SerializableObjectProxy *proxy,
                                     int                           selectionId,
                                     const char                   *className)
: d_selectionId(selectionId)
, d_proxy_p(proxy)
, d_className(className)
{
}

// MANIPULATORS
template <typename TYPE>
inline
int baea_SerializableObjectProxyUtil_ChoiceAccessorProxy::operator()(
                                             const TYPE&                object,
                                             const bdeat_SelectionInfo& info)
{
    d_proxy_p->loadChoiceForEncoding((void *)&object,
                                     &info,
                                     d_className,
                                     &baea_SerializableObjectProxyUtil::
                                                     makeEncodeProxyRaw<TYPE>);
    return 0;
}

      // -------------------------------------------------------------
      // class baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
      // -------------------------------------------------------------

// CREATORS
inline
baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
::baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy(
                                           baea_SerializableObjectProxy* proxy)
: d_proxy_p(proxy)
, d_selectionInfo_p(0)
{
}

// MANIPULATORS
template <typename TYPE>
inline
int baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy::operator()(
                                             const TYPE&                object,
                                             const bdeat_SelectionInfo& info)
{
    baea_SerializableObjectProxyUtil::makeDecodeProxy(
                                                   d_proxy_p,
                                                   const_cast<TYPE*>(&object));
    d_selectionInfo_p = &info;
    return 0;
}

// ACCESSORS
inline
const bdeat_SelectionInfo*
baea_SerializableObjectProxyUtil_ChoiceManipulatorProxy
                                                     ::selectionInfoPtr() const
{
    return d_selectionInfo_p;
}

         // ------------------------------------------------------------
         // class baea_SerializableObjectProxyUtil_SequenceAccessorProxy
         // ------------------------------------------------------------

// CREATORS
inline
baea_SerializableObjectProxyUtil_SequenceAccessorProxy
::baea_SerializableObjectProxyUtil_SequenceAccessorProxy(
                                           baea_SerializableObjectProxy* proxy)
: d_proxy_p(proxy)
{
}

// MANIPULATORS
template <typename TYPE>
inline
int baea_SerializableObjectProxyUtil_SequenceAccessorProxy::operator()(
                                                    const TYPE& object,
                                                    const bdeat_AttributeInfo&)
{
    baea_SerializableObjectProxyUtil::makeEncodeProxyRaw<TYPE>(d_proxy_p,
                                                               (void*)&object);
    return 0;
}

         // ---------------------------------------------------------------
         // class baea_SerializableObjectProxyUtil_SequenceManipulatorProxy
         // ---------------------------------------------------------------

// CREATORS
inline
baea_SerializableObjectProxyUtil_SequenceManipulatorProxy
::baea_SerializableObjectProxyUtil_SequenceManipulatorProxy (
                                           baea_SerializableObjectProxy *proxy)
: d_proxy_p(proxy)
{
}

// MANIPULATORS
template <typename TYPE>
inline
int baea_SerializableObjectProxyUtil_SequenceManipulatorProxy::operator() (
                                                    const TYPE& object,
                                                    const bdeat_AttributeInfo&)
{
    baea_SerializableObjectProxyUtil::makeDecodeProxyRaw<TYPE>(d_proxy_p,
                                                               (void*)&object);
    return 0;
}

         // -----------------------------------------------------
         // class baea_SerializableObjectProxyUtil_SequenceLoader
         // -----------------------------------------------------

// CLASS METHODS
template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil_SequenceLoader<TYPE, true>::loadAccessor(
                                          baea_SerializableObjectProxy *proxy,
                                          void                         *object)
{
    proxy->loadSequence(
                  static_cast<int>(TYPE::NUM_ATTRIBUTES),
                  object,
                  TYPE::ATTRIBUTE_INFO_ARRAY,
                  TYPE::CLASS_NAME,
                  &baea_SerializableObjectProxyUtil::sequenceAccessorFn<TYPE>);
}

// MANIPULATORS
template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil_SequenceLoader<TYPE, true>
           ::loadManipulator(baea_SerializableObjectProxy *proxy, void *object)
{
    proxy->loadSequence(
               static_cast<int>(TYPE::NUM_ATTRIBUTES),
               object,
               TYPE::ATTRIBUTE_INFO_ARRAY,
               TYPE::CLASS_NAME,
               &baea_SerializableObjectProxyUtil::sequenceManipulatorFn<TYPE>);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil_SequenceLoader<TYPE, false>
                    ::loadAccessor(baea_SerializableObjectProxy* proxy, void *)
{
    baea_SerializableObjectProxyUtil::makeProxyForEmptySequence(
                                                             proxy,
                                                             TYPE::CLASS_NAME);
}

template<typename TYPE>
inline
void baea_SerializableObjectProxyUtil_SequenceLoader<TYPE, false>
                 ::loadManipulator(baea_SerializableObjectProxy* proxy, void *)
{
    baea_SerializableObjectProxyUtil::makeProxyForEmptySequence(
                                                             proxy,
                                                             TYPE::CLASS_NAME);
}

}  // close namespace BloombergLP


#endif


// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2011
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ------------------------------ END-OF-FILE ---------------------------------
