// baea_serializableobjectproxy.h                                     -*-C++-*-
#ifndef INCLUDED_BAEA_SERIALIZABLEOBJECTPROXY
#define INCLUDED_BAEA_SERIALIZABLEOBJECTPROXY

#include <bdes_ident.h>
BDES_IDENT_RCSID(baea_serializableobjectproxy_h,"$Id$ $CSID$")
BDES_IDENT_PRAGMA_ONCE

//@PURPOSE: Provide a dynamically-typed facade for serializable types.
//
//@AUTHOR: David Schumann (dschumann1)
//
//@CLASSES:
//           baea::SerializableObjectProxy: facade for autogenerated types
//  baea::SerializableObjectProxyFunctions: namespace for function type aliases
//
//@SEE_ALSO: baea_serializableobjectproxyutil, bdeat_typecategory
//
//@DESCRIPTION: This component provides a mechanism, 'SerializableObjectProxy',
// that serves as a proxy for encoding/decoding autogenerated,
// 'bdeat'-compliant objects.  It exposes all the accessors and manipulators
// required by 'bdeat'-based encoders/decoders (such as 'bdem_berencoder',
// 'bdem_berdecoder', and similar encoders/decoders for XML), while referring
// to the data of the underlying object.  It provides set of "load" methods for
// configuring a proxy object to represent the intended 'bdeat'-compliant
// object.  However, clients should use a higher level component (e.g.,
// 'baea_serializableobjectproxyutil') to configure the proxy object
// automatically.
//
// This component serves to reduce the size of executable code associated with
// encoding/decoding autogenerated objects because the encoder/decoder
// implementations are template-expanded in terms of
// 'SerializableObjectProxy' only, and not in terms of all the
// autogenerated types (of which there may be many).  Rather than encoding
// or decoding an object of autogenerated type directly, a client will
// create and populate a 'SerializableObjectProxy' to represent that
// object, and then encode/decode the proxy.
//
// The type categories of the 'bdeat' package are used throughout this
// component.  The terms "Array", "Choice", "Customized", "Enumeration",
// "Nullable", "Sequence", and "Simple" all refer to the corresponding
// 'bdeat' categories.
//
///Treatment of "Customized" Types
///-------------------------------
// The 'bdeat' package has the concept of a Customized type.  Types in this
// category contain a restricted value of some other type.  A common example is
// a string of restricted length.  'SerializableObjectProxy' cannot directly
// represent a Customized type, but it can be use to represent its underlying
// base type.
//
// Customized types are required to have conversion methods for their
// underlying type -- for example, a Customized type based on 'bsl::string' is
// required to have a 'toString' method.  If this conversion method is use to
// retrieve the underlying type, then it must return a 'const' references to a
// member variable instead of returning by value, so that it is safe to take
// the address of the return value and store it for later use.  This is not
// required by the 'bdeat' package.  A Customized type based on 'bsl::string'
// is allowed to return a 'bsl::string' by value from 'toString', but such
// types cannot be used with this component, or undefined behavior will result.
// 'bas_codegen.pl' emits Customized types that return const references from
// their conversion methods and are thus compatible with this component.
//
///Restrictions On Proxied Types
///-----------------------------
// SerializableObjectProxy imposes restrictions on the implementation
// of the proxied type that are stricter than those imposed by the 'bdeat'
// framework in order to simplify the resulting object code.
//
//: o All Array type objects must be instantiations of bsl::vector.
//:
//: o All Nullable type objects must be instantiations of either
//:   'bdeut_NullableValue' or 'bdeut_NullableAllocatedValue'.
//:
//: o All Choice types must have a 'NUM_SELECTIONS' enumerated value, and class
//:   members named 'SELECTION_INFO_ARRAY' and 'CLASS_NAME'.
//:
//: o All Sequence types must have a 'NUM_ATTRIBUTES' enumerated value, and
//:   class members named 'ATTRIBUTE_INFO_ARRAY' and 'CLASS_NAME'.
//:
//: o As mentioned above, the accessors (e.g., 'toString') of Customized types
//:   are required to return const references to member variables -- the
//:   addresses of these return values will be taken, so they must not be
//:   temporaries.
//
// Violation of these restrictions except for the last one listed will lead to
// a compile-time error.  Violation of the last restriction listed
// (regarding the accessors of Customized types) will lead to undefined
// behavior at runtime.  Note that types auto-generated by 'bas_codegen.pl'
// will meet all of these restrictions.
//
///Using 'SerializableObjectProxy'
///-------------------------------
// Use of 'SerializableObjectProxy' is intended to reduce the amount of
// compiled object code required to encode/decode objects.  As a result,
// certain optimizations have been made which require careful attention by the
// users of the type.
//
//: o When decoding, 'SerializableObjectProxy' does not 'reset' the state of
//:   the target variable, whereas the BER and XML encoders automatically do.
//:   As a result, users of 'SerializableObjectProxy' should manually reset the
//:   target variable before decoding.
//:
//: o When decoding, 'SerializableObjectProxy' does not apply any of the
//:   restrictions on Customized types (e.g., length-limited strings).
//:
//: o A particular 'SerializableObjectProxy' object supports either encoding or
//:   decoding, but not both.
//:
//: o 'SerializableObjectProxy' does not support BDEX.  It provides standard
//:   BDEX accessor functions for integration purposes, but these methods will
//:   fail (indicating encoding/decoding failure) at runtime if used.
//:
//: o The encoder or decoder should be invoked on a proxy representing a Choice
//:   or Sequence.  There may be compile-time or run-time issues if attempting
//:   to encode/decode a top-level object of one of the other 'bdeat' types
//:   (Array, Nullable, etc).  In other words, the other 'bdeat' types are
//:   required to be contained, recursively, within a top-level object that is
//:   a Choice or Sequence.
//
///Description of the Proxy Representation
///---------------------------------------
// Some "load" methods of a 'SerializableObjectProxy' object requires, the
// caller to specify a function pointer for populate another
// 'SerializableObjectProxy' object (e.g., "loadChoice").  In the example of
// populating a proxy for a Choice, the supplied function will populate a new
// proxy object to represent the selection of the represented Choice.
//
// When a "visitor" compliant with the 'bdeat' framework is invoked on a
// 'SerializableObjectProxy', the proxy creates *another*
// 'SerializableObjectProxy' on the stack, invokes the function pointer
// supplied to its "load" method to populate that new object, and
// then recursively visits that object.  Recursion takes place in two ways:
// at compile time, instantiating template methods of the higher-level utility
// (e.g., SerializableObjectProxyUtil) recursively instantiates function
// templates for all the types that the encoder/decoder may encounter; and at
// runtime, applying an accessor or manipulator to a SerializableObjectProxy
// results in the recursive invocation of that accessor on temporary
// 'SerializableObjectProxy' objects created on the stack.
// Note that 'SerializableObjectProxy' objects are PODs so these temporary
// objects are relatively inexpensive to create and destroy.
//
// The 'serializableobjectproxyutil' component provides implementation of
// functions for the 'load' methods.
//
///Usage Example
///-------------
// This section illustrates intended use of this component.
//
///Example 1: Creating a Proxy Object for a Simple Request
///- - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to decode some XML data.  The data conforms to this schema:
//..
//  <?xml version='1.0' encoding='UTF-8'?>
//  <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
//             xmlns:test='http://bloomberg.com/schemas/test'
//             targetNamespace='http://bloomberg.com/schemas/test'
//             elementFormDefault='unqualified'>
//
//      <xs:complexType name='Simple'>
//          <xs:sequence>
//              <xs:element name='status' type='xs:int'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:element name='Simple' type='test:Simple'/>
//  </xs:schema>
//..
// This schema specify a Sequence type name 'Simple' with one element of type
// 'int' named 'status'.  Using the 'bas_codegen.pl' tool, we can generate a
// C++ class for this schema:
//..
//  $ bas_codegen.pl -m msg -p test -E simple.xsd
//..
// This tool will generate the header and implementation files for the
// 'test_simple' component, which contains a 'Test::Simple' class.
//
// Since 'Test::Simple' is a Sequence type, we first need to create a function
// that populate a proxy object for its element.  Note that in this case,
// 'Test::Simple' have only one element, 'status'.  Also note that, for
// simplification, this function will only work with 'Test::Simple' type, and
// not other Sequence type:
//..
//  void elementLoader(SerializableObjectProxy       *proxy,
//                     const SerializableObjectProxy &object,
//                     int                            index)
//  {
//      test::Simple *simpleObject = (test::Simple *)object.object();
//      proxy->loadSimple(&simpleObject->status());
//  }
//..
// Then, we define the XML string that we would like to decode.  This XML
// string defines a 'Simple' object to have a 'status' of 42:
//..
//  const char data[] =
//      "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>"
//      "<Simple xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">"
//      "    <status>42</status>"
//      "</Simple>";
//..
// Next, we create a 'test::Simple' object, 'result', to decode the XML string
// into:
//..
//  test::Simple result;
//..
// Then, instead of decoding the XML string directly, we can create a proxy
// object for 'result'.  Since 'test::Simple' is a Sequence object, we use the
// 'loadSequence' method to configure the proxy object.  Note that this is done
// for demonstration purpose.  Users should use methods in the
// 'baea_serializableobjectproxyutil' component to create the proxy object
// instead:
//..
//  baea::SerializableObjectProxy decodeProxy;
//  decodeProxy.loadSequence(test::Simple::NUM_ATTRIBUTES,
//                           &result,
//                           test::Simple::ATTRIBUTE_INFO_ARRAY,
//                           test::Simple::CLASS_NAME,
//                           &elementLoader);
//..
// Now, we create a decoder and decode the XML string into 'result' through the
// 'decodeProxy':
//..
//  baexml_DecoderOptions dOptions;
//  baexml_MiniReader reader;
//  baexml_Decoder decoder(&dOptions, &reader);
//
//  bdesb_FixedMemInStreamBuf isb(data, sizeof(data) - 1);
//  decoder.decode(&isb, &decodeProxy);
//..
// Finally, we assert that 'result' has the expected value.
//..
//  assert(42 == result.status());
//..

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BDEAT_ATTRIBUTEINFO
#include <bdeat_attributeinfo.h>
#endif

#ifndef INCLUDED_BDEAT_ARRAYFUNCTIONS
#include <bdeat_arrayfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CHOICEFUNCTIONS
#include <bdeat_choicefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_ENUMERATORINFO
#include <bdeat_enumeratorinfo.h>
#endif

#ifndef INCLUDED_BDEAT_ENUMFUNCTIONS
#include <bdeat_enumfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_NULLABLEVALUEFUNCTIONS
#include <bdeat_nullablevaluefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_SELECTIONINFO
#include <bdeat_selectioninfo.h>
#endif

#ifndef INCLUDED_BDEAT_SEQUENCEFUNCTIONS
#include <bdeat_sequencefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_TYPECATEGORY
#include <bdeat_typecategory.h>
#endif

#ifndef INCLUDED_BDEAT_TYPETRAITS
#include <bdeat_typetraits.h>
#endif

#ifndef INCLUDED_BDEF_FUNCTION
#include <bdef_function.h>
#endif

#ifndef INCLUDED_BDET_DATETIMETZ
#include <bdet_datetimetz.h>
#endif

#ifndef INCLUDED_BDEUT_NULLABLEALLOCATEDVALUE
#include <bdeut_nullableallocatedvalue.h>
#endif

#ifndef INCLUDED_BDEUT_NULLABLEVALUE
#include <bdeut_nullablevalue.h>
#endif

#ifndef INCLUDED_BDEUT_VARIANT
#include <bdeut_variant.h>
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include <bslalg_typetraits.h>
#endif

#ifndef INCLUDED_BSLMF_METAINT
#include <bslmf_metaint.h>
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include <bsls_objectbuffer.h>
#endif

#ifndef INCLUDED_BSL_STRING
#include <bsl_string.h>
#endif

#ifndef INCLUDED_BSL_VECTOR
#include <bsl_vector.h>
#endif

namespace BloombergLP {

namespace baea {

class SerializableObjectProxy;

                   // ======================================
                   // class SerializableObjectProxyFunctions
                   // ======================================

struct SerializableObjectProxyFunctions {
    // This 'struct' provides a namespace for type aliases for common function
    // pointer types used in the interface of this component.

    typedef void (*Loader)(SerializableObjectProxy *proxy, void *object);
        // Alias for a function that populate the specified 'proxy' with the
        // specified 'object.

    typedef void (*SelectionLoader)(SerializableObjectProxy    *proxy,
                                    void                       *object,
                                    const bdeat_SelectionInfo **selectInfoPtr);
        // Alias for a function that populate the specified 'proxy' with the
        // specified 'object and load the current selection to the specified
        // 'selectInfoPtr'.

    typedef void (*ElementLoader)(SerializableObjectProxy        *proxy,
                                  const SerializableObjectProxy&  object,
                                  int                             index);
        // Alias for a function that populate the specified 'proxy' with the
        // element at the specified 'index' of the specified 'object'.

    typedef int (*Chooser)(void *object, int selectionId);
        // Alias for a function that changes the selection of the specified
        // Choice 'object with the specified 'selectionId'.

    typedef void (*Resizer)(void         *object,
                            void        **newBeginAddress,
                            bsl::size_t   newSize);
        // Alias for a function that load, into the specified
        // 'newBeginAddress', the address of the first element after resizing a
        // 'bsl::vector' referred to by the specified 'object' to the specified
        // 'newSize'.

    typedef void * (*ObjectFetcher)(void *object);
        // Alias for a function that returns the address of the specified
        // Nullable 'object'.

    typedef int (*IntSetter)(void *object, int value);
        // Alias for a function that populate the specified Enumerated 'object'
        // with the specified 'value'.

    typedef int (*StringSetter)(void *object, const char *value, int length);
        // Alias for a function that populate the specified Enumerated 'object'
        // using the specified string, 'value', with the specified 'length'.

    typedef void (*ValueMaker)(void *object);
        // Alias for a function that creates a value for the specified Nullable
        // 'object', making it non-null.
};

                // ==============================================
                // class SerializableObjectProxy_ChoiceEncodeInfo
                // ==============================================

struct SerializableObjectProxy_ChoiceEncodeInfo {
    // [!PRIVATE!] This 'struct' holds the data necessary to represent a
    // Choice-type object for encoding.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions;  // for brevity

    // PUBLIC DATA
    const bdeat_SelectionInfo *d_selectionInfo_p; // info for current selection
    Functions::Loader          d_loader;          // create proxy for selection
    const char*                d_className_p;     // class name, may be 0

    // CREATORS
    SerializableObjectProxy_ChoiceEncodeInfo (
                                      const bdeat_SelectionInfo *selectionInfo,
                                      Functions::Loader          accessor,
                                      const char                *className)
    : d_selectionInfo_p(selectionInfo)
    , d_loader(accessor)
    , d_className_p(className)
        // Create a 'SerializableObjectProxy_ChoiceEncodeInfo' object having
        // the specified 'selectionInfo', 'accessor' and 'className' attribute
        // values.
    {
    }
};

              // ==============================================
              // class SerializableObjectProxy_ChoiceDecodeInfo
              // ==============================================

struct SerializableObjectProxy_ChoiceDecodeInfo {
    // [!PRIVATE!] This 'struct' holds the data necessary to represent a
    // Choice-type object for decoding.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions; // for brevity

    // PUBLIC DATA
    int                         d_numSelections;  // total number of selections
    const bdeat_SelectionInfo  *d_selectionInfoArray_p;
                                                  // array of selection info
                                                  // (held, not owned)
    int                         d_currentSelection;
                                                  // populated by chooser
    Functions::SelectionLoader  d_loader;         // creates proxy and gets
                                                  // info for current selection
    Functions::Chooser          d_chooser;        // change the current
                                                  // selection

    // CREATORS
    SerializableObjectProxy_ChoiceDecodeInfo(
                                int                         numSelections,
                                const bdeat_SelectionInfo  *selectionInfoArray,
                                Functions::SelectionLoader  loader,
                                Functions::Chooser          chooser)
    : d_numSelections(numSelections)
    , d_selectionInfoArray_p(selectionInfoArray)
    , d_currentSelection(bdeat_ChoiceFunctions::BDEAT_UNDEFINED_SELECTION_ID)
    , d_loader(loader)
    , d_chooser(chooser)
        // Create a 'SerializableObjectProxy_ChoiceDecodeInfo' object having
        // the specified 'numSelections', 'selectionInfoArray', 'loader' and
        // 'chooser' attribute values.
    {
    }
};

              // =============================================
              // class SerializableObjectProxy_ArrayEncodeInfo
              // =============================================

struct SerializableObjectProxy_ArrayEncodeInfo {
    // [!PRIVATE!] This 'struct' holds the data necessary to represent an
    // Array-type object for encoding.  As described in the component- level
    // documentation, only instantiations of 'bsl::vector' are supported.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions;  // for brevity

    // PUBLIC DATA
    int               d_length;       // number of elements in vector
    int               d_elementSize;  // element size, in bytes
    Functions::Loader d_loader;       // creates a proxy for an object of the
                                      // contained type

    // CREATORS
    SerializableObjectProxy_ArrayEncodeInfo(int               length,
                                            int               elementSize,
                                            Functions::Loader loader)
    : d_length(length)
    , d_elementSize(elementSize)
    , d_loader(loader)
        // Create a 'SerializableObjectProxy_ArrayEncodeInfo' object having
        // the specified 'length', 'elementSize' and 'loader' attribute
        // values.
    {
    }
};

              // =============================================
              // class SerializableObjectProxy_ArrayDecodeInfo
              // =============================================

struct SerializableObjectProxy_ArrayDecodeInfo {
    // [!PRIVATE!] This 'struct' holds the data necessary to represent an
    // Array-type object for decoding.  As described in the component-level
    // documentation, only instantiations of 'bsl::vector' are supported.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions;  // for brevity

    // PUBLIC DATA
    int                 d_length;       // number of elements in vector
    int                 d_elementSize;  // element size, in bytes
    void               *d_begin;        // address of first element, 0 if empty
    Functions::Resizer  d_resizer;      // changes size
    Functions::Loader   d_loader;       // creates a proxy for an object of the
                                        // contained type

    // CREATORS
    SerializableObjectProxy_ArrayDecodeInfo(int                 length,
                                            int                 elementSize,
                                            void               *begin,
                                            Functions::Resizer  resizer,
                                            Functions::Loader   loader)
    : d_length(length)
    , d_elementSize(elementSize)
    , d_begin(begin)
    , d_resizer(resizer)
    , d_loader(loader)
        // Create a 'SerializableObjectProxy_ArrayDecodeInfo' object having
        // the specified 'length', 'elementSize', 'begin', 'resizer' and
        // 'loader' attribute values.
    {
    }
};

              // ============================================
              // class SerializableObjectProxy_EnumDecodeInfo
              // ============================================

struct SerializableObjectProxy_EnumDecodeInfo {
    // [!PRIVATE!] This 'struct' holds the data necessary to represent an
    // Enumeration-type object for decoding.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions;  // for brevity

    // PUBLIC DATA
    Functions::IntSetter        d_intSetter;      // sets the value based on
                                                  // int
    Functions::StringSetter     d_stringSetter;   // sets the value based on
                                                  // a string
    const bdeat_EnumeratorInfo *d_infoArray_p;    // array of enumerator info
                                                  // (held, not owned)
    int                         d_infoArraySize;  // size of the array
};

              // ============================================
              // class SerializableObjectProxy_EnumEncodeInfo
              // ============================================

struct SerializableObjectProxy_EnumEncodeInfo {
    // [!PRIVATE!] This 'struct' holds the data necessary to represent an
    // Enumeration-type object for encoding.

    // PUBLIC DATA
    int                         d_intVal;         // the current value as int
    const bdeat_EnumeratorInfo *d_infoArray_p;    // array of enumerator info
                                                  // (held, not owned)
    int                         d_infoArraySize;  // size of the array
};

              // ==========================================
              // class SerializableObjectProxy_SequenceInfo
              // ==========================================

struct SerializableObjectProxy_SequenceInfo {
    // [!PRIVATE!] This 'struct' holds the data necessary to represent a
    // Sequence-type object for either encoding or decoding

    // TYPES
    typedef SerializableObjectProxyFunctions Functions;  // for brevity

    // PUBLIC DATA
    int                        d_numAttributes;    // number of attributes
    const bdeat_AttributeInfo *d_attributeInfo_p;  // array of attribute info
                                                   // (held, not owned)
    Functions::ElementLoader   d_loader;           // creates a proxy for the
                                                   // element at an index
    const char                *d_className_p;      // class name, may be 0

    // CREATORS
    SerializableObjectProxy_SequenceInfo(
                                      int                        numAttributes,
                                      const bdeat_AttributeInfo *attributeInfo,
                                      const char                *className,
                                      Functions::ElementLoader   loader)
    : d_numAttributes(numAttributes)
    , d_attributeInfo_p(attributeInfo)
    , d_loader(loader)
    , d_className_p(className)
        // Create a 'SerializableObjectProxy_SequenceInfo' object having
        // the specified 'numAttributes', 'attributeInfo', 'className' and
        // 'loader' attribute values.
    {
    }
};

              // ===========================================
              // class SerializableObjectProxy_SimplePointer
              // ===========================================

struct SerializableObjectProxy_SimplePointer {
    // [!PRIVATE!] This 'struct' is used for representing a simple type.  The
    // underlying type is represented by this 'struct', rather than by a
    // 'bdeut_Variant', to avoid extremely long mangled names that can result
    // from placing a large Variant inside another large Variant.

    // CONSTANTS
    enum Type {
        TYPE_CHAR,
        TYPE_UCHAR,
        TYPE_SHORT,
        TYPE_INT,
        TYPE_INT64,
        TYPE_USHORT,
        TYPE_UINT,
        TYPE_UINT64,
        TYPE_FLOAT,
        TYPE_DOUBLE,
        TYPE_STRING,
        TYPE_DATETIME,
        TYPE_DATE,
        TYPE_TIME,
        TYPE_BOOL,
        TYPE_DATETIMETZ,
        TYPE_DATETZ,
        TYPE_TIMETZ
    };

    Type d_type;  // type of the represented value
};

              // ============================================
              // class SerializableObjectProxy_NullableDecode
              // ============================================

struct SerializableObjectProxy_NullableDecodeInfo {
    // [!PRIVATE!] This 'struct' is used when the proxy represents a
    // Nullable-type object for decoding.  As described in the component-level
    // documentation, only instantiations of bdeut_NullableValue or
    // bdeut_NullableAllocatedValue are supported.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions;  // for brevity

    // PUBLIC DATA
    Functions::ValueMaker    d_valueMaker; // makes the value non-null
    Functions::ObjectFetcher d_fetcher;    // return address of underlying data
    Functions::Loader        d_loader;     // makes proxy for underlying data
};

typedef SerializableObjectProxyFunctions::Loader
                                   SerializableObjectProxy_NullableEncodeInfo;
    // This 'typedef' represents a Nullable object for encoding.  The only data
    // necessary is the function for creating a proxy for the underlying object

              // =============================================
              // class SerializableObjectProxy_NullableAdapter
              // =============================================

struct SerializableObjectProxy_NullableAdapter {
    // [!PRIVATE!] Provide a type that holds a pointer to a
    // 'SerializableObjectProxy' but only exposes the Nullable trait, and not
    // any other traits.  This is required for integration with at least the
    // BER decoder, which cannot handle a nullable element of dynamic type
    // contained within a dynamic type.  So this adapter allows for a nullable
    // 'SerializableObjectProxy' of non-dynamic type.
    //
    // As described in the component-level documentation, the encoders/decoders
    // will not be invoked directly on Nullable proxies, but instead on a
    // Choice or Sequence; thus any Nullable object will be held within another
    // object.  So the accessor/manipulator methods of Choice, Array, and
    // Sequence will, before invoking the accessor/manipulator on a proxy for a
    // contained element, test whether that element is a Nullable, and if so,
    // construct an object of this type (NullableAdapter) and then invoke the
    // accessor/manipulator on it.

    SerializableObjectProxy *d_proxy_p;  // pointer to the proxy it represents
                                         // (held, not owned)
};

                     // =============================
                     // class SerializableObjectProxy
                     // =============================

class SerializableObjectProxy {
    // This class provides a proxy mechanism for encoding and decoding.
    // 'SerializableObjectProxy' exposes the minimal interface required by
    // 'bdeat'-based codecs (see 'bdem_berencoder', 'baexml_encoder', etc) and
    // insulates the encoder/decoder from type information about the proxied
    // types, primarily types autogenerated by 'bas_codegen.pl' or types that
    // expose the same introspection API.  Note that clients are
    // encouraged to use utilities provided in the
    // 'baea_serializableobjectproxyutil' component to populate a
    // 'SerializableObjectProxy' object instead of doing that manually.

    // PRIVATE TYPES
    typedef SerializableObjectProxy_ChoiceEncodeInfo   ChoiceEncodeInfo;
    typedef SerializableObjectProxy_ChoiceDecodeInfo   ChoiceDecodeInfo;
    typedef SerializableObjectProxy_SequenceInfo       SequenceInfo;
    typedef SerializableObjectProxy_ArrayEncodeInfo    ArrayEncodeInfo;
    typedef SerializableObjectProxy_ArrayDecodeInfo    ArrayDecodeInfo;
    typedef SerializableObjectProxy_EnumEncodeInfo     EnumEncodeInfo;
    typedef SerializableObjectProxy_EnumDecodeInfo     EnumDecodeInfo;
    typedef SerializableObjectProxy_NullableEncodeInfo NullableEncodeInfo;
    typedef SerializableObjectProxy_NullableDecodeInfo NullableDecodeInfo;
    typedef SerializableObjectProxy_SimplePointer      SimplePointer;

    typedef bdeut_Variant<ChoiceEncodeInfo,
                          ChoiceDecodeInfo,
                          SequenceInfo,
                          ArrayEncodeInfo,
                          ArrayDecodeInfo,
                          EnumEncodeInfo,
                          EnumDecodeInfo,
                          NullableEncodeInfo,
                          NullableDecodeInfo,
                          SimplePointer> ObjectInfo;

    // DATA
    bsls_ObjectBuffer<ObjectInfo> d_objectInfoArena;
                                           // This is held as an ObjectBuffer
                                           // to avoid the expense of
                                           // default-constructing and
                                           // (especially) destroying the
                                           // object.

    ObjectInfo&                d_objectInfo;
                                            // Refers to the object held in the
                                            // arena.

    void                      *d_object_p;  // Meaning depends on the type
                                            // being represented: (1) If
                                            // representing a Nullable object
                                            // for encoding, return 0 if the
                                            // value if the value is null,
                                            // return the address of the
                                            // contained element otherwise.
                                            // (2) If representing a Choice for
                                            // encoding, return the address of
                                            // the selected element.  (3) If
                                            // representing an Enumeration for
                                            // encoding, return 0.  (4) If
                                            // representing an Array for
                                            // encoding, return 0 if the array
                                            // is empty, and the address of the
                                            // first element otherwise.  (5) In
                                            // all other cases, return the
                                            // address of the proxied value.

    bdeat_TypeCategory::Value  d_category;  // dynamic type of proxied value

  private:
    // NOT IMPLEMENTED
    SerializableObjectProxy(const SerializableObjectProxy&);
    SerializableObjectProxy& operator=(const SerializableObjectProxy&);

    // PRIVATE CLASS METHODS
    template<typename ACCESSOR>
    static int accessContainedElement(const SerializableObjectProxy& proxy,
                                      ACCESSOR&                      accessor);
        // Invoke the specified 'accessor' on the object represented by the
        // specified 'proxy', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and return the result of the invocation.
        // 'ACCESSOR' shall be a functor providing methods that can be called
        // as if it had the following signatures:
        //..
        //  int operator()(const SerializableObjectProxy&);
        //  int operator()(const SerializableObjectProxy_NullableAdapter&);
        //..

    template<typename ACCESSOR>
    static int accessContainedElement(const SerializableObjectProxy& proxy,
                                      ACCESSOR&                      accessor,
                                      const bdeat_SelectionInfo&     info);
        // Invoke the specified 'accessor' on the object, represented by the
        // specified 'proxy', and the specified 'info', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and return the result of
        // the invocation.  'ACCESSOR' shall be a functor providing methods
        // that can be called as if it had the following signatures:
        //..
        //  int operator()(const SerializableObjectProxy&,
        //                 const bdeat_SelectionInfo&);
        //
        //  int operator()(const SerializableObjectProxy_NullableAdapter&,
        //                 const bdeat_SelectionInfo&);
        //..

    template<typename ACCESSOR>
    static int accessContainedElement(const SerializableObjectProxy& proxy,
                                      ACCESSOR&                      accessor,
                                      const bdeat_AttributeInfo&     info);
        // Invoke the specified 'accessor' on the object, represented by the
        // specified 'proxy', and the specified 'info', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and return the result of the invocation.
        // 'ACCESSOR' shall be a functor providing methods that can be called
        // as if it had the following signature:
        //..
        //  int operator()(const SerializableObjectProxy&,
        //                 const bdeat_AttributeInfo&);
        //
        //  int operator()(const SerializableObjectProxy_NullableAdapter&,
        //                 const bdeat_AttributeInfo&);
        //..

    template<typename MANIPULATOR>
    static int manipulateContainedElement(
                                         SerializableObjectProxy *proxy,
                                         MANIPULATOR&             manipulator);
    static int manipulateContainedElement(
                SerializableObjectProxy                          *proxy,
                bdef_Function<int(*)(SerializableObjectProxy*)>&  manipulator);
        // Invoke the specified 'manipulator' on the object represented by the
        // specified 'proxy', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and return the result of the invocation.
        // 'MANIPULATOR' shall be a functor providing methods that can be
        // called as if it had the following signature:
        //..
        //  int operator()(SerializableObjectProxy *);
        //  int operator()(SerializableObjectProxy_NullableAdapter *);
        //..
        // IMPLEMENTATION NOTE: see the .cpp file for a discussion of why this
        // method is overloaded.

    template<typename MANIPULATOR>
    static int manipulateContainedElement(
                                       SerializableObjectProxy    *proxy,
                                       MANIPULATOR&                manipulator,
                                       const bdeat_SelectionInfo&  info);
    static int manipulateContainedElement(
              SerializableObjectProxy                            *proxy,
              bdef_Function<int(*)(SerializableObjectProxy*,
                                   const bdeat_SelectionInfo&)>&  manipulator,
              const bdeat_SelectionInfo&                          info);
        // Invoke the specified 'manipulator' on the object, represented by the
        // specified 'proxy', and the specified 'info', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and return the result of the invocation.
        // 'MANIPULATOR' shall be a functor providing methods that can be
        // called as if it had the following signature:
        //..
        //  int operator()(SerializableObjectProxy *,
        //                 const bdeat_SelectionInfo&)
        //
        //  int operator()(SerializableObjectProxy_NullableAdapter *,
        //                 const bdeat_SelectionInfo&)
        //..
        // IMPLEMENTATION NOTE: see the .cpp file for a discussion of why this
        // method is overloaded.

    template<typename MANIPULATOR>
    static int manipulateContainedElement(
                                       SerializableObjectProxy    *proxy,
                                       MANIPULATOR&                manipulator,
                                       const bdeat_AttributeInfo&  info);
    static int manipulateContainedElement(
              SerializableObjectProxy                            *proxy,
              bdef_Function<int(*)(SerializableObjectProxy*,
                                   const bdeat_AttributeInfo&)>&  manipulator,
              const bdeat_AttributeInfo&                          info);
        // Invoke the specified 'manipulator' on the object, represented by the
        // specified 'proxy', and the specified 'info', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and return the result of the invocation.
        // 'MANIPULATOR' shall be a functor providing a method that can be
        // called as if it had the following signature:
        //..
        //  int operator()(SerializableObjectProxy *,
        //                 const bdeat_AttributeInfo&);
        //
        //  int operator()(SerializableObjectProxy_NullableAdapter *,
        //                 const bdeat_AttributeInfo&)
        //..
        // IMPLEMENTATION NOTE: see the .cpp file for a discussion of why this
        // method is overloaded.

    // PRIVATE MANIPULATORS
    int loadSequenceElementDecodeProxy(SerializableObjectProxy    *proxy,
                                       const bdeat_AttributeInfo **info,
                                       int                         elementId);
        // If the sequence represented by this object contains an element with
        // the specified 'elementId', populate the specified 'proxy' so that it
        // can be used to decode into that element, load, into the specified
        // 'info', a pointer to the 'bdeat_AttributeInfo' for that element, and
        // return 0; otherwise return a non-zero value.  The behavior is
        // undefined unless this object represents a Sequence.

    int loadSequenceElementDecodeProxy(
                                SerializableObjectProxy    *proxy,
                                const bdeat_AttributeInfo **info,
                                const char                 *elementName,
                                int                         elementNameLength);
        // If the sequence contains an element with the specified 'elementName'
        // of the specified 'elementNameLength', populate the specified 'proxy'
        // for decoding into that element and load, into the specified 'info',
        // a pointer to the 'bdeat_AttributeInfo' for that element and return
        // 0.  Return non-zero otherwise.  The behavior is undefined unless
        // this object represents a Sequence.

    // PRIVATE ACCESSORS
    void loadArrayElementEncodeProxy(SerializableObjectProxy *proxy,
                                     int                      index) const;
        // Populate the specified 'proxy' for encoding the object at the
        // specified 'index' within the Array represented by this object.  The
        // behavior is undefined unless this object represents an array for
        // encoding, and that array contains at least 'index + 1' elements.

    void loadArrayElementDecodeProxy(SerializableObjectProxy *proxy,
                                     int                      index) const;
        // Populate the specified 'proxy' for decoding into the object at the
        // specified 'index' within the Array represented by this object.  The
        // behavior is undefined unless this object represents an array for
        // decoding, and that array contains at least 'index + 1' elements.

  public:
    // CREATORS
    SerializableObjectProxy();
        // Create a proxy object in an empty state.  The object must be
        // populated before being used for encoding or decoding.  Note that
        // clients are encouraged to use utilities provided in the
        // 'baea_serializableobjectproxyutil' component to populate the
        // 'SerializableObjectProxy' object.

    // NO-OP FUNCTIONS FOR INTEGRATION

    void reset();
        // Do nothing.  This method is required by 'bdeat'-based decoders but
        // is frequently unnecessary.  Note that because this method is a
        // no-op, users of 'SerializableObjectProxy' are responsible for
        // resetting target variables when decoding if needed.

    int maxSupportedBdexVersion() const;
        // Return -1.  'SerializableObjectProxy' does not support BDEX.  This
        // method is provided for integration with frameworks that assume the
        // complete 'bas_codegen' API, which is larger than the API required by
        // 'bdeat'-based codecs.

    template <class STREAM>
    STREAM& bdexStreamIn(STREAM& stream, int);
        // Mark the specified 'stream' invalid and return 'stream'.
        // 'SerializableObjectProxy' does not support BDEX.  This method is
        // provided for integration with frameworks that assume the complete
        // 'bas_codegen' API, which is larger than the API required by
        // 'bdeat'-based codecs.

    template <class STREAM>
    STREAM& bdexStreamOut(STREAM& stream, int) const;
        // Mark the specified 'stream' invalid and return 'stream'.
        // 'SerializableObjectProxy' does not support BDEX.  This method is
        // provided for integration with frameworks that assume the complete
        // 'bas_codegen' API, which is larger than the API required by
        // 'bdeat'-based codecs.

    // MANIPULATORS
    void resize(size_t newSize);
        // Change the size of the Array represented by this object to the
        // specified 'newSize'.  The behavior is undefined unless this object
        // represents an Array for decoding.

    int choiceMakeSelection(int selectionId);
        // Change the selection of the Choice represented by this object to the
        // specified 'selectionId' by invoking the chooser function supplied at
        // the 'loadChoice' method.  Return the result of the invocation.  The
        // behavior is undefined unless this object represents a Choice for
        // decoding.

    int choiceMakeSelection(const char *selectionName,
                            int         selectionNameLength);
        // Change the selection of the Choice represented by this object to the
        // selection having the specified 'selectionName' of the specified
        // 'selectionNameLength' by invoking the chooser function at the
        // 'loadChoice' method.  Return the result of the invocation if this
        // object contains the selection indicated by 'selectionName', and a
        // non-zero value otherwise.  The behavior is undefined unless this
        // object represents a Choice for decoding.

    template<typename MANIPULATOR>
    int choiceManipulateSelection(MANIPULATOR& manipulator);
        // Invoke the specified 'manipulator' on a proxy object, populated by
        // the 'loader' function supplied at the 'loadChoice' method,
        // representing the current selection of the Choice represented by this
        // object, and return the result of the invocation.  'MANIPULATOR'
        // shall be a functor providing methods that can be called as if it had
        // the following signatures:
        //..
        //  int operator()(SerializableObjectProxy *,
        //                 const bdeat_SelectionInfo&));
        //
        //  int operator()(SerializableObjectProxy_NullableAdapter *,
        //                 const bdeat_SelectionInfo&));
        //..
        // The behavior is undefined unless this object represents a Choice for
        // decoding.

    template<typename MANIPULATOR>
    int arrayManipulateElement(MANIPULATOR& manipulator, int index);
        // Invoke the specified 'manipulator' on a proxy object, populated by
        // the 'loader' function supplied at the 'loadArray' method,
        // representing the element at the specified 'index' in the vector
        // represented by this 'SerializableObjectProxy', and return the result
        // of the invocation.  'MANIPULATOR' shall be a functor providing
        // methods that can be called as if it had the following signatures:
        //..
        //  int operator()(const SerializableObjectProxy&);
        //  int operator()(const SerializableObjectProxy_NullableAdapter&);
        //..
        // The behavior is undefined unless this object represents a vector for
        // decoding, 'false == isByteArrayValue()', and '0 <= index < size()'.

    template<typename MANIPULATOR>
    int sequenceManipulateAttribute(MANIPULATOR& manipulator, int attributeId);
        // If the sequence represented by this object has an element with the
        // specified 'attributeId', invoke the specified 'manipulator' on a
        // proxy object, populated by the 'loader' function supplied at the
        // 'loadSequence' method, representing that element, and return the
        // result of the invocation; return a non-zero value if there is no
        // such element.  'MANIPULATOR' shall be a functor providing a method
        // that can be called as if it had the following signature:
        //..
        //  int operator()(SerializableObjectProxy *,
        //                 const bdeat_AttributeInfo&);
        //
        //  int operator()(SerializableObjectProxy_NullableAdapter *,
        //                 const bdeat_AttributeInfo&);
        //..
        // The behavior is undefined unless this object represents a Sequence.

    template<typename MANIPULATOR>
    int sequenceManipulateAttribute(MANIPULATOR&  manipulator,
                                    const char   *attributeName,
                                    int           nameLength);
        // If the sequence represented by this object has an element with the
        // specified 'attributeName' of the specified 'nameLength', invoke the
        // specified 'manipulator' on a proxy object, populated by the 'loader'
        // function supplied at the 'loadSequence' method, representing that
        // element, and return the result of the invocation; or return a
        // non-zero value if there is no such element.  'MANIPULATOR' shall be
        // a functor providing methods that can be called as if it had the
        // following signatures:
        //..
        //  int operator()(SerializableObjectProxy *,
        //                 const bdeat_AttributeInfo&);
        //
        //  int operator()(SerializableObjectProxy_NullableAdapter *,
        //                 const bdeat_AttributeInfo&)
        //..
        // The behavior is undefined unless this object represents a Sequence.

    template<typename MANIPULATOR>
    int sequenceManipulateAttributes(MANIPULATOR& manipulator);
        // Invoke the specified 'manipulator' on a number of proxy objects,
        // populated by the 'loader' function supplied at the 'loadSequence'
        // method, each representing an attribute of the sequence represented
        // by this object.  If any invocation returns a non-zero value, return
        // that value and stop invoking the manipulator; otherwise return 0
        // after 'manipulator' return 0 on all attributes.  'MANIPULATOR' shall
        // be a functor providing a method that can be called as if it had the
        // following signature:
        //..
        //  int operator()(SerializableObjectProxy *,
        //                 const bdeat_AttributeInfo&);
        //
        //  int operator()(SerializableObjectProxy_NullableAdapter *,
        //                 const bdeat_AttributeInfo&)
        //..
        // The behavior is undefined unless this object represents a sequence.

    template<typename MANIPULATOR>
    int manipulateSimple(MANIPULATOR& manipulator);
        // Invoke the specified 'manipulator' on the Simple value represented
        // by this object, and return the result of the invocation.
        // 'MANIPULATOR' shall be a functor providing a method that can be
        // called as if it had the following signature:
        //..
        // template <class TYPE>
        // int operator()(TYPE *, const bdeat_TypeCategory::Simple&)
        //..
        // The behavior in undefined unless this object represents a Simple
        // value.

    template<typename MANIPULATOR>
    int manipulateNullable(MANIPULATOR& manipulator);
        // Invoke the specified 'manipulator' on the (non-null) value held in
        // the nullable object referred to by this object, and return the
        // result of that invocation.  'MANIPULATOR' shall be a functor
        // providing a method that can be called as if it had the following
        // signature:
        //..
        //  template <class TYPE, class CATEGORY>
        //  int operator()(TYPE *, CATEGORY)
        //..
        // The behavior is undefined unless this object represents a non-null
        // Nullable value for decoding.

    int enumFromInt(int value);
        // Set the enumeration represented by this object to the specified
        // 'value' by invoking the 'intSetter' supplied at the
        // 'loadEnumeration' method, and return the result of the invocation.
        // The behavior is undefined unless this object represents an
        // Enumeration value for decoding.

    int enumFromString(const char *stringValue, int stringLength);
        // Set the enumeration represented by this object to the specified
        // 'stringValue' of the specified 'stringLength' by invoking the
        // 'stringSetter' supplied at the 'loadEnumeration' method, and return
        // the result of the invocation.  The behavior is undefined unless this
        // proxy represents an Enumeration value for decoding.

    void makeValue();
        // Invoke 'makeValue' on the Nullable object represented by this proxy.
        // The behavior is undefined unless this proxy represents a Nullable
        // value of type for decoding.  Note that the nullable object this
        // proxy represents is of type 'bdeut_NullableValue' or
        // 'bdeut_NullableAllocatedValue'.

    void loadSimple(char               *value);
    void loadSimple(unsigned char      *value);
    void loadSimple(short              *value);
    void loadSimple(int                *value);
    void loadSimple(bsls_Types::Int64  *value);
    void loadSimple(unsigned short     *value);
    void loadSimple(unsigned int       *value);
    void loadSimple(bsls_Types::Uint64 *value);
    void loadSimple(float              *value);
    void loadSimple(double             *value);
    void loadSimple(bsl::string        *value);
    void loadSimple(bdet_Datetime      *value);
    void loadSimple(bdet_Date          *value);
    void loadSimple(bdet_Time          *value);
    void loadSimple(bool               *value);
    void loadSimple(bdet_DatetimeTz    *value);
    void loadSimple(bdet_DateTz        *value);
    void loadSimple(bdet_TimeTz        *value);
        // Populate this 'SerializableObjectProxy' object to represent the
        // specified primitive 'value'.

    void loadChoice(void                                     *object,
                    const bdeat_SelectionInfo                *selectionInfo,
                    const char                               *className,
                    SerializableObjectProxyFunctions::Loader  loader);
        // Populate this proxy object to represent a Choice with the specified
        // 'className' for encoding with the specified 'selectionInfo'
        // containing information about the current selection; the specified
        // 'object' is the address of the selected object (not the address of
        // the choice object); and the specified 'loader' is a function that
        // will populate a 'SerializableObjectProxy' to represent the Choice's
        // current selection (i.e., 'object').

    void loadChoice(
         int                                                numSelections,
         void                                              *choice,
         const bdeat_SelectionInfo                         *selectionInfoArray,
         SerializableObjectProxyFunctions::SelectionLoader  loader,
         SerializableObjectProxyFunctions::Chooser          chooser);
        // Populate this 'SerializableObjectProxy' object to represent the
        // specified 'choice' object, having the specified 'numSelections' and
        // 'selectionInfoArray', for decoding; the specified 'loader' is a
        // function that, given 'choice', will populate a proxy object and an
        // offset into 'selectionInfoArray' to represent the current selection
        // of 'choice'; the specified 'chooser' is a function that will change
        // the selection of 'choice'.

    void loadSequence(
                int                                              numAttributes,
                void                                            *object,
                const bdeat_AttributeInfo                       *attributeInfo,
                const char                                      *className,
                SerializableObjectProxyFunctions::ElementLoader  loader);
        // Populate this 'SerializableObjectProxy' object to represent the
        // specified sequence 'object', having the specified 'className',
        // 'numSelections', and 'attributeInfo', for encoding or decoding.
        // 'loader' is a function that will populate a
        // 'SerializableObjectProxy' to represent a particular element in the
        // 'object'.

    void loadByteArray(bsl::vector<char> *object);
        // Populate this 'SerializableObjectProxy' to represent the specified
        // byte array, 'object', for encoding or decoding.

    void loadArray(int                                       length,
                   int                                       elementSize,
                   void                                     *begin,
                   SerializableObjectProxyFunctions::Loader  loader);
        // Populate this 'SerializableObjectProxy' to represent a
        // 'bsl::vector<T>' object for some element type 'T', having the
        // specified 'length', 'elementSize' in bytes, and 'begin' address, for
        // encoding.  'loader' is a function that will populate a
        // 'SerializableObjectProxy' for an object of 'T', the contained type
        // of the vector.

    void loadArray(void                                      *array,
                   int                                        length,
                   int                                        elementSize,
                   void                                      *begin,
                   SerializableObjectProxyFunctions::Resizer  resizer,
                   SerializableObjectProxyFunctions::Loader   loader);
        // Populate this 'SerializableObjectProxy' to represent a
        // 'bsl::vector<T>' object for some type 'T', at the address indicated
        // by the specified 'array', with the specified 'length', 'elementSize'
        // in bytes, and 'begin' address (0 if empty) for decoding; the
        // specified 'resizer' is a function that will change the size of
        // 'array' and the specified 'loader' is a function that populates a
        // 'SerializableObjectProxy' to represent an object of 'T'.

    void loadNullable(void                                     *object,
                      SerializableObjectProxyFunctions::Loader  loader);
        // Populate this 'SerializableObjectProxy' to represent a Nullable
        // object for encoding containing the specified 'object', or having a
        // null value if 'object' is 0; the specified 'loader' is a function
        // that populates a proxy to represent 'object', or it is ignored if
        // 'object' is 0.

    void loadNullable(
                void                                            *object,
                SerializableObjectProxyFunctions::Loader         loader,
                SerializableObjectProxyFunctions::ValueMaker     valueMaker,
                SerializableObjectProxyFunctions::ObjectFetcher  valueFetcher);
        // Populate this 'SerializableObjectProxy' to represent the specified
        // Nullable 'object' for decoding; the specified 'loader' is a function
        // that will populate a proxy for the *contained* object within the
        // nullable value; the specified 'valueMaker' is a function that will
        // make 'object' non-null, and the specified 'valueFetcher' is a
        // function that will return the address of the contained object.  The
        // behavior is undefined unless 'object' is the address of an object of
        // type 'bdeut_NullableAllocatedValue' or 'bdeut_NullableValue'.

    void loadEnumeration(int                         value,
                         const bdeat_EnumeratorInfo *infoArray,
                         int                         infoArraySize);
        // Populate this 'SerializableObjectProxy' to represent an Enumeration
        // having the specified 'value', and described by the specified
        // 'infoArray' of the specified 'infoArraySize', for encoding.

    void loadEnumeration(
                void                                           *address,
                SerializableObjectProxyFunctions::IntSetter     intSetter,
                SerializableObjectProxyFunctions::StringSetter  stringSetter,
                const bdeat_EnumeratorInfo                     *infoArray,
                int                                             infoArraySize);
        // Populate this 'SerializableObjectProxy' to represent an Enumeration
        // at the specified 'address', described by the specified 'infoArray'
        // of the specified 'infoArraySize', for decoding.  'intSetter' is a
        // function that will populate the enumeration at 'address' given an
        // 'int', and 'stringSetter' is a function that will populate the
        // object given a string.

    // ACCESSORS
    const char *className() const;
        // Return the class name of the Choice or Sequence represented by this
        // object, or 0 if this object has another type or the name is unknown.

    bdeat_TypeCategory::Value category() const;
        // Return the category of the type represented by this proxy, or
        // 'bdeat_TypeCategory::BDEAT_DYNAMIC_CATEGORY' if this proxy has not
        // been populated.

    int selectionId() const;
        // If this object represents a Choice, return the current selection of
        // that Choice; otherwise return
        // 'bdeat_ChoiceFunctions::BDEAT_UNDEFINED_SELECTION_ID'.

    bsl::size_t size() const;
        // Return the size of the Array represented by this object.  The
        // behavior is undefined unless this object represents an Array.

    const void* object() const;
        // Return the address provided to the "load" method
        // (e.g., 'loadChoice').  The meaning of this address depends on the
        // represented type and codec direction (encoding/decoding):
        //: 1 If representing a Nullable object for encoding, return 0 if the
        //:   value if the value is null, otherwise return the address of the
        //:   contained element.
        //: 2 If representing a Choice for encoding, return the address of the
        //:   selected element.
        //: 3 If representing an Enumeration for encoding, return 0.
        //: 4 If representing an Array for encoding, return 0 if the array is
        //:   empty, and the address of the first element otherwise.
        //: 5 In all other cases, return the address of the proxied value.

    bool isByteArrayValue() const;
        // Return 'true' if this object represents a 'bsl::vector<char>' for
        // encoding or decoding, and 'false' otherwise.

    bool isNull() const;
        // Return 'true' if this object represents a Nullable value that is
        // currently null, and 'false' otherwise.  The behavior is undefined
        // unless this object represent a Nullable value for encoding or
        // decoding.

    bool isValidForEncoding() const;
        // Return 'true' if this object represents a Choice, Array,
        // Enumeration, or Nullable for encoding; or a Sequence, Simple, or
        // byte array value.  Return 'false' otherwise.  Note that for
        // Sequence, Simple, and byte array values, both 'isValidForEncoding'
        // and 'isValidForDecoding' return 'true'.

    bool isValidForDecoding() const;
        // Return 'true' if this object represents a Choice, Array,
        // Enumeration, or Nullable for decoding; or a Sequence, Simple, or
        // byte array value.  Return 'false' otherwise.  Note that for
        // Sequence, Simple, and byte array values, both 'isValidForEncoding'
        // and 'isValidForDecoding' return 'true'.

    bool choiceHasSelection(const char *selectionName,
                            int         selectionNameLength) const;
        // Return 'true' if the Choice represented by this object contains a
        // selection with the specified 'selectionName' of the specified
        // 'selectionNameLength', and 'false' otherwise.  The behavior is
        // undefined unless this object represent a Choice for decoding.

    bool choiceHasSelection(int selectionId) const;
        // Return 'true' if the Choice represented by this object contains a
        // selection with the specified 'selectionId', and 'false' otherwise.
        // The behavior is undefined unless this object represents a Choice for
        // decoding.

    bool sequenceHasAttribute(const char *name, int nameLength) const;
        // Return 'true' if the Sequence represented by this object contains an
        // attribute with the specified 'name' of the specified 'nameLength',
        // and 'false' otherwise.  The behavior is undefined unless this object
        // represents a Sequence.

    bool sequenceHasAttribute(int attributeId) const;
        // Return 'true' if the Sequence represented by this object contains an
        // attribute with the specified 'attributeId', and 'false' otherwise.
        // The behavior is undefined unless this object represents a Sequence.

    template<typename ACCESSOR>
    int choiceAccessSelection(ACCESSOR& accessor) const;
        // Invoke the specified 'accessor' on a proxy object, populated by the
        // 'loader' function supplied at the 'loadChoice' method, representing
        // the current selection of the Choice represented by this object, and
        // return the result of the invocation.  'ACCESSOR' shall be a functor
        // providing methods that can be called as if it had the following
        // signatures:
        //..
        //  int operator()(const SerializableObjectProxy&,
        //                 const bdeat_SelectionInfo&));
        //
        //  int operator()(const SerializableObjectProxy_NullableAdapter&,
        //                 const bdeat_SelectionInfo&));
        //..
        // The behavior is undefined unless this object represents a Choice for
        // encoding.

    template<typename ACCESSOR>
    int sequenceAccessAttribute(ACCESSOR& accessor,
                                int       attributeId) const;
        // If the sequence represented by this object has an element with the
        // specified 'attributeId', invoke the specified 'accessor' on a proxy
        // object, populated by the 'loader' function supplied at the
        // 'loadSequence' method, representing on that element, and return the
        // result of the invocation; return a non-zero value if there is no
        // such element.  'ACCESSOR' shall be a functor providing methods that
        // can be called as if it had the following signatures:
        //..
        //  int operator()(const SerializableObjectProxy&,
        //                 const bdeat_AttributeInfo&);
        //
        //  int operator()(const SerializableObjectProxy_NullableAdapter&,
        //                 const bdeat_AttributeInfo&);
        //..
        // The behavior is undefined unless this object represents a Sequence.

    template<typename ACCESSOR>
    int sequenceAccessAttributes(ACCESSOR& accessor) const;
        // Invoke the specified 'accessor' on a number of proxy objects,
        // populated by the 'loader' function supplied at the 'loadSequence'
        // method, each representing an attribute of the sequence represented
        // by this object.  If any invocation returns a non-zero value, return
        // that value and stop invoking 'accessor'; otherwise return 0 after
        // 'accessor' return 0 on all attributes.  'ACCESSOR' shall be a
        // functor providing methods that can be called as if it had the
        // following signatures:
        //..
        //  int operator()(const SerializableObjectProxy&,
        //                 const bdeat_AttributeInfo&);
        //
        //  int operator()(const SerializableObjectProxy_NullableAdapter&,
        //                 const bdeat_AttributeInfo&);
        //..
        // The behavior is undefined unless this object represents a sequence.

    template<typename ACCESSOR>
    int accessNullable(ACCESSOR& accessor) const;
        // Invoke the specified 'accessor' on the (non-null) value held in the
        // nullable object referred to by this proxy, and return the result of
        // that invocation.  'ACCESSOR' shall be a functor providing a method
        // that can be called as if it had the following signature:
        //..
        //  template <class TYPE, class CATEGORY>
        //  int operator()(const TYPE&, TYPE_CATEGORY)
        //..
        // The behavior is undefined unless this object represents a non-null
        // Nullable value for encoding.

    template<typename ACCESSOR>
    int accessSimple(ACCESSOR& accessor) const;
        // Invoke the specified 'accessor' on the Simple value represented by
        // this object, and return the result of the invocation.  'ACCESSOR'
        // shall be a functor providing a method that can be called as if it
        // had the following signature:
        //..
        // template <class TYPE>
        // int operator()(const TYPE&, bdeat_TypeCategory::Simple)
        //..
        // The behavior in undefined unless this object represents a Simple
        // value.

    template<typename ACCESSOR>
    int arrayAccessElement(ACCESSOR& accessor, int index) const;
        // Invoke the specified 'accessor' on a proxy object, populated by
        // the 'loader' function supplied at the 'loadArray' method,
        // representing the element at the specified 'index' in the vector
        // represented by this 'SerializableObjectProxy', and return the result
        // of the invocation.  'ACCESSOR' shall be a functor providing methods
        // that can be called as if it had the following signatures:
        //..
        //  int operator()(const SerializableObjectProxy&);
        //  int operator()(const SerializableObjectProxy_NullableAdapter&);
        //..
        // The behavior is undefined unless this object represents a vector for
        // encoding, 'false == isByteArrayValue()', and '0 <= index < size()'.

    int enumToInt() const;
        // Return the integer representation of the Enumeration represented by
        // this object.  The behavior is undefined unless this object
        // represents an Enumerated value for encoding.

    const char* enumToString() const;
        // Return the string representation of the Enumeration represented by
        // this object.  The behavior is undefined unless this object
        // represents an Enumerated value for encoding.
};

// ============================================================================
//                  INLINE AND TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

inline
SerializableObjectProxy::SerializableObjectProxy()
: d_objectInfo(d_objectInfoArena.object())
, d_object_p(0)
, d_category(bdeat_TypeCategory::BDEAT_DYNAMIC_CATEGORY) // 0 ("invalid")
{
}

inline
void SerializableObjectProxy::reset()
{
}

inline
int SerializableObjectProxy::maxSupportedBdexVersion() const
{
    return -1;
}

template <class STREAM>
inline
STREAM& SerializableObjectProxy::bdexStreamIn(STREAM& stream, int)
{
    stream.invalidate();
    return stream;
}

template <class STREAM>
inline
STREAM& SerializableObjectProxy::bdexStreamOut(STREAM& stream, int) const
{
    stream.invalidate();
    return stream;
}

template <typename ACCESSOR>
int SerializableObjectProxy::accessSimple(ACCESSOR& accessor) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SimplePointer>());

    const SimplePointer& simplePtr = d_objectInfo.the<SimplePointer>();

    switch (simplePtr.d_type) {
      case SimplePointer::TYPE_CHAR: {
        return accessor(*(char*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_UCHAR: {
        return accessor(*(unsigned char*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_SHORT: {
        return accessor(*(short*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_INT: {
        return accessor(*(int*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_INT64: {
        return accessor(*(bsls_Types::Int64*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_USHORT: {
        return accessor(*(unsigned short*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_UINT: {
        return accessor(*(unsigned int*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_UINT64: {
        return accessor(*(bsls_Types::Uint64*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_FLOAT: {
        return accessor(*(float*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_DOUBLE: {
        return accessor(*(double*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_STRING: {
        return accessor(*(bsl::string*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_DATETIME: {
        return accessor(*(bdet_Datetime*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_DATE: {
        return accessor(*(bdet_Date*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_TIME: {
        return accessor(*(bdet_Time*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_BOOL: {
        return accessor(*(bool*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_DATETIMETZ: {
        return accessor(*(bdet_DatetimeTz*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_DATETZ: {
        return accessor(*(bdet_DateTz*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
      case SimplePointer::TYPE_TIMETZ: {
        return accessor(*(bdet_TimeTz*)d_object_p,
                        bdeat_TypeCategory::Simple());                // RETURN
      }
    }
    return -1;
}

template <typename MANIPULATOR>
int SerializableObjectProxy::manipulateSimple(MANIPULATOR& manipulator)
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SimplePointer>());

    const SimplePointer& simplePtr = d_objectInfo.the<SimplePointer>();

    switch (simplePtr.d_type) {
      case SimplePointer::TYPE_CHAR: {
        return manipulator((char*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_UCHAR: {
        return manipulator((unsigned char*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_SHORT: {
        return manipulator((short*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_INT: {
        return manipulator((int*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_INT64: {
        return manipulator((bsls_Types::Int64*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_USHORT: {
        return manipulator((unsigned short*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_UINT: {
        return manipulator((unsigned int*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_UINT64: {
        return manipulator((bsls_Types::Uint64*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_FLOAT: {
        return manipulator((float*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_DOUBLE: {
        return manipulator((double*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_STRING: {
        return manipulator((bsl::string*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_DATETIME: {
        return manipulator((bdet_Datetime*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_DATE: {
        return manipulator((bdet_Date*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_TIME: {
        return manipulator((bdet_Time*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_BOOL: {
        return manipulator((bool*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_DATETIMETZ: {
        return manipulator((bdet_DatetimeTz*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_DATETZ: {
        return manipulator((bdet_DateTz*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
      case SimplePointer::TYPE_TIMETZ: {
        return manipulator((bdet_TimeTz*)d_object_p,
                           bdeat_TypeCategory::Simple());             // RETURN
      }
    }
    return -1;
}

template<typename ACCESSOR>
int SerializableObjectProxy::accessContainedElement(
                                       const SerializableObjectProxy& proxy,
                                       ACCESSOR&                      accessor)
{
    if (proxy.category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = {
            const_cast<SerializableObjectProxy*>(&proxy)
        };
        return accessor(adapter);                                     // RETURN
    }
    else {
        return accessor(proxy);                                       // RETURN
    }
}

template<typename MANIPULATOR>
int SerializableObjectProxy::manipulateContainedElement(
                                        SerializableObjectProxy  *proxy,
                                        MANIPULATOR&              manipulator)
{
    if (proxy->category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = { proxy };
        return manipulator(&adapter);                                 // RETURN
    }
    else {
        return manipulator(proxy);                                    // RETURN
    }
}

template<typename MANIPULATOR>
int SerializableObjectProxy::manipulateContainedElement(
                                        SerializableObjectProxy   *proxy,
                                        MANIPULATOR&               manipulator,
                                        const bdeat_SelectionInfo& info)
{
    if (proxy->category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = { proxy };
        return manipulator(&adapter, info);                           // RETURN
    }
    else {
        return manipulator(proxy, info);                              // RETURN
    }
}

template<typename MANIPULATOR>
int SerializableObjectProxy::manipulateContainedElement(
                                        SerializableObjectProxy   *proxy,
                                        MANIPULATOR&               manipulator,
                                        const bdeat_AttributeInfo& info)
{
    if (proxy->category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = { proxy };
        return manipulator(&adapter, info);                           // RETURN
    }
    else {
        return manipulator(proxy, info);                              // RETURN
    }
}

template<typename ACCESSOR>
int SerializableObjectProxy::accessContainedElement(
                                       const SerializableObjectProxy& proxy,
                                       ACCESSOR&                      accessor,
                                       const bdeat_SelectionInfo&     info)
{
    if (proxy.category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = {
            const_cast<SerializableObjectProxy*>(&proxy)
        };
        return accessor(adapter, info);                               // RETURN
    }
    else {
        return accessor(proxy, info);                                 // RETURN
    }
}

template<typename ACCESSOR>
int SerializableObjectProxy::accessContainedElement(
                                       const SerializableObjectProxy& proxy,
                                       ACCESSOR&                      accessor,
                                       const bdeat_AttributeInfo&     info)
{
    if (proxy.category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = {
            const_cast<SerializableObjectProxy*>(&proxy)
        };
        return accessor(adapter, info);                               // RETURN
    }
    else {
        return accessor(proxy, info);                                 // RETURN
    }
}

template<typename MANIPULATOR>
int SerializableObjectProxy::manipulateNullable(MANIPULATOR& manipulator)
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<NullableDecodeInfo>());

    const NullableDecodeInfo& info = d_objectInfo.the<NullableDecodeInfo>();

    SerializableObjectProxy proxy;
    info.d_loader(&proxy, info.d_fetcher(d_object_p));

    return bdeat_TypeCategoryUtil::manipulateByCategory(&proxy, manipulator);
}

template<typename ACCESSOR>
int SerializableObjectProxy::accessNullable(ACCESSOR& accessor) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<NullableEncodeInfo>());
    BSLS_ASSERT_SAFE(d_object_p);

    SerializableObjectProxy proxy;
    d_objectInfo.the<NullableEncodeInfo>()(&proxy,
                                           const_cast<void*>(d_object_p));

    return bdeat_TypeCategoryUtil::accessByCategory(proxy, accessor);
}

template<typename ACCESSOR>
int SerializableObjectProxy::choiceAccessSelection(ACCESSOR& accessor) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<ChoiceEncodeInfo>());

    SerializableObjectProxy selectionProxy;
    const ChoiceEncodeInfo& info = d_objectInfo.the<ChoiceEncodeInfo>();
    info.d_loader(&selectionProxy, d_object_p);

    return accessContainedElement(selectionProxy,
                                  accessor,
                                  *info.d_selectionInfo_p);
}

template<typename MANIPULATOR>
int SerializableObjectProxy::choiceManipulateSelection(
                                                      MANIPULATOR& manipulator)
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<ChoiceDecodeInfo>());

    SerializableObjectProxy selectionProxy;
    const ChoiceDecodeInfo& info = d_objectInfo.the<ChoiceDecodeInfo>();
    const bdeat_SelectionInfo *selectionInfoPtr;

    d_objectInfo.the<ChoiceDecodeInfo>().d_loader(&selectionProxy,
                                                  d_object_p,
                                                  &selectionInfoPtr);

    return manipulateContainedElement(&selectionProxy,
                                      manipulator,
                                      *selectionInfoPtr);
}

template<typename MANIPULATOR>
int SerializableObjectProxy::sequenceManipulateAttribute(
                                                      MANIPULATOR& manipulator,
                                                      int          id)
{
    SerializableObjectProxy elementProxy;
    const bdeat_AttributeInfo *info;
    if (0 == loadSequenceElementDecodeProxy(&elementProxy, &info, id)) {
        BSLS_ASSERT_SAFE(elementProxy.isValidForDecoding());

        return manipulateContainedElement(&elementProxy, manipulator, *info);
                                                                      // RETURN
    }
    return -1;
}

template<typename MANIPULATOR>
int SerializableObjectProxy::sequenceManipulateAttribute(
                                                   MANIPULATOR&  manipulator,
                                                   const char   *attributeName,
                                                   int           nameLength)
{
    SerializableObjectProxy elementProxy;
    const bdeat_AttributeInfo *info;
    if (0 == loadSequenceElementDecodeProxy(&elementProxy,
                                            &info,
                                            attributeName,
                                            nameLength))
    {
        BSLS_ASSERT_SAFE(elementProxy.isValidForDecoding());

        return manipulateContainedElement(&elementProxy, manipulator, *info);
                                                                      // RETURN
    }
    return -1;
}

template<typename MANIPULATOR>
int SerializableObjectProxy::sequenceManipulateAttributes(
                                                      MANIPULATOR& manipulator)
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SequenceInfo>());

    SerializableObjectProxy elementProxy;
    const SequenceInfo& info = d_objectInfo.the<SequenceInfo>();

    for(int i = 0; i < info.d_numAttributes; ++i)
    {
        info.d_loader(&elementProxy, *this, i);

        BSLS_ASSERT_SAFE(elementProxy.isValidForDecoding());

        int rc = manipulateContainedElement(&elementProxy,
                                            manipulator,
                                            info.d_attributeInfo_p[i]);
        if (0 != rc) {
            return rc;                                                // RETURN
        }
    }
    return 0;
}

template<typename ACCESSOR>
int SerializableObjectProxy::sequenceAccessAttribute(ACCESSOR& accessor,
                                                     int       id) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SequenceInfo>());

    const SequenceInfo& info = d_objectInfo.the<SequenceInfo>();
    for(int i = 0; i < info.d_numAttributes; ++i)
    {
        if (info.d_attributeInfo_p[i].id() == id) {
            SerializableObjectProxy elementProxy;
            info.d_loader(&elementProxy, *this, i);

            BSLS_ASSERT_SAFE(elementProxy.isValidForEncoding());

            return accessContainedElement(elementProxy,
                                          accessor,
                                          info.d_attributeInfo_p[i]); // RETURN
        }
    }
    return -1;
}

template<typename ACCESSOR>
int SerializableObjectProxy::sequenceAccessAttributes(ACCESSOR& accessor) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SequenceInfo>());

    SerializableObjectProxy elementProxy;
    const SequenceInfo& info = d_objectInfo.the<SequenceInfo>();

    for(int i = 0; i < info.d_numAttributes; ++i)
    {
        info.d_loader(&elementProxy, *this, i);

        BSLS_ASSERT_SAFE(elementProxy.isValidForEncoding());

        int rc = accessContainedElement(elementProxy,
                                        accessor,
                                        info.d_attributeInfo_p[i]);
        if (0 != rc) {
            return rc;                                                // RETURN
        }
    }
    return 0;
}

template<typename ACCESSOR>
int SerializableObjectProxy::arrayAccessElement(ACCESSOR& accessor,
                                                int       index) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<ArrayEncodeInfo>());
    BSLS_ASSERT_SAFE(0 <= index);

    SerializableObjectProxy elementProxy;
    loadArrayElementEncodeProxy(&elementProxy, index);

    return accessContainedElement(elementProxy, accessor);
}

template<typename MANIPULATOR>
int SerializableObjectProxy::arrayManipulateElement(MANIPULATOR& manipulator,
                                                    int          index)
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<ArrayDecodeInfo>());
    BSLS_ASSERT_SAFE(0 <= index);
    BSLS_ASSERT_SAFE(index < size());

    SerializableObjectProxy elementProxy;
    loadArrayElementDecodeProxy(&elementProxy, index);

    return manipulateContainedElement(&elementProxy, manipulator);
}

inline
bdeat_TypeCategory::Value SerializableObjectProxy::category() const
{
    return d_category;
}

inline
const void *SerializableObjectProxy::object() const
{
    return d_object_p;
}

inline
bool SerializableObjectProxy::isByteArrayValue() const
{
    return d_objectInfo.is<ArrayEncodeInfo>() &&
        d_objectInfo.the<ArrayEncodeInfo>().d_loader == 0;
}

inline
bool SerializableObjectProxy::isValidForEncoding() const
{
    return isByteArrayValue() ||
        d_objectInfo.is<ChoiceEncodeInfo>() ||
        d_objectInfo.is<SequenceInfo>() ||
        d_objectInfo.is<ArrayEncodeInfo>() ||
        d_objectInfo.is<EnumEncodeInfo>() ||
        d_objectInfo.is<NullableEncodeInfo>() ||
        d_objectInfo.is<SimplePointer>();
}

inline
bool SerializableObjectProxy::isValidForDecoding() const
{
    return isByteArrayValue() ||
        d_objectInfo.is<ChoiceDecodeInfo>() ||
        d_objectInfo.is<SequenceInfo>() ||
        d_objectInfo.is<ArrayDecodeInfo>() ||
        d_objectInfo.is<EnumDecodeInfo>() ||
        d_objectInfo.is<NullableDecodeInfo>() ||
        d_objectInfo.is<SimplePointer>();
}

}  // close namespace baea

// ============================================================================
//                            Basic Type Traits
// ============================================================================

template<>
struct bslalg_TypeTraits<baea::SerializableObjectProxy> :
    bdeat_TypeTraitBasicChoice,
    bdeat_TypeTraitBasicSequence,
    bdeat_TypeTraitBasicEnumeration
{
};

// ============================================================================
//                     'bdeat_typecategory' overloads
// ============================================================================

template<>
struct bdeat_TypeCategoryDeclareDynamic<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

namespace bdeat_TypeCategoryFunctions {

template <>
inline
bdeat_TypeCategory::Value
bdeat_typeCategorySelect<baea::SerializableObjectProxy>(
                                   const baea::SerializableObjectProxy& object)
{
    return object.category();
}

}  // close namespace bdeat_TypeCategoryFunctions

namespace baea {

template <typename ACCESSOR>
inline
int bdeat_typeCategoryAccessSimple(
                                 const baea::SerializableObjectProxy& object,
                                 ACCESSOR&                            accessor)
{
    return object.accessSimple(accessor);
}

template <typename MANIPULATOR>
inline
int bdeat_typeCategoryManipulateSimple(
                                    baea::SerializableObjectProxy *object,
                                    MANIPULATOR&                   manipulator)
{
    return object->manipulateSimple(manipulator);
}

template <typename MANIPULATOR>
int bdeat_typeCategoryManipulateArray(
                                    baea::SerializableObjectProxy *object,
                                    MANIPULATOR&                   manipulator)
{
    if (object->isByteArrayValue()) {
        bsl::vector<char>* arrayPtr =
            (bsl::vector<char>*)object->object();
        return manipulator(arrayPtr, bdeat_TypeCategory::Array());    // RETURN
    }
    else {
        return manipulator(object, bdeat_TypeCategory::Array());      // RETURN
    }
}

template <typename ACCESSOR>
int bdeat_typeCategoryAccessArray(
                                 const baea::SerializableObjectProxy& object,
                                 ACCESSOR&                            accessor)
{
    if (object.isByteArrayValue()) {
        const bsl::vector<char>* arrayPtr =
                                   (const bsl::vector<char> *) object.object();
        return accessor(*arrayPtr, bdeat_TypeCategory::Array());      // RETURN
    }
    else {
        return accessor(object, bdeat_TypeCategory::Array());         // RETURN
    }
}

template <typename ACCESSOR>
int bdeat_typeCategoryAccessNullableValue(
                                 const baea::SerializableObjectProxy& object,
                                 ACCESSOR&                            accessor)
{
    if (object.category() == bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY
        && !object.isNull())
    {
        return object.accessNullable(accessor);                       // RETURN
    }
    return -1;
}

template <typename MANIPULATOR>
int bdeat_typeCategoryManipulateNullableValue(
                                    baea::SerializableObjectProxy* object,
                                    MANIPULATOR&                   manipulator)
{
    if (object->category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY)
    {
        BSLS_ASSERT_SAFE(!object->isNull()); // the default imp.  does this too
        return object->manipulateNullable(manipulator);               // RETURN
    }
    return -1;
}

}  // close namespace baea

// ============================================================================
//           'bdeat_enumfunctions' overloads and specializations
// ============================================================================
namespace bdeat_EnumFunctions {

// META-FUNCTIONS
bslmf_MetaInt<1> isEnumerationMetaFunction(
                                         const baea::SerializableObjectProxy&);
    // This function can be overloaded to support partial specialization
    // (Sun5.2 compiler is unable to partially specialize the 'struct'
    // below).  Note that this function is has no definition and should not
    // be called at run-time.

template <>
struct IsEnumeration<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

}  // close namespace bdeat_EnumFunctions

namespace baea {

inline
void bdeat_enumToInt(int *result, const baea::SerializableObjectProxy& object)
{
    *result = object.enumToInt();
}

inline
int bdeat_enumFromInt(baea::SerializableObjectProxy* result,
                      int value)
{
    return result->enumFromInt(value);
}


inline
void bdeat_enumToString(bsl::string                          *result,
                        const baea::SerializableObjectProxy&  object)
{
    *result = object.enumToString();
}

inline
int bdeat_enumFromString(baea::SerializableObjectProxy *result,
                         const char                    *stringValue,
                         int                            stringLength)
{
    return result->enumFromString(stringValue, stringLength);
}

}  // close namespace baea

// ============================================================================
//           'bdeat_arrayfunctions' overloads and specializations
// ============================================================================

namespace bdeat_ArrayFunctions {

bslmf_MetaInt<1> isArrayMetaFunction(const baea::SerializableObjectProxy&);

template <>
struct IsArray<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

template <>
struct ElementType<baea::SerializableObjectProxy> {
    typedef baea::SerializableObjectProxy Type;
};

}  // close namespace bdeat_ArrayFunctions

namespace baea {

inline
bsl::size_t bdeat_arraySize(const baea::SerializableObjectProxy& object)
{
    return object.size();
}

inline
void bdeat_arrayResize(baea::SerializableObjectProxy* object, int newSize)
{
    object->resize(newSize);
}

template <typename ACCESSOR>
inline
int bdeat_arrayAccessElement(const baea::SerializableObjectProxy& object,
                             ACCESSOR&                            accessor,
                             int                                  index)
{
    return object.arrayAccessElement(accessor, index);
}

template <typename MANIPULATOR>
inline
int bdeat_arrayManipulateElement(baea::SerializableObjectProxy* object,
                                 MANIPULATOR&                   manipulator,
                                 int                            index)
{
    return object->arrayManipulateElement(manipulator, index);
}

}  // close namespace baea

// ============================================================================
//           'bdeat_sequencefunctions' overloads and specializations
// ============================================================================

namespace bdeat_SequenceFunctions {

bslmf_MetaInt<1> isSequenceMetaFunction(const baea::SerializableObjectProxy&);

template <>
struct IsSequence<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

}  // close namespace bdeat_SequenceFunctions

namespace baea {

template <typename ACCESSOR>
inline
int bdeat_sequenceAccessAttributes(
                                 const baea::SerializableObjectProxy& object,
                                 ACCESSOR&                            accessor)
{
    return object.sequenceAccessAttributes(accessor);
}

template <typename ACCESSOR>
inline
int bdeat_sequenceAccessAttribute(const baea::SerializableObjectProxy& object,
                                  ACCESSOR&             accessor,
                                  int                   attributeId)
{
    return object.sequenceAccessAttribute(accessor, attributeId);
}

template <typename MANIPULATOR>
inline
int bdeat_sequenceManipulateAttributes(
                                    baea::SerializableObjectProxy *object,
                                    MANIPULATOR&                   manipulator)
{
    return object->sequenceManipulateAttributes(manipulator);
}

template <typename MANIPULATOR>
inline
int bdeat_sequenceManipulateAttribute(
                                    baea::SerializableObjectProxy *object,
                                    MANIPULATOR&                   manipulator,
                                    int                            attributeId)
{
    return object->sequenceManipulateAttribute(manipulator, attributeId);
}

template <typename MANIPULATOR>
inline
int bdeat_sequenceManipulateAttribute(baea::SerializableObjectProxy *object,
                                      MANIPULATOR& manipulator,
                                      const char*  attributeName,
                                      int          nameLength)
{
    return object->sequenceManipulateAttribute(manipulator, attributeName,
                                               nameLength);
}

inline
bool bdeat_sequenceHasAttribute(const baea::SerializableObjectProxy&  object,
                                int                         attributeId)
{
    return object.sequenceHasAttribute(attributeId);
}

inline
bool bdeat_sequenceHasAttribute(const baea::SerializableObjectProxy&  object,
                                const char                 *attributeName,
                                int                         nameLength)
{
    return object.sequenceHasAttribute(attributeName, nameLength);
}

}  // close namespace baea

// ============================================================================
//           'bdeat_nullablevaluefunctions' overloads and specializations
// ============================================================================
namespace bdeat_NullableValueFunctions {

bslmf_MetaInt<1> isNullableValueMetaFunction(
                         const baea::SerializableObjectProxy_NullableAdapter&);

template <>
struct IsNullableValue<baea::SerializableObjectProxy_NullableAdapter> {
    enum { VALUE = 1 };
};

template <>
struct ValueType<baea::SerializableObjectProxy_NullableAdapter> {
    typedef baea::SerializableObjectProxy Type;
};

}  // close namespace bdeat_NullableValueFunctions

namespace baea {

inline
bool bdeat_nullableValueIsNull(
                   const baea::SerializableObjectProxy_NullableAdapter& object)
{
    return object.d_proxy_p->isNull();
}

inline
void bdeat_nullableValueMakeValue(
                         baea::SerializableObjectProxy_NullableAdapter *object)
{
    object->d_proxy_p->makeValue();
}

template <typename MANIPULATOR>
inline
int bdeat_nullableValueManipulateValue(
                    baea::SerializableObjectProxy_NullableAdapter *object,
                    MANIPULATOR&                                   manipulator)
{
    return manipulator(object->d_proxy_p);
}

template <typename ACCESSOR>
inline
int bdeat_nullableValueAccessValue(
                 const baea::SerializableObjectProxy_NullableAdapter& object,
                 ACCESSOR&                                            accessor)
{
    return accessor(*object.d_proxy_p);
}

}  // close namespace baea

// ============================================================================
//                       'bdeat_typename' overloads
// ============================================================================
namespace bdeat_TypeName_Overloadable {

inline
const char *bdeat_TypeName_className(
                                   const baea::SerializableObjectProxy& object)
     // Return the type name of the type represented by the specified
     // 'object', or 0 if there is no such name.
{
    return object.className();
}

}  // close namespace bdeat_TypeName_Overloadable

// ============================================================================
//           'bdeat_choicefunctions' overloads and specializations
// ============================================================================

namespace bdeat_ChoiceFunctions {
bslmf_MetaInt<1> isChoiceMetaFunction(const baea::SerializableObjectProxy&);

template <>
struct IsChoice<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

}  // close namespace bdeat_ChoiceFunctions

namespace baea {

inline
int bdeat_choiceSelectionId(const baea::SerializableObjectProxy& object)
{
    return object.selectionId();
}

template <typename ACCESSOR>
inline
int bdeat_choiceAccessSelection(const baea::SerializableObjectProxy& object,
                                ACCESSOR&                            accessor)
{
    return object.choiceAccessSelection(accessor);
}

inline
bool bdeat_choiceHasSelection(
                     const baea::SerializableObjectProxy&  object,
                     const char                           *selectionName,
                     int                                   selectionNameLength)
{
    return object.choiceHasSelection(selectionName, selectionNameLength);
}

inline
bool bdeat_choiceHasSelection(const baea::SerializableObjectProxy& object,
                              int                                  selectionId)
{
    return object.choiceHasSelection(selectionId);
}

inline
int bdeat_choiceMakeSelection(baea::SerializableObjectProxy *object,
                              int                            selectionId)
{
    return object->choiceMakeSelection(selectionId);
}

inline
int bdeat_choiceMakeSelection(
                            baea::SerializableObjectProxy *object,
                            const char                    *selectionName,
                            int                            selectionNameLength)
{
    return object->choiceMakeSelection(selectionName, selectionNameLength);
}

template <typename MANIPULATOR>
inline
int bdeat_choiceManipulateSelection(baea::SerializableObjectProxy *object,
                                    MANIPULATOR&                   manipulator)
{
    return object->choiceManipulateSelection(manipulator);
}

}  // close namespace baea
}  // close namespace BloombergLP

#endif


// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2011
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ------------------------------ END-OF-FILE ---------------------------------
