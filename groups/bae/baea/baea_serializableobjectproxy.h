// baea_serializableobjectproxy.h                                   -*-C++-*-
#ifndef INCLUDED_BAEA_SERIALIZABLEOBJECTPROXY
#define INCLUDED_BAEA_SERIALIZABLEOBJECTPROXY

#include <bdes_ident.h>
BDES_IDENT_RCSID(baea_serializableobjectproxy_h,"$Id$ $CSID$")
BDES_IDENT_PRAGMA_ONCE

//@PURPOSE: Provide a dynamically-typed facade for serializable types.
//
//@AUTHOR: David Schumann (dschumann1)
//
//@CLASSES:
//           baea::SerializableObjectProxy: facade for autogenerated types
//  baea::SerializableObjectProxyFunctions: namespace for function type aliases
//
//@SEE_ALSO: baea_serializableobjectproxyutil, bdeat
//
//@DESCRIPTION: This component provides a class, 'SerializableObjectProxy',
// that serves as a proxy for encoding/decoding autogenerated,
// 'bdeat'-compliant objects.  It exposes all the accessors and manipulators
// required by bdeat-based encoders/decoders (see 'bdem_BerEncoder',
// 'bdem_BerDecoder', as well as similar types for XML), while referring to the
// data of the underlying object.  It also provides manipulators for
// configuring a proxy object to represent some other object; however, clients
// will typically use a higher level component (e.g.,
// 'baea_serializableobjectproxyutil') to configure the proxy object
// automatically.
//
// This component serves to reduce the size of executable code associated with
// encoding/decoding autogenerated objects because the encoder/decoder
// implementations are template-expanded in terms of
// 'SerializableObjectProxy' only, and not in terms of all the
// autogenerated types (of which there may be many).  Rather than encoding
// or decoding an object of autogenerated type directly, a client will
// create and populate a 'SerializableObjectProxy' to represent that
// object, and then encode/decode the proxy.
//
// The type categories of the 'bdeat' package are used throughout this
// component.  The terms "Array", "Choice", "Customized", "Enumeration",
// "Nullable", "Sequence", and "Simple" all refer to the corresponding
// 'bdeat' categories.
//
///Restrictions On Proxied Types
///-----------------------------
//
// SerializableObjectProxy imposes restrictions on the implementation
// of the proxied type that are stricter than those imposed by the 'bdeat'
// framework in order to simplify the resulting object code.
//
//: o All Array-type objects must be instantiations of bsl::vector.
//
//: o All Nullable types must be instantiations of either
//    'bdeut_NullableValue' or 'bdeut_NullableAllocatedValue'.
//
//: o All Choice types must have a 'NUM_SELECTIONS' enumerated value,
//    and class members named 'SELECTION_INFO_ARRAY' and 'CLASS_NAME'.
//
//: o All Sequence types must have a 'NUM_ATTRIBUTES' enumerated value,
//    and class members named 'ATTRIBUTE_INFO_ARRAY' and 'CLASS_NAME'.
//
//: o As mentioned above, the accessors (e.g., 'toString') of Customized
//    types are required to return const references to member variables -- the
//    addresses of these return values will be taken, so they must not be
//    temporaries.
//
// Violation of most of these restrictions will lead to an error at compile
// time.  However, violation of the last restriction listed (regarding the
// accessors of Customized types) will lead to undefined behavior at runtime.
// Note that types auto-generated by 'bas_codegen.pl' will meet all of these
// restrictions.
//
///Using 'SerializableObjectProxy'
///-------------------------------
//
// Use of 'SerializableObjectProxy' is intended to reduce the amount of
// compiled object code required to encode/decode objects.  As a result,
// certain optimizations have been made which require careful attention by the
// users of the type.
//
//: o When decoding, 'SerializableObjectProxy' does not 'reset' the state of
//:   the target variable, whereas the BER and XML encoders automatically do.
//:   As a result, users of 'SerializableObjectProxy' should manually reset the
//:   target variable before decoding.
//: o When decoding, 'SerializableObjectProxy' does not apply any of the
//:   restrictions on Customized types (e.g., length-limited strings).
//: o A particular 'SerializableObjectProxy' object supports either
//:   encoding or decoding, but not both.  Either 'makeEncodeProxy' or
//:   'makeDecodeProxy' in the 'SerializableObjectProxyUtil' namespace
//:   should be used as appropriate.
//: o 'SerializableObjectProxy' does not support BDEX.  It provides standard
//:   BDEX accessor functions for integration purposes, but these methods
//:   will fail (indicating encoding/decoding failure) at runtime if used.
//: o The encoder or decoder should be invoked on a proxy representing a
//:   Choice or Sequence.  There may be compile- or run-time issues if
//:   attempting to encode/decode a top-level object of one of the other
//:   bdeat types (Array, Nullable, etc).  In other words, the other bdeat
//:   types are required to be contained, recursively, within a top-level
//:   object that is a Choice or Sequence.
//
//
///Description of the Proxy Representation
///---------------------------------------
// When a 'SerializableObjectProxy' object is populated using one of the "load"
// methods (for example, 'loadChoice'), the caller specifies a function
// pointer.  In the example of populating a proxy for a Choice, the supplied
// function will populate a new proxy object to represent the selection of the
// represented Choice.  In practice, this function will be a template
// instantiation in a higher-level component such as
// 'SerializableObjectProxyUtil'.
//
// When a "visitor" compliant with the 'bdeat' framework is invoked on a
// 'SerializableObjectProxy', the proxy creates *another*
// 'SerializableObjectProxy' on the stack, invokes the function pointer
// supplied to its "load" method to populate that new object, and
// then recursively visits that object.  Recursion takes place in two ways:
// at compile time, instantiating template methods of the higher-level utility
// (e.g., SerializableObjectProxyUtil) recursively instantiates function
// templates for all the types that the encoder/decoder may encounter; and at
// runtime, applying an accessor or manipulator to a SerializableObjectProxy
// results in the recursive invocation of that accessor on temporary
// 'SerializableObjectProxy' objects created on the stack.
// Note that 'SerializableObjectProxy' objects are PODs so these temporary
// objects are relatively inexpensive to create and destroy.
//
// In the function-level documentation of this component, this recursive
// behavior is elided.  For example, the documentation of
// 'choiceManipulateSelection' states that it invokes the specified manipulator
// on the current selection of the choice.  In fact, it creates a proxy
// representing the current selection, and invokes the manipulator on that
// proxy.
//
///Usage Example
///-------------
//
// 'SerializableObjectProxy' must be populated prior to being used; then it
// can simply be passed to bdem-style encoders and decoders.  For an
// example of populating the proxy object, see the component documentation of
// 'SerializableObjectProxyUtil'.

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BDEAT_ATTRIBUTEINFO
#include <bdeat_attributeinfo.h>
#endif

#ifndef INCLUDED_BDEAT_ARRAYFUNCTIONS
#include <bdeat_arrayfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CHOICEFUNCTIONS
#include <bdeat_choicefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_ENUMERATORINFO
#include <bdeat_enumeratorinfo.h>
#endif

#ifndef INCLUDED_BDEAT_ENUMFUNCTIONS
#include <bdeat_enumfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_NULLABLEVALUEFUNCTIONS
#include <bdeat_nullablevaluefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_SELECTIONINFO
#include <bdeat_selectioninfo.h>
#endif

#ifndef INCLUDED_BDEAT_SEQUENCEFUNCTIONS
#include <bdeat_sequencefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_TYPECATEGORY
#include <bdeat_typecategory.h>
#endif

#ifndef INCLUDED_BDEAT_TYPETRAITS
#include <bdeat_typetraits.h>
#endif

#ifndef INCLUDED_BDEF_FUNCTION
#include <bdef_function.h>
#endif

#ifndef INCLUDED_BDET_DATETIMETZ
#include <bdet_datetimetz.h>
#endif

#ifndef INCLUDED_BDEUT_NULLABLEALLOCATEDVALUE
#include <bdeut_nullableallocatedvalue.h>
#endif

#ifndef INCLUDED_BDEUT_NULLABLEVALUE
#include <bdeut_nullablevalue.h>
#endif

#ifndef INCLUDED_BDEUT_VARIANT
#include <bdeut_variant.h>
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include <bslalg_typetraits.h>
#endif

#ifndef INCLUDED_BSLMF_METAINT
#include <bslmf_metaint.h>
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include <bsls_objectbuffer.h>
#endif

#ifndef INCLUDED_BSL_STRING
#include <bsl_string.h>
#endif

#ifndef INCLUDED_BSL_VECTOR
#include <bsl_vector.h>
#endif

namespace BloombergLP {

namespace baea {

class SerializableObjectProxy;

                   // ======================================
                   // class SerializableObjectProxyFunctions
                   // ======================================

struct SerializableObjectProxyFunctions {
    // A namespace for type aliases for common function pointer types used in
    // the interface of this component.

    typedef void  (*Accessor)(SerializableObjectProxy *proxy,
                              void                    *object);
    typedef void  (*AccessorAndExtractor)(
                                    SerializableObjectProxy    *proxy,
                                    void                       *object,
                                    const bdeat_SelectionInfo **selectInfoPtr);
    typedef void  (*ElementAccessor)(SerializableObjectProxy        *proxy,
                                     const SerializableObjectProxy&  object,
                                     int                             index);
    typedef int   (*Chooser)(void *object, int selectionId);

    typedef void  (*Resizer)(void         *object,
                             void        **newBeginAddress,
                             bsl::size_t   newSize);
    typedef void* (*ObjectFetcher)(void *object);
    typedef int   (*IntSetter)(void *object, int value);
    typedef int   (*StringSetter)(void *object, const char *value, int length);
    typedef void  (*Manipulator)(void *);
};

                // ====================================================
                // local class SerializableObjectProxy_ChoiceEncodeInfo
                // ====================================================

struct SerializableObjectProxy_ChoiceEncodeInfo {
    // This component-private 'struct' holds the data necessary to represent
    // a Choice-type object for encoding.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions; // for brevity

    // PUBLIC DATA
    int                        d_selectionId;     // ID of current selection
    const bdeat_SelectionInfo* d_selectionInfo_p; // info for current selection
    Functions::Accessor        d_accessor;        // create proxy for selection
    const char*                d_className_p;     // 0 allowed when no name

    // CREATORS
    SerializableObjectProxy_ChoiceEncodeInfo (
                                      int                        selectionId,
                                      const bdeat_SelectionInfo *selectionInfo,
                                      Functions::Accessor        accessor,
                                      const char                *className)
    : d_selectionId(selectionId)
    , d_selectionInfo_p(selectionInfo)
    , d_accessor(accessor)
    , d_className_p(className)
    {}
};

              // ====================================================
              // local class SerializableObjectProxy_ChoiceDecodeInfo
              // ====================================================

struct SerializableObjectProxy_ChoiceDecodeInfo {
    // This component-private "struct" holds the data necessary to
    // represent a Choice-type object for decoding.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions; // for brevity

    // PUBLIC DATA
    int                             d_numSelections;
    const bdeat_SelectionInfo*      d_selectionInfoArray_p;
    int                             d_currentSelection; // populated by chooser
    Functions::AccessorAndExtractor d_accessor; // creates proxy and gets info
                                                // for current selection
    Functions::Chooser              d_chooser;  // change the current selection

    // CREATORS
    SerializableObjectProxy_ChoiceDecodeInfo(
               int                             numSelections,
               const bdeat_SelectionInfo*      selectionInfoArray,
               Functions::AccessorAndExtractor accessor,
               Functions::Chooser              chooser)
    : d_numSelections(numSelections)
    , d_selectionInfoArray_p(selectionInfoArray)
    , d_currentSelection(bdeat_ChoiceFunctions::BDEAT_UNDEFINED_SELECTION_ID)
    , d_accessor(accessor)
    , d_chooser(chooser)
    {}
};

              // ===================================================
              // local class SerializableObjectProxy_ArrayEncodeInfo
              // ===================================================

struct SerializableObjectProxy_ArrayEncodeInfo {
    // This component-private "struct" holds the data necessary to represent
    // an Array-type object for encoding.  As described in the component-
    // level documentation, only instantiations of 'bsl::vector' are supported.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions; // for brevity

    // PUBLIC DATA
    int                          d_length;      // number of elements in vector
    int                          d_elementSize; // element size, in bytes
    Functions::Accessor          d_accessor;    // creates a proxy for an
                                                // object of the contained type

    // CREATORS
    SerializableObjectProxy_ArrayEncodeInfo(int                 length,
                                            int                 elementSize,
                                            Functions::Accessor accessor)
    : d_length(length)
    , d_elementSize(elementSize)
    , d_accessor(accessor)
    {}
};

              // ===================================================
              // local class SerializableObjectProxy_ArrayDecodeInfo
              // ===================================================

struct SerializableObjectProxy_ArrayDecodeInfo {
    // This component-private "struct" holds the data necessary to represent
    // an Array-type object for decoding.  As described in the component-
    // level documentation, only instantiations of bsl::vector are supported.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions; // for brevity

    // PUBLIC DATA
    int                 d_length;      // number of elements in vector
    int                 d_elementSize; // element size, in bytes
    void               *d_begin;       // address of first element, 0 if empty
    Functions::Resizer  d_resizer;     // changes size
    Functions::Accessor d_accessor;    // Creates a proxy for an object of the
                                       // contained type

    // CREATORS
    SerializableObjectProxy_ArrayDecodeInfo(
                                        int                       length,
                                        int                       elementSize,
                                        void                     *begin,
                                        Functions::Resizer        resizer,
                                        Functions::Accessor       accessor)
    : d_length(length)
    , d_elementSize(elementSize)
    , d_begin(begin)
    , d_resizer(resizer)
    , d_accessor(accessor)
    {}
};

              // ==================================================
              // local class SerializableObjectProxy_EnumDecodeInfo
              // ==================================================

struct SerializableObjectProxy_EnumDecodeInfo {
    // This component-private "struct" holds the data necessary to represent
    // an Enumeration-type object for decoding.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions; // for brevity

    // PUBLIC DATA
    Functions::IntSetter        d_intSetter;    // sets the value based on int
    Functions::StringSetter     d_stringSetter; // sets the value based on
                                                // a string
    const bdeat_EnumeratorInfo *d_infoArray_p;  // points to start of array
    int                         d_infoArraySize;// number of elements
};

              // ==================================================
              // local class SerializableObjectProxy_EnumEncodeInfo
              // ==================================================

struct SerializableObjectProxy_EnumEncodeInfo {
    // This component-private "struct" holds the data necessary to represent
    // an Enumeration-type object for encoding.

    // PUBLIC DATA
    int                         d_intVal;        // the current value as int
    const bdeat_EnumeratorInfo *d_infoArray_p;   // start of info array
    int                         d_infoArraySize; // number of elements
};

              // ================================================
              // local class SerializableObjectProxy_SequenceInfo
              // ================================================

struct SerializableObjectProxy_SequenceInfo {
    // This component-private "struct" holds the data necessary to
    // represent a Sequence-type object for either encoding or decoding

    // TYPES
    typedef SerializableObjectProxyFunctions Functions; // for brevity

    // PUBLIC DATA
    int                         d_numAttributes;
    const bdeat_AttributeInfo  *d_attributeInfo_p;
    Functions::ElementAccessor  d_accessor;    // creates a proxy for the
                                               // element at an index
    const char                 *d_className_p; // 0 allowed when when name
                                               // not known or when decoding

    // CREATORS
    SerializableObjectProxy_SequenceInfo(
                                 int                        numAttributes,
                                 const bdeat_AttributeInfo *attributeInfo,
                                 const char                *className,
                                 Functions::ElementAccessor accessor)
    : d_numAttributes(numAttributes)
    , d_attributeInfo_p(attributeInfo)
    , d_accessor(accessor)
    , d_className_p(className)
    {}
};

              // =================================================
              // local class SerializableObjectProxy_SimplePointer
              // =================================================

struct SerializableObjectProxy_SimplePointer {
    // This component-private 'struct' is used for representing a simple type.
    // The underlying type is represented by this struct, rather than by a
    // 'bdeut_Variant', to avoid extremely long mangled names that can result
    // from placing a large Variant inside another large Variant.

    // CONSTANTS
    enum Type {
        TYPE_CHAR,
        TYPE_UCHAR,
        TYPE_SHORT,
        TYPE_INT,
        TYPE_INT64,
        TYPE_USHORT,
        TYPE_UINT,
        TYPE_UINT64,
        TYPE_FLOAT,
        TYPE_DOUBLE,
        TYPE_STRING,
        TYPE_DATETIME,
        TYPE_DATE,
        TYPE_TIME,
        TYPE_BOOL,
        TYPE_DATETIMETZ,
        TYPE_DATETZ,
        TYPE_TIMETZ
    };

    void*  d_address;    // address of the represented value
    Type   d_type;       // type of the represented value
};

              // ==================================================
              // local class SerializableObjectProxy_NullableDecode
              // ==================================================

struct SerializableObjectProxy_NullableDecodeInfo {
    // This component-private "struct" is used when the proxy represents
    // a Nullable-type object for decoding.  As described in the
    // component-level documentation, only instantiations of
    // bdeut_NullableValue or bdeut_NullableAllocatedValue are supported.

    // TYPES
    typedef SerializableObjectProxyFunctions Functions; // for brevity

    // PUBLIC DATA
    Functions::Manipulator   d_valueMaker; // makes the value non-null
    Functions::ObjectFetcher d_fetcher;    // return address of underlying data
    Functions::Accessor      d_accessor;   // makes proxy for underlying data
};

// When representing a Nullable object for encoding, the only data
// necessary is the function for creating a proxy for the underlying object
typedef SerializableObjectProxyFunctions::Accessor
                                   SerializableObjectProxy_NullableEncodeInfo;

              // ===================================================
              // local class SerializableObjectProxy_NullableAdapter
              // ===================================================

struct SerializableObjectProxy_NullableAdapter {
    // Provide a type that holds a pointer to a 'SerializableObjectProxy' but
    // only exposes the Nullable trait, and not any other traits.  This is
    // required for integration with at least the BER decoder, which cannot
    // handle a nullable element of dynamic type contained within a dynamic
    // type.  So this adapter allows for a nullable 'SerializableObjectProxy'
    // of non-dynamic type.
    //
    // As described in the component-level documentation, the encoders/decoders
    // will not be invoked directly on Nullable proxies, but instead on
    // a Choice or Sequence; thus any Nullable object will be held within
    // another object.  So the accessor/manipulator methods of Choice, Array,
    // and Sequence will, before invoking the accessor/manipulator on a proxy
    // for a contained element, test whether that element is a Nullable, and
    // if so, construct an object of this type (NullableAdapter) and then
    // invoke the accessor/manipulator on it.

    SerializableObjectProxy *d_proxy_p; // held
};

                     // =============================
                     // class SerializableObjectProxy
                     // =============================

class SerializableObjectProxy {
    // This class provides a proxy mechanism for encoding and decoding.
    // 'SerializableObjectProxy' exposes the minimal interface required by
    // 'bdeat'-based codecs (see 'bdem_berencoder', 'baexml_encoder', etc) and
    // insulates the encoder/decoder from type information about the proxied
    // types, primarily types autogenerated by 'bas_codegen' or types that
    // expose the same introspection API.  Note that to use this this type,
    // clients will typically construct an instance and then populate it using
    // either 'SerializableObjectProxyUtil::makeEncodeProxy' or
    // 'SerializableObjectProxyUtil::makeDecodeProxy' as required.

    // PRIVATE TYPES

    typedef SerializableObjectProxy_ChoiceEncodeInfo   ChoiceEncodeInfo;
    typedef SerializableObjectProxy_ChoiceDecodeInfo   ChoiceDecodeInfo;
    typedef SerializableObjectProxy_SequenceInfo       SequenceInfo;
    typedef SerializableObjectProxy_ArrayEncodeInfo    ArrayEncodeInfo;
    typedef SerializableObjectProxy_ArrayDecodeInfo    ArrayDecodeInfo;
    typedef SerializableObjectProxy_EnumEncodeInfo     EnumEncodeInfo;
    typedef SerializableObjectProxy_EnumDecodeInfo     EnumDecodeInfo;
    typedef SerializableObjectProxy_NullableEncodeInfo NullableEncodeInfo;
    typedef SerializableObjectProxy_NullableDecodeInfo NullableDecodeInfo;
    typedef SerializableObjectProxy_SimplePointer      SimplePointer;

    typedef bdeut_Variant<ChoiceEncodeInfo,
                          ChoiceDecodeInfo,
                          SequenceInfo,
                          ArrayEncodeInfo,
                          ArrayDecodeInfo,
                          EnumEncodeInfo,
                          EnumDecodeInfo,
                          NullableEncodeInfo,
                          NullableDecodeInfo,
                          SimplePointer>               ObjectInfo;

    // DATA

    bsls_ObjectBuffer<ObjectInfo>     // This is held as an ObjectBuffer to
                   d_objectInfoArena; // avoid the expense of
                                      // default-constructing and (especially)
                                      // destroying the object.

    ObjectInfo    &d_objectInfo;      // Refers to the object held in the arena

    void          *d_object_p;        // Meaning depends on the type being
                                      // represented: (1) If representing a
                                      // nullable object for encoding, holds 0
                                      // if the value is null, otherwise holds
                                      // the address of the contained element.
                                      // (2) If representing a choice for
                                      // encoding, holds the address of the
                                      // selected element.  (3) In all other
                                      // cases, holds the address of the
                                      // proxied value.

    bdeat_TypeCategory::Value d_category;
                                      // dynamic type of proxied value

  private:
    // NOT IMPLEMENTED
    SerializableObjectProxy(const SerializableObjectProxy&);
    SerializableObjectProxy& operator=(const SerializableObjectProxy&);

    // PRIVATE CLASS METHODS
    template<typename ACCESSOR>
    static int accessContainedElement(const SerializableObjectProxy& proxy,
                                      ACCESSOR&                      accessor);
        // Invoke the specified 'accessor' on the object represented by the
        // specified 'proxy', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and return the result of the invocation.
        // 'ACCESSOR' shall be a functor providing a method that can be called
        // as if it had the following signature:
        //..
        //   int operator()(const TYPE&)
        //..
        // where TYPE is 'SerializableObjectProxy' or
        // 'SerializableObjectProxy_NullableAdapter'.

    template<typename ACCESSOR>
    static int accessContainedElement(const SerializableObjectProxy& proxy,
                                      ACCESSOR&                      accessor,
                                      const bdeat_SelectionInfo&     info);
        // Invoke the specified 'accessor' on the object represented by the
        // specified 'proxy', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and the specified 'info', and return the result of
        // the invocation.  'ACCESSOR' shall be a functor providing a method
        // that can be called as if it had the following signature:
        //..
        //   int operator()(const TYPE&, const bdeat_SelectionInfo&)
        //..
        // where TYPE is 'SerializableObjectProxy' or
        // 'SerializableObjectProxy_NullableAdapter'.

    template<typename ACCESSOR>
    static int accessContainedElement(const SerializableObjectProxy& proxy,
                                      ACCESSOR&                      accessor,
                                      const bdeat_AttributeInfo&     info);
        // Invoke the specified 'accessor' on the object represented by the
        // specified 'proxy', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and the specified 'info', and return the result of
        // the invocation.  'ACCESSOR' shall be a functor providing a method
        // that can be called as if it had the following signature:
        //..
        //   int operator()(const TYPE&, const bdeat_AttributeInfo&)
        //..
        // where TYPE is 'SerializableObjectProxy' or
        // 'SerializableObjectProxy_NullableAdapter'.

    template<typename MANIPULATOR>
    static int manipulateContainedElement(
                                         SerializableObjectProxy *proxy,
                                         MANIPULATOR&             manipulator);
    static int manipulateContainedElement(
                SerializableObjectProxy                          *proxy,
                bdef_Function<int(*)(SerializableObjectProxy*)>&  manipulator);
        // Invoke the specified 'manipulator' on the object represented by the
        // specified 'proxy', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and return the result of the invocation.
        // 'MANIPULATOR' shall be a functor providing a method that can be
        // called as if it had the following signature:
        //..
        //   int operator()(TYPE*)
        //..
        // where TYPE is 'SerializableObjectProxy' or
        // 'SerializableObjectProxy_NullableAdapter'.  IMPLEMENTATION NOTE: see
        // the .cpp file for a discussion of why this method is overloaded.

    template<typename MANIPULATOR>
    static int manipulateContainedElement(
                                       SerializableObjectProxy   *proxy,
                                       MANIPULATOR&               manipulator,
                                       const bdeat_SelectionInfo& info);
    static int manipulateContainedElement(
              SerializableObjectProxy                            *proxy,
              bdef_Function<int(*)(SerializableObjectProxy*,
                                   const bdeat_SelectionInfo&)>&  manipulator,
              const bdeat_SelectionInfo&                          info);
        // Invoke the specified 'manipulator' on the object represented by the
        // specified 'proxy', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and the specified 'info', and return the result of
        // the invocation.  'MANIPULATOR' shall be a functor providing a method
        // that can be called as if it had the following signature:
        //..
        //   int operator()(TYPE*, const bdeat_SelectionInfo&)
        //..
        // where TYPE is 'SerializableObjectProxy' or
        // 'SerializableObjectProxy_NullableAdapter'.  IMPLEMENTATION NOTE: see
        // the .cpp file for a discussion of why this method is overloaded.

    template<typename MANIPULATOR>
    static int manipulateContainedElement(SerializableObjectProxy  *proxy,
                                          MANIPULATOR&  accessor,
                                          const bdeat_AttributeInfo& info);
    static int manipulateContainedElement(
              SerializableObjectProxy                            *proxy,
              bdef_Function<int(*)(SerializableObjectProxy*,
                                   const bdeat_AttributeInfo&)>&  manipulator,
              const bdeat_AttributeInfo&                          info);
        // Invoke the specified 'manipulator' on the object represented by the
        // specified 'proxy', creating a
        // 'SerializableObjectProxy_NullableAdapter' to represent it if
        // necessary (see the class-level documentation of that type for
        // further details), and the specified 'info', and return the result of
        // the invocation.  'MANIPULATOR' shall be a functor providing a method
        // that can be called as if it had the following signature:
        //..
        //   int operator()(TYPE*, const bdeat_AttributeInfo&)
        //..
        // where TYPE is 'SerializableObjectProxy' or
        // 'SerializableObjectProxy_NullableAdapter'.  IMPLEMENTATION NOTE: see
        // the .cpp file for a discussion of why this method is overloaded.

    // PRIVATE ACCESSORS
    void loadArrayElementEncodeProxy(SerializableObjectProxy  *proxy,
                                     int                       index) const;
        // Populate the specified 'proxy' for encoding the object at the
        // specified 'index' within the Array represented by this object.  The
        // behavior is undefined unless this object represents an array for
        // encoding, and that array contains at least 'index+1' elements.

    void loadArrayElementDecodeProxy(SerializableObjectProxy  *proxy,
                                     int                       index) const;
        // Populate the specified 'proxy' for decoding into the object at the
        // specified 'index' within the Array represented by this object.  The
        // behavior is undefined unless this object represents an array for
        // decoding, and that array contains at least 'index+1' elements.

    // PRIVATE MANIPULATORS
    int loadSequenceElementDecodeProxy(SerializableObjectProxy    *proxy,
                                       const bdeat_AttributeInfo **info,
                                       int                         elementId);
        // If the sequence represented by this object contains an element with
        // the specified 'elementId', populate the specified 'proxy' so that it
        // can be used to decode into that element, load into 'info' a pointer
        // to the bdeat_AttributeInfo for that element, and return 0; otherwise
        // return a non-zero value.  The behavior is undefined unless this
        // object represents a Sequence.

    int loadSequenceElementDecodeProxy(
                                SerializableObjectProxy    *proxy,
                                const bdeat_AttributeInfo **info,
                                const char                 *elementName,
                                int                         elementNameLength);
        // If the sequence contains an element with the specified 'elementName'
        // of the specified 'elementNameLength', populate 'proxy' for decoding
        // into that element and load into 'info' a pointer to the
        // bdeat_AttributeInfo for that element and return 0.  Return non-zero
        // otherwise.  The behavior is undefined unless this object represents
        // a Sequence.

  public:
    // CREATORS
    SerializableObjectProxy();
        // Create a proxy object in an empty state.  The object must be
        // populated before being used for encoding or decoding.  Note that the
        // methods in 'SerializableObjectProxyUtil' are ideal for populating
        // the proxy appropriately.

    // NO-OP FUNCTIONS FOR INTEGRATION

    void reset();
        // Do nothing.  This method is required by 'bdeat'-based decoders but
        // is frequently unnecessary.  Note that because this method is a
        // no-op, users of 'SerializableObjectProxy' are responsible for
        // resetting target variables when decoding if needed.

    int maxSupportedBdexVersion() const;
        // Return -1.  'SerializableObjectProxy' does not support BDEX.  This
        // method is provided for integration with frameworks that assume the
        // complete 'bas_codegen' API, which is larger than the API required by
        // 'bdeat'-based codecs.

    template <class STREAM>
    STREAM& bdexStreamIn(STREAM& stream, int);
        // Mark the specified 'stream' invalid and return 'stream'.
        // 'SerializableObjectProxy' does not support BDEX.  This method is
        // provided for integration with frameworks that assume the complete
        // 'bas_codegen' API, which is larger than the API required by
        // 'bdeat'-based codecs.

    template <class STREAM>
    STREAM& bdexStreamOut(STREAM& stream, int) const;
        // Mark the specified 'stream' invalid and return 'stream'.
        // 'SerializableObjectProxy' does not support BDEX.  This method is
        // provided for integration with frameworks that assume the complete
        // 'bas_codegen' API, which is larger than the API required by
        // 'bdeat'-based codecs.

    // MANIPULATORS
    void resize(size_t newSize);
        // Change the size of the Array represented by this object to the
        // specified 'newSize'.  The behavior is undefined unless this object
        // represents an Array for decoding.

    int choiceMakeSelection(int selectionId);
        // Change the selection of the Choice represented by this object to the
        // specified 'selectionId'.  Return 0 on success, and a non-zero value
        // otherwise.  The behavior is undefined unless this object represents
        // a Choice for decoding.

    int choiceMakeSelection(const char *selectionName,
                            int         selectionNameLength);
        // Change the selection of the Choice represented by this object to the
        // selection having the specified 'selectionName' of the specified
        // 'selectionNameLength'.  Return 0 on success, and a non-zero value
        // otherwise.  The behavior is undefined unless this object represents
        // a Choice for decoding.

    template<typename MANIPULATOR>
    int choiceManipulateSelection(MANIPULATOR& manipulator);
        // Invoke the specified 'manipulator' on the current selection of the
        // choice represented by this object, and return the result of the
        // invocation.  'MANIPULATOR' shall be a functor providing a method
        // that can be called as if it had the following signature:
        //..
        // int operator()(TYPE*, const bdeat_SelectionInfo&)
        //..
        // where 'TYPE' is the type of the selection of the choice represented
        // by this object.  The behavior is undefined unless this object
        // represents a Choice for decoding.

    template<typename MANIPULATOR>
    int arrayManipulateElement(MANIPULATOR& manipulator, int index);
        // Invoke the specified 'manipulator' on the element at the specified
        // 'index' in the vector represented by this SerializableObjectProxy,
        // and return the result of the invocation.  'MANIPULATOR' shall be a
        // functor providing a method that can be called as if it had the
        // following signature:
        //..
        // int operator()(TYPE*)
        //..
        // where 'TYPE' is the type held in the array represented by this
        // object.  The behavior is undefined unless this object represents a
        // vector for decoding, and that vector has at least 'index+1'
        // elements.

    template<typename MANIPULATOR>
    int sequenceManipulateAttribute(MANIPULATOR& manipulator, int attributeId);
        // If the sequence represented by this object has an element with the
        // specified 'attributeId', invoke the specified 'manipulator' on that
        // element, and return the result of the invocation; or return a
        // non-zero value if there is no such element.  'MANIPULATOR' shall be
        // a functor providing a method that can be called as if it had the
        // following signature:
        //..
        // int operator()(TYPE*, const bdeat_AttributeInfo&)
        //..
        // where 'TYPE' is the type of the element having 'attributeId'.  The
        // behavior is undefined unless this object represents a Sequence.

    template<typename MANIPULATOR>
    int sequenceManipulateAttribute(MANIPULATOR& manipulator,
                                    const char*  attributeName,
                                    int          nameLength);
        // If the sequence represented by this object has an element with the
        // specified 'attributeName' of the specified 'nameLength', invoke the
        // specified 'manipulator' on that element, and return the result of
        // the invocation; or return a non-zero value if there is no such
        // element.  'MANIPULATOR' shall be a functor providing a method that
        // can be called as if it had the following signature:
        //..
        // int operator()(TYPE*, const bdeat_AttributeInfo&)
        //..
        // where 'TYPE' is the type of the element having 'attributeName'.  The
        // behavior is undefined unless this object represents a Sequence.

    template<typename MANIPULATOR>
    int manipulateSimple(MANIPULATOR& manipulator);
        // Invoke the specified 'manipulator' on the Simple value represented
        // by this object, and return the result of the invocation.
        // 'MANIPULATOR' shall be a functor providing a method that can be
        // called as if it had the following signature:
        //..
        // int operator()(TYPE*, bdeat_TypeCategory::Simple)
        //..
        // where 'TYPE' is the type of the element represented by this object.
        // The behavior in undefined unless this object represents a Simple
        // value.

    template<typename MANIPULATOR>
    int manipulateNullable(MANIPULATOR& manipulator);
        // Invoke the specified 'manipulator' on the (non-null) value held in
        // the nullable object referred to through this proxy, and return the
        // result of that invocation.  'MANIPULATOR' shall be a functor
        // providing a method that can be called as if it had the following
        // signature:
        //..
        //  int operator()(TYPE*, TYPE_CATEGORY)
        //..
        // where 'TYPE' is the type of value held in the nullable object this
        // object proxies, and 'TYPE_CATEGORY' is the 'bdeat_TypeCategory'
        // enumerator that describes 'TYPE'.  The behavior is undefined unless
        // this object represents a non-null Nullable value for decoding.

    int enumFromInt(int value);
        // Set the enumeration represented by this object to the specified
        // 'value'.  Return 0 on success, and a non-zero value otherwise.  The
        // behavior is undefined unless this object represents an
        // Enumeration-type value for decoding.

    int enumFromString(const char *stringValue, int stringLength);
        // Set the enumeration represented by this object to the specified
        // 'stringValue' of the specified 'stringLength'.  Return 0 on success,
        // and a non-zero value otherwise.  The behavior is undefined unless
        // this proxy represents an Enumeration-type value for decoding.

    void makeValue();
        // Invoke 'makeValue' on the Nullable object represented by this proxy
        // (which, as described in the component-level documentation, is
        // required to be an instantiation of either bdeut_NullableValue or
        // bdeut_NullableAllocatedValue).  The behavior is undefined unless
        // this proxy represents a Nullable-type value for decoding.

    void loadSimple(char               *value);
    void loadSimple(unsigned char      *value);
    void loadSimple(short              *value);
    void loadSimple(int                *value);
    void loadSimple(bsls_Types::Int64  *value);
    void loadSimple(unsigned short     *value);
    void loadSimple(unsigned int       *value);
    void loadSimple(bsls_Types::Uint64 *value);
    void loadSimple(float              *value);
    void loadSimple(double             *value);
    void loadSimple(bsl::string        *value);
    void loadSimple(bdet_Datetime      *value);
    void loadSimple(bdet_Date          *value);
    void loadSimple(bdet_Time          *value);
    void loadSimple(bool               *value);
    void loadSimple(bdet_DatetimeTz    *value);
    void loadSimple(bdet_DateTz        *value);
    void loadSimple(bdet_TimeTz        *value);
        // Populate this 'SerializableObjectProxy' object to represent the
        // specified primitive 'value'.

    void loadChoice(int                                         selectionId,
                    void                                       *object,
                    const bdeat_SelectionInfo                  *selectionInfo,
                    const char                                 *className,
                    SerializableObjectProxyFunctions::Accessor  accessor);
        // Populate this proxy object to represent a Choice of the specified
        // 'className' for encoding.  The specified 'selectionId' is the id of
        // the current selection, associated with the specified
        // 'selectionInfo'; the specified 'object' is the address of the
        // selection (not the address of the choice object); and the specified
        // 'accessor' is a function that will populate a
        // 'SerializableObjectProxy' to represent the choice's current
        // selection (i.e., 'object').

    void loadChoice(int                                     numSelections,
                    void                                   *choice,
                    const bdeat_SelectionInfo              *selectionInfoArray,
                    SerializableObjectProxyFunctions::AccessorAndExtractor
                                                            accessor,
                    SerializableObjectProxyFunctions::Chooser
                                                            chooser);
        // Populate this 'SerializableObjectProxy' object to represent the
        // specified 'choice' object for decoding.  The choice type has the
        // specified 'numSelections' and 'selectionInfoArray'.  'accessor' is a
        // function that, given 'choice', will populate a proxy object and an
        // offset into 'selectionInfoArray' to represent the current selection
        // of 'choice'.  'chooser' is a function that will change the selection
        // of 'choice'.

    void loadSequence(int                                       numSelections,
                      void                                     *object,
                      const bdeat_AttributeInfo                *attributeInfo,
                      const char                               *className,
                      SerializableObjectProxyFunctions::ElementAccessor
                                                                accessor);
        // Populate this 'SerializableObjectProxy' object to represent the
        // specified sequence 'object', having the specified 'className',
        // 'numSelections', and 'attributeInfo', for encoding or decoding.
        // 'accessor' is a function that will populate a
        // 'SerializableObjectProxy' to represent a particular element in the
        // 'object'.

    void loadArray(int                                         length,
                   int                                         elementSize,
                   void                                       *begin,
                   SerializableObjectProxyFunctions::Accessor  accessor);
        // Populate this 'SerializableObjectProxy' to represent an
        // instantiation of 'bsl::vector<T>' for some element type 'T', having
        // the specified 'length', 'elementSize' in bytes, and 'begin' address,
        // for encoding.  'accessor' is a function that will populate a
        // 'SerializableObjectProxy' for an object of 'T', the contained type
        // of the vector.

    void loadArray(void                                           *array,
                   int                                             length,
                   int                                             elementSize,
                   void                                           *begin,
                   SerializableObjectProxyFunctions::Resizer       resizer,
                   SerializableObjectProxyFunctions::Accessor      accessor);
        // Populate this 'SerializableObjectProxy' to represent the specified
        // 'array', an instantiation of vector<T> for some type T, for
        // decoding.  The vector has the specified 'length', 'elementSize' in
        // bytes, and 'begin' address (0 if empty).  'resizer' is a function
        // that will change the size of 'array' and 'accessor' is a function
        // that populates a 'SerializableObjectProxy' to represent an object of
        // T.

    void loadNullable(void                                      *object,
                      SerializableObjectProxyFunctions::Accessor accessor);
        // Populate this 'SerializableObjectProxy' to represent a Nullable
        // object for encoding containing the specified 'object', or having a
        // null value if 'object' is 0.  'accessor' is a function that
        // populates a proxy to represent 'object', or it is ignored if
        // 'object' is 0.

    void loadNullable(void                                      *object,
                 SerializableObjectProxyFunctions::Accessor      accessor,
                 SerializableObjectProxyFunctions::Manipulator   valueMaker,
                 SerializableObjectProxyFunctions::ObjectFetcher valueFetcher);
        // Populate this 'SerializableObjectProxy' to represent the specified
        // Nullable 'object' for decoding.  'accessor' is a function that will
        // populate a proxy for the *contained* object within the nullable
        // value.  'valueMaker' is a function that will make 'object' non-null,
        // and 'valueFetcher' is a function that will return the address of the
        // contained object.

    void loadEnumeration(int                         value,
                         const bdeat_EnumeratorInfo *infoArray,
                         int                         infoArraySize);
        // Populate this 'SerializableObjectProxy' to represent an enumerated
        // constant having the specified 'value', and described by the
        // specified 'infoArray' of the specified 'infoArraySize', for
        // encoding.

    void loadEnumeration(
               void                                           *address,
               SerializableObjectProxyFunctions::IntSetter     intSetter,
               SerializableObjectProxyFunctions::StringSetter  stringSetter,
               const bdeat_EnumeratorInfo                     *infoArray,
               int                                             infoArraySize);
        // Populate this 'SerializableObjectProxy' to represent an enumerated
        // constant at the specified 'address', described by the specified
        // 'infoArray' of the specified 'infoArraySize', for decoding.
        // 'intSetter' is a function that will populate the object at 'address'
        // given an int, and 'stringSetter' is a function that will populate
        // the object given a string.

    // ACCESSORS
    const char *className() const;
        // Return the class name of the Choice or Sequence represented by this
        // object, or 0 if this object has another type or the name is unknown.

    bdeat_TypeCategory::Value category() const;
        // Return the category of the type represented by this proxy, or
        // 'bdeat_TypeCategory::BDEAT_DYNAMIC_CATEGORY' if this proxy has not
        // been populated.

    int selectionId() const;
        // If this object represents a Choice, return the current selection of
        // that Choice; otherwise return
        // bdeat_ChoiceFunctions::BDEAT_UNDEFINED_SELECTION_ID.

    bsl::size_t size() const;
        // Return the size of the Array represented by this object.  The
        // behavior is undefined unless this object represents an Array.

    const void* object() const;
        // Return the address provided to the "load" method (e.g.,
        // 'loadChoice').  The meaning of this address depends on the
        // represented type and codec direction (encoding/decoding): (1) If
        // representing a nullable object for encoding, return 0 if the value
        // if the value is null, otherwise return the address of the contained
        // element.  (2) If representing a choice for encoding, return the
        // address of the selected element.  (3) In all other cases, return the
        // address of the proxied value.

    bool isByteArrayValue() const;
        // Return 'true' if this object represents a 'bsl::vector<char>' for
        // encoding, and 'false' otherwise.

    bool isNull() const;
        // Return 'true' if this object represents a Nullable value that is
        // currently null, and 'false' otherwise.

    bool choiceHasSelection(const char *selectionName,
                            int         selectionNameLength) const;
        // Return 'true' if the Choice represented by this object contains a
        // selection with the specified 'selectionName' of the specified
        // 'selectionNameLength', and 'false' otherwise.  The behavior is
        // undefined if this object does not represent a Choice for decoding.

    bool choiceHasSelection(int selectionId) const;
        // Return 'true' if the Choice represented by this object contains a
        // selection with the specified 'selectionId', and 'false' otherwise.
        // The behavior is undefined unless this object represents a Choice for
        // decoding.

    bool sequenceHasAttribute(const char *name, int nameLength) const;
        // Return 'true' if the Sequence represented by this object contains an
        // attribute with the specified 'name' of the specified 'nameLength',
        // and 'false' otherwise.  The behavior is undefined unless this object
        // represents a Sequence.

    bool sequenceHasAttribute(int attributeId) const;
        // Return 'true' if the Sequence represented by this object contains an
        // attribute with the specified 'attributeId', and 'false' otherwise.
        // The behavior is undefined unless this object represents a Sequence.

    template<typename ACCESSOR>
    int choiceAccessSelection(ACCESSOR& accessor) const;
        // Invoke the specified 'accessor' on the current selection of the
        // choice represented by this object, and return the result of the
        // invocation.  'ACCESSOR' shall be a functor providing a method that
        // can be called as if it had the following signature:
        //..
        // int operator()(const TYPE&, const bdeat_SelectionInfo&)
        //..
        // where 'TYPE' is the type of the selection of the choice represented
        // by this object.  The behavior is undefined unless this object
        // represents a Choice for encoding.

    template<typename ACCESSOR>
    int sequenceAccessAttribute(ACCESSOR&  accessor,
                                int        attributeId) const;
        // If the sequence represented by this object has an element with the
        // specified 'attributeId', invoke the specified 'accessor' on that
        // element, and return the result of the invocation; or return a
        // non-zero value if there is no such element.  'ACCESSOR' shall be a
        // functor providing a method that can be called as if it had the
        // following signature:
        //..
        // int operator()(const TYPE&, const bdeat_AttributeInfo&)
        //..
        // where 'TYPE' is the type of the element having 'attributeId'.  The
        // behavior is undefined unless this object represents a Sequence.

    template<typename ACCESSOR>
    int sequenceAccessAttributes(ACCESSOR& accessor) const;
        // Invoke the specified 'accessor' on each attribute of the sequence
        // represented by this object.  If any invocation returns a non-zero
        // value, return that value and stop invoking the accessor; otherwise
        // return 0 after the accessor has been invoked with a 0 result on all
        // attributes.  'ACCESSOR' shall be a functor providing a method that
        // can be called as if it had the following signature:
        //..
        // int operator()(const TYPE&, const bdeat_AttributeInfo&)
        //..
        // where 'TYPE' is the type of a particular element contained in the
        // sequence represented by this object.  The behavior is undefined
        // unless this object represents a sequence.

    template<typename ACCESSOR>
    int accessNullable(ACCESSOR& accessor) const;
        // Invoke the specified 'accessor' on the (non-null) value held in the
        // nullable object referred to through this proxy, and return the
        // result of that invocation.  'ACCESSOR' shall be a functor providing
        // a method that can be called as if it had the following signature:
        //..
        //  int operator()(const TYPE&, TYPE_CATEGORY)
        //..
        // where 'TYPE' is the type of value held in the nullable object this
        // object proxies, and 'TYPE_CATEGORY' is the 'bdeat_TypeCategory'
        // enumerator that describes 'TYPE'.  The behavior is undefined unless
        // this object represents a non-null Nullable value for encoding.

    template<typename ACCESSOR>
    int accessSimple(ACCESSOR& accessor) const;
        // Invoke the specified 'accessor' on the Simple value represented by
        // this object, and return the result of the invocation.  'ACCESSOR'
        // shall be a functor providing a method that can be called as if it
        // had the following signature:
        //..
        // int operator()(const TYPE&, bdeat_TypeCategory::Simple)
        //..
        // where 'TYPE' is the type of the element represented by this object.
        // The behavior in undefined unless this object represents a Simple
        // value.

    template<typename ACCESSOR>
    int arrayAccessElement(ACCESSOR& accessor, int index) const;
        // Invoke the specified 'accessor' on the element at the specified
        // 'index' in the vector represented by this SerializableObjectProxy,
        // and return the result of the invocation.  'ACCESSOR' shall be a
        // functor providing a method that can be called as if it had the
        // following signature:
        //..
        // int operator()(const TYPE&)
        //..
        // where 'TYPE' is the type held in the array represented by this
        // object.  The behavior is undefined unless this object represents a
        // vector for encoding, and that vector has at least 'index+1'
        // elements.

    int enumToInt() const;
        // Return the integer representation of the enumerated constant
        // represented by this object.  The behavior is undefined unless this
        // object represents an Enumerated value for encoding.

    const char* enumToString() const;
        // Return the string representation of the enumerated constant
        // represented by this object.  The behavior is undefined unless this
        // object represents an Enumerated value for encoding.
};

// ============================================================================
//                  INLINE AND TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

inline
SerializableObjectProxy::SerializableObjectProxy()
: d_objectInfo(d_objectInfoArena.object())
, d_object_p(0)
, d_category(bdeat_TypeCategory::BDEAT_DYNAMIC_CATEGORY) // 0 ("invalid")
{
}

inline
void SerializableObjectProxy::reset()
{
}

inline
int SerializableObjectProxy::maxSupportedBdexVersion() const
{ return -1; }

template <class STREAM>
inline
STREAM& SerializableObjectProxy::bdexStreamIn(STREAM& stream, int)
{
    stream.invalidate();
    return stream;
}

template <class STREAM>
inline
STREAM& SerializableObjectProxy::bdexStreamOut(STREAM& stream, int) const
{
    stream.invalidate();
    return stream;
}

template <typename ACCESSOR>
int SerializableObjectProxy::accessSimple(ACCESSOR& accessor) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SimplePointer>());

    const SimplePointer& simplePtr = d_objectInfo.the<SimplePointer>();

    switch (simplePtr.d_type) {
      case SimplePointer::TYPE_CHAR:
        return accessor(*(char*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_UCHAR:
        return accessor(*(unsigned char*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_SHORT:
        return accessor(*(short*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_INT:
        return accessor(*(int*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_INT64:
        return accessor(*(bsls_Types::Int64*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_USHORT:
        return accessor(*(unsigned short*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_UINT:
        return accessor(*(unsigned int*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_UINT64:
        return accessor(*(bsls_Types::Uint64*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_FLOAT:
        return accessor(*(float*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_DOUBLE:
        return accessor(*(double*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_STRING:
        return accessor(*(bsl::string*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_DATETIME:
        return accessor(*(bdet_Datetime*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_DATE:
        return accessor(*(bdet_Date*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_TIME:
        return accessor(*(bdet_Time*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_BOOL:
        return accessor(*(bool*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_DATETIMETZ:
        return accessor(*(bdet_DatetimeTz*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_DATETZ:
        return accessor(*(bdet_DateTz*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
      case SimplePointer::TYPE_TIMETZ:
        return accessor(*(bdet_TimeTz*)simplePtr.d_address,
                        bdeat_TypeCategory::Simple());                // RETURN
    }
    return -1;
}

template <typename MANIPULATOR>
int SerializableObjectProxy::manipulateSimple(MANIPULATOR& manipulator)
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SimplePointer>());

    const SimplePointer& simplePtr = d_objectInfo.the<SimplePointer>();

    switch (simplePtr.d_type) {
      case SimplePointer::TYPE_CHAR:
        return manipulator((char*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_UCHAR:
        return manipulator((unsigned char*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_SHORT:
        return manipulator((short*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_INT:
        return manipulator((int*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_INT64:
        return manipulator((bsls_Types::Int64*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_USHORT:
        return manipulator((unsigned short*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_UINT:
        return manipulator((unsigned int*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_UINT64:
        return manipulator((bsls_Types::Uint64*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_FLOAT:
        return manipulator((float*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_DOUBLE:
        return manipulator((double*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_STRING:
        return manipulator((bsl::string*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_DATETIME:
        return manipulator((bdet_Datetime*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_DATE:
        return manipulator((bdet_Date*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_TIME:
        return manipulator((bdet_Time*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_BOOL:
        return manipulator((bool*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_DATETIMETZ:
        return manipulator((bdet_DatetimeTz*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_DATETZ:
        return manipulator((bdet_DateTz*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
      case SimplePointer::TYPE_TIMETZ:
        return manipulator((bdet_TimeTz*)simplePtr.d_address,
                           bdeat_TypeCategory::Simple());             // RETURN
    }
    return -1;
}

template<typename ACCESSOR>
int SerializableObjectProxy::accessContainedElement(
                                       const SerializableObjectProxy& proxy,
                                       ACCESSOR&                      accessor)
{
    if (proxy.category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = {
            const_cast<SerializableObjectProxy*>(&proxy)
        };
        return accessor(adapter);                                     // RETURN
    }
    else {
        return accessor(proxy);                                       // RETURN
    }
}

template<typename MANIPULATOR>
int SerializableObjectProxy::manipulateContainedElement(
                                        SerializableObjectProxy  *proxy,
                                        MANIPULATOR&              manipulator)
{
    if (proxy->category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = { proxy };
        return manipulator(&adapter);                                 // RETURN
    }
    else {
        return manipulator(proxy);                                    // RETURN
    }
}

template<typename MANIPULATOR>
int SerializableObjectProxy::manipulateContainedElement(
                                        SerializableObjectProxy   *proxy,
                                        MANIPULATOR&               manipulator,
                                        const bdeat_SelectionInfo& info)
{
    if (proxy->category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = { proxy };
        return manipulator(&adapter, info);                           // RETURN
    }
    else {
        return manipulator(proxy, info);                              // RETURN
    }
}

template<typename MANIPULATOR>
int SerializableObjectProxy::manipulateContainedElement(
                                        SerializableObjectProxy   *proxy,
                                        MANIPULATOR&               manipulator,
                                        const bdeat_AttributeInfo& info)
{
    if (proxy->category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = { proxy };
        return manipulator(&adapter, info);                           // RETURN
    }
    else {
        return manipulator(proxy, info);                              // RETURN
    }
}

template<typename ACCESSOR>
int SerializableObjectProxy::accessContainedElement(
                                 const SerializableObjectProxy& proxy,
                                 ACCESSOR&                      accessor,
                                 const bdeat_SelectionInfo&     info) {
    if (proxy.category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = {
            const_cast<SerializableObjectProxy*>(&proxy)
        };
        return accessor(adapter, info);                               // RETURN
    }
    else {
        return accessor(proxy, info);                                 // RETURN
    }
}

template<typename ACCESSOR>
int SerializableObjectProxy::accessContainedElement(
                                    const SerializableObjectProxy& proxy,
                                    ACCESSOR&                      accessor,
                                    const bdeat_AttributeInfo&     info) {
    if (proxy.category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY) {
        SerializableObjectProxy_NullableAdapter adapter = {
            const_cast<SerializableObjectProxy*>(&proxy)
        };
        return accessor(adapter, info);                               // RETURN
    }
    else {
        return accessor(proxy, info);                                 // RETURN
    }
}

template<typename MANIPULATOR>
int SerializableObjectProxy::manipulateNullable(MANIPULATOR& manipulator)
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<NullableDecodeInfo>());

    const NullableDecodeInfo& info = d_objectInfo.the<NullableDecodeInfo>();

    SerializableObjectProxy proxy;
    info.d_accessor(&proxy, info.d_fetcher(d_object_p));

    return bdeat_TypeCategoryUtil::manipulateByCategory(&proxy,
                                                        manipulator);
}

template<typename ACCESSOR>
int SerializableObjectProxy::accessNullable(ACCESSOR& accessor) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<NullableEncodeInfo>());
    BSLS_ASSERT_SAFE(d_object_p);

    SerializableObjectProxy proxy;
    d_objectInfo.the<NullableEncodeInfo>()(&proxy,
                                           const_cast<void*>(d_object_p));

    return bdeat_TypeCategoryUtil::accessByCategory(proxy, accessor);
}

template<typename ACCESSOR>
int SerializableObjectProxy::choiceAccessSelection(ACCESSOR& accessor) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<ChoiceEncodeInfo>());

    SerializableObjectProxy selectionProxy;
    const ChoiceEncodeInfo& info = d_objectInfo.the<ChoiceEncodeInfo>();
    info.d_accessor(&selectionProxy, d_object_p);

    return accessContainedElement(selectionProxy,
                                  accessor,
                                  *info.d_selectionInfo_p);
}

template<typename MANIPULATOR>
int SerializableObjectProxy::choiceManipulateSelection(
                                                      MANIPULATOR& manipulator)
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<ChoiceDecodeInfo>());

    SerializableObjectProxy selectionProxy;
    const ChoiceDecodeInfo& info = d_objectInfo.the<ChoiceDecodeInfo>();
    const bdeat_SelectionInfo *selectionInfoPtr;

    d_objectInfo.the<ChoiceDecodeInfo>().d_accessor(&selectionProxy,
                                                    d_object_p,
                                                    &selectionInfoPtr);

    return manipulateContainedElement(&selectionProxy,
                                      manipulator,
                                      *selectionInfoPtr);
}

template<typename ACCESSOR>
int SerializableObjectProxy::sequenceAccessAttributes(ACCESSOR& accessor) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SequenceInfo>());

    SerializableObjectProxy elementProxy;
    const SequenceInfo& info = d_objectInfo.the<SequenceInfo>();

    for(int i = 0; i < info.d_numAttributes; ++i)
    {
        info.d_accessor(&elementProxy, *this, i);

        BSLS_ASSERT_SAFE(elementProxy.d_objectInfo.is<ChoiceEncodeInfo>() ||
                         elementProxy.d_objectInfo.is<SequenceInfo>() ||
                         elementProxy.d_objectInfo.is<ArrayEncodeInfo>() ||
                         elementProxy.d_objectInfo.is<EnumEncodeInfo>() ||
                         elementProxy.d_objectInfo.is<NullableEncodeInfo>() ||
                         elementProxy.d_objectInfo.is<SimplePointer>());

        int rc = accessContainedElement(elementProxy,
                                        accessor,
                                        info.d_attributeInfo_p[i]);
        if (0 != rc) {
            return rc;                                                // RETURN
        }
    }
    return 0;
}

template<typename MANIPULATOR>
int SerializableObjectProxy::sequenceManipulateAttribute(
                                             MANIPULATOR& manipulator,
                                             int          id)
{
    SerializableObjectProxy elementProxy;
    const bdeat_AttributeInfo *info;
    if (0 == loadSequenceElementDecodeProxy(&elementProxy, &info, id)) {

        BSLS_ASSERT_SAFE(elementProxy.d_objectInfo.is<ChoiceDecodeInfo>() ||
                         elementProxy.d_objectInfo.is<SequenceInfo>() ||
                         elementProxy.d_objectInfo.is<ArrayDecodeInfo>() ||
                         elementProxy.d_objectInfo.is<EnumDecodeInfo>() ||
                         elementProxy.d_objectInfo.is<NullableDecodeInfo>() ||
                         elementProxy.d_objectInfo.is<SimplePointer>());

        return manipulateContainedElement(&elementProxy, manipulator, *info);
                                                                      // RETURN
    }
    return -1;
}

template<typename MANIPULATOR>
int SerializableObjectProxy::sequenceManipulateAttribute(
                                             MANIPULATOR&  manipulator,
                                             const char   *attributeName,
                                             int           nameLength)
{
    SerializableObjectProxy elementProxy;
    const bdeat_AttributeInfo *info;
    if (0 == loadSequenceElementDecodeProxy(&elementProxy, &info,
                                 attributeName, nameLength))
    {
        BSLS_ASSERT_SAFE(elementProxy.d_objectInfo.is<ChoiceDecodeInfo>() ||
                         elementProxy.d_objectInfo.is<SequenceInfo>() ||
                         elementProxy.d_objectInfo.is<ArrayDecodeInfo>() ||
                         elementProxy.d_objectInfo.is<EnumDecodeInfo>() ||
                         elementProxy.d_objectInfo.is<NullableDecodeInfo>() ||
                         elementProxy.d_objectInfo.is<SimplePointer>());

        return manipulateContainedElement(&elementProxy, manipulator, *info);
                                                                      // RETURN
    }
    return -1;
}

template<typename ACCESSOR>
int SerializableObjectProxy::sequenceAccessAttribute(ACCESSOR& accessor,
                                                     int id) const
{
    BSLS_ASSERT_SAFE(d_objectInfo.is<SequenceInfo>());

    const SequenceInfo& info = d_objectInfo.the<SequenceInfo>();
    for(int i = 0; i < info.d_numAttributes; ++i)
    {
        if (info.d_attributeInfo_p[i].id() == id) {
            SerializableObjectProxy elementProxy;
            info.d_accessor(&elementProxy, *this, i);

            BSLS_ASSERT_SAFE(
                          elementProxy.d_objectInfo.is<ChoiceEncodeInfo>() ||
                          elementProxy.d_objectInfo.is<SequenceInfo>() ||
                          elementProxy.d_objectInfo.is<ArrayEncodeInfo>() ||
                          elementProxy.d_objectInfo.is<EnumEncodeInfo>() ||
                          elementProxy.d_objectInfo.is<NullableEncodeInfo>() ||
                          elementProxy.d_objectInfo.is<SimplePointer>());

            return accessContainedElement(elementProxy,
                                          accessor,
                                          info.d_attributeInfo_p[i]); // RETURN
        }
    }
    return -1;
}

template<typename ACCESSOR>
int SerializableObjectProxy::arrayAccessElement(ACCESSOR& accessor,
                                                int index) const
{
    SerializableObjectProxy elementProxy;
    loadArrayElementEncodeProxy(&elementProxy, index);

    return accessContainedElement(elementProxy,
                                  accessor);
}

template<typename MANIPULATOR>
int SerializableObjectProxy::arrayManipulateElement(MANIPULATOR& manipulator,
                                                    int index)
{
    SerializableObjectProxy elementProxy;
    loadArrayElementDecodeProxy(&elementProxy, index);

    return manipulateContainedElement(&elementProxy, manipulator);
}

inline
bdeat_TypeCategory::Value SerializableObjectProxy::category() const
{
    return d_category;
}

inline
const void *SerializableObjectProxy::object() const
{
    return d_object_p;
}

inline
bool SerializableObjectProxy::isByteArrayValue() const
{
    return d_objectInfo.is<ArrayEncodeInfo>() &&
        d_objectInfo.the<ArrayEncodeInfo>().d_accessor == 0;
}


}  // close namespace baea

// ============================================================================
//                            Basic Type Traits
// ============================================================================

template<>
struct bslalg_TypeTraits<baea::SerializableObjectProxy> :
    bdeat_TypeTraitBasicChoice,
    bdeat_TypeTraitBasicSequence,
    bdeat_TypeTraitBasicEnumeration
{};

// ============================================================================
//                     'bdeat_typecategory' overloads
// ============================================================================

template<>
struct bdeat_TypeCategoryDeclareDynamic<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

namespace bdeat_TypeCategoryFunctions {

inline
bdeat_TypeCategory::Value bdeat_typeCategorySelect(
                                   const baea::SerializableObjectProxy& object)
{
    return object.category();
}

}  // close namespace bdeat_TypeCategoryFunctions

template <typename ACCESSOR>
inline
int bdeat_typeCategoryAccessSimple(
                                 const baea::SerializableObjectProxy& object,
                                 ACCESSOR&                            accessor)
{
    return object.accessSimple(accessor);
}

template <typename MANIPULATOR>
inline
int bdeat_typeCategoryManipulateSimple(
                               baea::SerializableObjectProxy *object,
                               MANIPULATOR&                     manipulator)
{
    return object->manipulateSimple(manipulator);
}

template <typename MANIPULATOR>
int bdeat_typeCategoryManipulateArray(
                                  baea::SerializableObjectProxy *object,
                                  MANIPULATOR&                     manipulator)
{
    if (object->isByteArrayValue()) {
        bsl::vector<char>* arrayPtr =
            (bsl::vector<char>*)object->object();
        return manipulator(arrayPtr, bdeat_TypeCategory::Array());    // RETURN
    }
    else {
        return manipulator(object, bdeat_TypeCategory::Array());      // RETURN
    }
}

template <typename ACCESSOR>
int bdeat_typeCategoryAccessArray(
                               const baea::SerializableObjectProxy& object,
                               ACCESSOR&                              accessor)
{
    if (object.isByteArrayValue()) {
        const bsl::vector<char>* arrayPtr =
            (const bsl::vector<char>*)object.object();
        return accessor(*arrayPtr, bdeat_TypeCategory::Array());      // RETURN
    }
    else {
        return accessor(object, bdeat_TypeCategory::Array());         // RETURN
    }
}

template <typename ACCESSOR>
int bdeat_typeCategoryAccessNullableValue(
                               const baea::SerializableObjectProxy& object,
                               ACCESSOR&                              accessor)
{
    if (object.category() == bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY
        && !object.isNull())
    {
        return object.accessNullable(accessor);                       // RETURN
    }
    return -1;
}

template <typename MANIPULATOR>
int bdeat_typeCategoryManipulateNullableValue(
                                  baea::SerializableObjectProxy* object,
                                  MANIPULATOR&                     manipulator)
{
    if (object->category() ==
        bdeat_TypeCategory::BDEAT_NULLABLE_VALUE_CATEGORY)
    {
        BSLS_ASSERT_SAFE(!object->isNull()); // the default imp.  does this too
        return object->manipulateNullable(manipulator);               // RETURN
    }
    return -1;
}


// ============================================================================
//           'bdeat_enumfunctions' overloads and specializations
// ============================================================================
namespace bdeat_EnumFunctions {

// META-FUNCTIONS
bslmf_MetaInt<1> isEnumerationMetaFunction(
                                      const baea::SerializableObjectProxy&);
    // This function can be overloaded to support partial specialization
    // (Sun5.2 compiler is unable to partially specialize the 'struct'
    // below).  Note that this function is has no definition and should not
    // be called at runtime.

template <>
struct IsEnumeration<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

inline
void bdeat_enumToInt(int *result, const baea::SerializableObjectProxy& object)
{
    *result = object.enumToInt();
}

inline
int bdeat_enumFromInt(baea::SerializableObjectProxy* result,
                      int value)
{
    return result->enumFromInt(value);
}


inline
void bdeat_enumToString(bsl::string *result,
                        const baea::SerializableObjectProxy& object)
{
    *result = object.enumToString();
}

inline
int bdeat_enumFromString(baea::SerializableObjectProxy* result,
                         const char *stringValue,
                         int         stringLength)
{
    return result->enumFromString(stringValue, stringLength);
}

}  // close namespace bdeat_EnumFunctions

// ============================================================================
//           'bdeat_arrayfunctions' overloads and specializations
// ============================================================================

namespace bdeat_ArrayFunctions {

bslmf_MetaInt<1> isArrayMetaFunction(const baea::SerializableObjectProxy&);

template <>
struct IsArray<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

template <>
struct ElementType<baea::SerializableObjectProxy> {
    typedef baea::SerializableObjectProxy Type;
};

inline
bsl::size_t bdeat_arraySize(const baea::SerializableObjectProxy& object)
{
    return object.size();
}

inline
void bdeat_arrayResize(baea::SerializableObjectProxy* object, int newSize)
{
    object->resize(newSize);
}

template <typename ACCESSOR>
inline
int bdeat_arrayAccessElement(const baea::SerializableObjectProxy& object,
                             ACCESSOR& accessor,
                             int index)
{
    return object.arrayAccessElement(accessor, index);
}

template <typename MANIPULATOR>
inline
int bdeat_arrayManipulateElement(baea::SerializableObjectProxy* object,
                                 MANIPULATOR& accessor,
                                 int index)
{
    return object->arrayManipulateElement(accessor, index);
}

}  // close namespace bdeat_ArrayFunctions

// ============================================================================
//           'bdeat_sequencefunctions' overloads and specializations
// ============================================================================

namespace bdeat_SequenceFunctions {

bslmf_MetaInt<1> isSequenceMetaFunction(const baea::SerializableObjectProxy&);

template <>
struct IsSequence<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

template <typename ACCESSOR>
inline
int bdeat_sequenceAccessAttributes(
                               const baea::SerializableObjectProxy& object,
                               ACCESSOR&                              accessor)
{
    return object.sequenceAccessAttributes(accessor);
}

template <typename ACCESSOR>
inline
int bdeat_sequenceAccessAttribute(const baea::SerializableObjectProxy& object,
                                  ACCESSOR&             accessor,
                                  int                   attributeId)
{
    return object.sequenceAccessAttribute(accessor, attributeId);
}

template <typename MANIPULATOR>
inline
int bdeat_sequenceManipulateAttribute(baea::SerializableObjectProxy *object,
                                      MANIPULATOR& manipulator,
                                      int          attributeId)
{
    return object->sequenceManipulateAttribute(manipulator, attributeId);
}

template <typename MANIPULATOR>
inline
int bdeat_sequenceManipulateAttribute(baea::SerializableObjectProxy *object,
                                      MANIPULATOR& manipulator,
                                      const char*  attributeName,
                                      int          nameLength)
{
    return object->sequenceManipulateAttribute(manipulator, attributeName,
                                               nameLength);
}

inline
bool bdeat_sequenceHasAttribute(const baea::SerializableObjectProxy&  object,
                                int                         attributeId)
{
    return object.sequenceHasAttribute(attributeId);
}

inline
bool bdeat_sequenceHasAttribute(const baea::SerializableObjectProxy&  object,
                                const char                 *attributeName,
                                int                         nameLength)
{
    return object.sequenceHasAttribute(attributeName, nameLength);
}

}  // close namespace bdeat_SequenceFunctions

// ============================================================================
//           'bdeat_nullablevaluefunctions' overloads and specializations
// ============================================================================
namespace bdeat_NullableValueFunctions {

bslmf_MetaInt<1> isNullableValueMetaFunction(
                       const baea::SerializableObjectProxy_NullableAdapter&);

template <>
struct IsNullableValue<baea::SerializableObjectProxy_NullableAdapter> {
    enum { VALUE = 1 };
};

template <>
struct ValueType<baea::SerializableObjectProxy_NullableAdapter> {
    typedef baea::SerializableObjectProxy Type;
};

inline
bool bdeat_nullableValueIsNull(
                 const baea::SerializableObjectProxy_NullableAdapter& object)
{
    return object.d_proxy_p->isNull();
}

inline
void bdeat_nullableValueMakeValue(
                      baea::SerializableObjectProxy_NullableAdapter *object)
{
    object->d_proxy_p->makeValue();
}

}  // close namespace bdeat_NullableValueFunctions

template <typename MANIPULATOR>
inline
int bdeat_nullableValueManipulateValue(
                    baea::SerializableObjectProxy_NullableAdapter *object,
                    MANIPULATOR&                                   manipulator)
{
    return manipulator(object->d_proxy_p);
}

template <typename ACCESSOR>
inline
int bdeat_nullableValueAccessValue(
               const baea::SerializableObjectProxy_NullableAdapter& object,
               ACCESSOR&                                              accessor)
{
    return accessor(*object.d_proxy_p);
}

// ============================================================================
//                       'bdeat_typename' overloads
// ============================================================================
namespace bdeat_TypeName_Overloadable {

inline
const char *bdeat_TypeName_className(
                                 const baea::SerializableObjectProxy& object)
     // Return the type name of the type represented by the specified
     // 'object', or 0 if there is no such name.
{
    return object.className();
}

}  // close namespace bdeat_TypeName_Overloadable

// ============================================================================
//           'bdeat_choicefunctions' overloads and specializations
// ============================================================================

namespace bdeat_ChoiceFunctions {
bslmf_MetaInt<1> isChoiceMetaFunction(const baea::SerializableObjectProxy&);

template <>
struct IsChoice<baea::SerializableObjectProxy> {
    enum { VALUE = 1 };
};

inline
int bdeat_choiceSelectionId(const baea::SerializableObjectProxy& object)
{
    return object.selectionId();
}

template <typename ACCESSOR>
inline
int bdeat_choiceAccessSelection(const baea::SerializableObjectProxy& object,
                                ACCESSOR&             accessor)
{
    return object.choiceAccessSelection(accessor);
}

inline
bool bdeat_choiceHasSelection(const baea::SerializableObjectProxy&  object,
                              const char                 *selectionName,
                              int                         selectionNameLength)
{
    return object.choiceHasSelection(selectionName, selectionNameLength);
}

inline
bool bdeat_choiceHasSelection(const baea::SerializableObjectProxy&  object,
                              int                         selectionId)
{
    return object.choiceHasSelection(selectionId);
}

inline
int bdeat_choiceMakeSelection(baea::SerializableObjectProxy*  object,
                              int                   selectionId)
{
    return object->choiceMakeSelection(selectionId);
}

inline
int bdeat_choiceMakeSelection(baea::SerializableObjectProxy  *object,
                              const char           *selectionName,
                              int                   selectionNameLength)
{
    return object->choiceMakeSelection(selectionName, selectionNameLength);
}

template <typename MANIPULATOR>
inline
int bdeat_choiceManipulateSelection(baea::SerializableObjectProxy* object,
                                    MANIPULATOR&         manipulator)
{
    return object->choiceManipulateSelection(manipulator);
}

}  // close namespace bdeat_ChoiceFunctions
}  // close namespace BloombergLP

#endif


// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2011
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ------------------------------ END-OF-FILE ---------------------------------
