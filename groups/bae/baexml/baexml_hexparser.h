// baexml_hexparser.h                  -*-C++-*-
#ifndef INCLUDED_BAEXML_HEXPARSER
#define INCLUDED_BAEXML_HEXPARSER

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide push parser for hex types.
//
//@DEPRECATED: This functionality will be moved to bdede w/ a new interface.
//
//@CLASSES: baexml_HexParser: push parser for hex types.
//
//@SEE_ALSO:
//
//@AUTHOR: Shezan Baig (sbaig)
//
//@CONTACT: Rohan Bhindwale (rbhindwa)
//
//@DESCRIPTION: The 'baexml_HexParser<TYPE>' class template provided by this
// component can be used to parse Hex characters into one of the supported Hex
// types, which are 'bsl::vector<char>' and 'bsl::string'.  The 'TYPE'
// parameter can be one of these two types.
//
// This class template is a model of the 'PushParser' concept, which contains
// the following methods:
//..
//  int beginParse(TYPE *object);
//      // Prepare the parser to start parsing a new value and associate the
//      // specified 'object' with the parser.  Return 0 if successful and
//      // non-zero otherwise.
//
//  int endParse();
//      // Ends the parse operation and store the value parsed from the pushed
//      // characters into the associated object.  Return 0 if successful and
//      // non-zero otherwise.  The behavior is undefined unless an object is
//      // associated with this parser.  Upon successful completion, the parser
//      // will be disassociated with the object.
//
//  template <typename INPUT_ITERATOR>
//  int pushCharacters(INPUT_ITERATOR begin, INPUT_ITERATOR end);
//      // Push the characters ranging from the specified 'begin' up to (but
//      // not including) the specified 'end' into this parser.  Return 0 if
//      // successful and non-zero otherwise.  The parameterized
//      // 'INPUT_ITERATOR' must be dereferenceable to a 'char' value.  The
//      // behavior is undefined unless an object is associated with this
//      // parser.
//..
//
///Usage
///-----
// The following snippets of code illustrate the usage of this component.
// Suppose you had an input stream that contained Hex data.  The following
// 'loadFromHexStream' function loads this data into an 'bsl::vector<char>'
// blob:
//..
//  #include <baexml_hexparser.h>
//
//  #include <istream>
//  #include <iterator>
//  #include <vector>
//
//  using namespace BloombergLP;
//
//  int loadFromHexStream(bsl::vector<char> *result, bsl::istream& stream)
//  {
//      enum { BAEXML_FAILURE = -1 };
//
//      baexml_HexParser<bsl::vector<char> > parser;
//
//      if (0 != parser.beginParse(result)) {
//          return BAEXML_FAILURE;
//      }
//
//      if (0 != parser.pushCharacters(bsl::istreambuf_iterator<char>(stream),
//                                     bsl::istreambuf_iterator<char>())) {
//          return BAEXML_FAILURE;
//      }
//
//      return parser.endParse();
//  }
//..
// The following function demonstrates the 'loadFromHexStream' function:
//..
//  #include <sstream>
//
//  void usageExample()
//  {
//      const char INPUT[] = "0F3B296A";
//
//      bsl::vector<char>  vec;
//      bsl::istringstream iss(INPUT);
//
//      int result = loadFromHexStream(&vec, iss);
//
//      assert(0    == result);
//      assert(4    == vec.size());
//      assert(0x0F == vec[0]);
//      assert(0x3B == vec[1]);
//      assert(0x29 == vec[2]);
//      assert(0x6A == vec[3]);
//  }
//..

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BDEAT_VALUETYPEFUNCTIONS
#include <bdeat_valuetypefunctions.h>
#endif

#ifndef INCLUDED_BDEU_CHARTYPE
#include <bdeu_chartype.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

namespace BloombergLP {

                           // ============================
                           // class baexml_HexParser<TYPE>
                           // ============================

template <typename TYPE>
class baexml_HexParser {
    // This is a push parser for supported Hex types ('bsl::vector<char>'
    // or 'bsl::string').

    // PRIVATE DATA MEMBERS
    char  d_firstDigit;  // buffer for first digit
    TYPE *d_object_p;    // associated object

  private:
    // NOT IMPLEMENTED
    baexml_HexParser(const baexml_HexParser&);
    baexml_HexParser& operator=(const baexml_HexParser&);

    // PRIVATE MANIPULATORS
    void appendOctet(char firstDigit, char secondDigit);
        // Append an octet generated from the specified 'firstDigit' and the
        // specified 'secondDigit' to the associated object.

  public:
    // CREATORS
    baexml_HexParser();
        // Create a parser for parsing Hex types.

    // Generated by compiler:
    // ~baexml_HexParser();

    // MANIPULATORS
    int beginParse(TYPE *object);
        // Prepare the parser to start parsing a new value and associate the
        // specified 'object' with the parser.  Return 0 if successful and
        // non-zero otherwise.

    int endParse();
        // Ends the parse operation and store the value parsed from the pushed
        // characters into the associated object.  Return 0 if successful and
        // non-zero otherwise.  The behavior is undefined unless an object is
        // associated with this parser.  Upon successful completion, the parser
        // will be disassociated with the object.

    template <typename INPUT_ITERATOR>
    int pushCharacters(INPUT_ITERATOR begin, INPUT_ITERATOR end);
        // Push the characters ranging from the specified 'begin' up to (but
        // not including) the specified 'end' into this parser.  Return 0 if
        // successful and non-zero otherwise.  The parameterized
        // 'INPUT_ITERATOR' must be dereferenceable to a 'char' value.  The
        // behavior is undefined unless an object is associated with this
        // parser.
};

                       // ==============================
                       // struct baexml_HexParser_Helper
                       // ==============================

class baexml_HexParser_Helper {
    // Namespace for facilities that are used in the implementation of
    // class 'baexml_HexParser<TYPE>'.  Only instances of
    // 'baexml_HexParser<TYPE>' can access the facilities in this class.

    template <typename TYPE> friend class baexml_HexParser;

    static const char s_hexValueTable[128];
        // Table that maps from ASCII character value to hex value.
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                           // ----------------------------
                           // class baexml_HexParser<TYPE>
                           // ----------------------------

// PRIVATE MANIPULATORS
template <typename TYPE>
void baexml_HexParser<TYPE>::appendOctet(char firstDigit, char secondDigit)
{
    BSLS_ASSERT_SAFE(bdeu_CharType::isXdigit((unsigned char) firstDigit));
    BSLS_ASSERT_SAFE(bdeu_CharType::isXdigit((unsigned char) secondDigit));

    char value =
        (char)((baexml_HexParser_Helper::s_hexValueTable[(int)firstDigit] << 4)
             | (baexml_HexParser_Helper::s_hexValueTable[(int)secondDigit]));

    d_object_p->push_back(value);
}

// CREATORS
template <typename TYPE>
baexml_HexParser<TYPE>::baexml_HexParser()
: d_firstDigit(0)
, d_object_p(0)
{
}

// MANIPULATORS
template <typename TYPE>
int baexml_HexParser<TYPE>::beginParse(TYPE *object)
{
    BSLS_ASSERT_SAFE(object);

    enum { BAEXML_SUCCESS = 0 };

    d_firstDigit = 0;
    d_object_p   = object;

    bdeat_ValueTypeFunctions::reset(d_object_p);

    return BAEXML_SUCCESS;
}

template <typename TYPE>
int baexml_HexParser<TYPE>::endParse()
{
    BSLS_ASSERT_SAFE(d_object_p);

    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    d_object_p = 0;

    return 0 == d_firstDigit ? BAEXML_SUCCESS : BAEXML_FAILURE;
}

template <typename TYPE>
template <typename INPUT_ITERATOR>
int baexml_HexParser<TYPE>::pushCharacters(INPUT_ITERATOR begin,
                                           INPUT_ITERATOR end)
{
    BSLS_ASSERT_SAFE(d_object_p);

    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    while (begin != end) {
        const char digit = *begin;

        ++begin;

        if (!bdeu_CharType::isSpace(digit)) {
            if (!bdeu_CharType::isXdigit(digit)) {
                return BAEXML_FAILURE;
            }

            if (0 == d_firstDigit) {
                d_firstDigit = digit;
            }
            else {
                appendOctet(d_firstDigit, digit);

                d_firstDigit = 0;
            }
        }
    }

    return BAEXML_SUCCESS;
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2005
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
