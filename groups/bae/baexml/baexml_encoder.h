// baexml_encoder.h         -*-C++-*-
#ifndef INCLUDED_BAEXML_ENCODER
#define INCLUDED_BAEXML_ENCODER

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide an XML encoder utility.
//
//@CLASSES:
//  baexml_Encoder: XML encoder utility class
//
//@AUTHOR: Shezan Baig (sbaig)
//
//@CONTACT: Rohan Bhindwale (rbhindwa)
//
//@SEE_ALSO: baexml_decoder, bdem_berencoder
//
//@DESCRIPTION: This component provides a class for encoding value-semantic
// objects in XML format.  In particular, the 'baexml_Encoder' 'class'
// contains a parameterized 'encode' function that encodes a specified
// value-semantic object into a specified stream.  There are three overloaded
// versions of this function:
//..
//    o writes to an 'bsl::streambuf'
//    o writes to an 'bsl::ostream'
//    o writes to an 'baexml_Formatter'
//..
// The 'encode' function encodes objects in XML format, which is a very useful
// format for debugging.  For more efficient performance, a binary encoding
// (such as BER) should be used.
//
// This component can be used with types supported by the 'bdeat' framework.
// In particular, types generated by the 'bas_codegen.pl' tool can be used.
//
///Usage
///-----
// The following snippets of code illustrate the usage of this component.
// Suppose we have an XML schema inside a file called 'employee.xsd':
//..
//  <?xml version='1.0' encoding='UTF-8'?>
//  <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
//             xmlns:test='http://bloomberg.com/schemas/test'
//             targetNamespace='http://bloomberg.com/schemas/test'
//             elementFormDefault='unqualified'>
//
//      <xs:complexType name='Address'>
//          <xs:sequence>
//              <xs:element name='street' type='xs:string'/>
//              <xs:element name='city'   type='xs:string'/>
//              <xs:element name='state'  type='xs:string'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:complexType name='Employee'>
//          <xs:sequence>
//              <xs:element name='name'        type='xs:string'/>
//              <xs:element name='homeAddress' type='test:Address'/>
//              <xs:element name='age'         type='xs:int'/>
//          </xs:sequence>
//      </xs:complexType>
//
//  </xs:schema>
//..
// Using the 'bas_codegen.pl' tool, we generate C++ classes for this schema as
// follows:
//..
//  $ bas_codegen.pl -m msg -p test -E employee.xsd
//..
// This tool will generate the header and implementation files for the
// 'test_address' and 'test_employee' components in the current directory.
//
// Now suppose we wanted to encode information about a particular employee
// using XML encoding to the standard output, using the 'PRETTY' option for
// formatting the output.  The following function will do this:
//..
//  #include <test_employee.h>
//
//  #include <baexml_encoder.h>
//  #include <baexml_encodingstyle.h>
//
//  #include <iostream>
//
//  using namespace BloombergLP;
//
//  void usageExample()
//  {
//      test::Employee bob;
//
//      bob.name()                 = "Bob";
//      bob.homeAddress().street() = "Some Street";
//      bob.homeAddress().city()   = "Some City";
//      bob.homeAddress().state()  = "Some State";
//      bob.age()                  = 21;
//
//      baexml_EncoderOptions options;
//      options.setEncodingStyle(baexml_EncodingStyle::BAEXML_PRETTY);
//
//      baexml_Encoder encoder(&options, &bsl::err, &bsl::err);
//      int rc = encoder.encodeToStream(ss, bob);
//
//      ASSERT(0 == rc);
//  }
//..
// When this function is invoked, the following text will be printed to the
// standard output:
//..
//  <?xml version="1.0" encoding="UTF-8" ?>
//  <Employee>
//      <name>Bob</name>
//      <homeAddress>
//          <street>Some Street</street>
//          <city>Some City</city>
//          <state>Some State</state>
//      </homeAddress>
//      <age>21</age>
//  </Employee>
//..

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BAEXML_ENCODEROPTIONS
#include <baexml_encoderoptions.h>
#endif

#ifndef INCLUDED_BAEXML_ENCODINGSTYLE
#include <baexml_encodingstyle.h>
#endif

#ifndef INCLUDED_BAEXML_ERRORINFO
#include <baexml_errorinfo.h>      // for Severity
#endif

#ifndef INCLUDED_BAEXML_FORMATTER
#include <baexml_formatter.h>
#endif

#ifndef INCLUDED_BAEXML_TYPESPRINTUTIL
#include <baexml_typesprintutil.h>
#endif

#ifndef INCLUDED_BDEAT_ARRAYFUNCTIONS
#include <bdeat_arrayfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CHOICEFUNCTIONS
#include <bdeat_choicefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_NULLABLEVALUEFUNCTIONS
#include <bdeat_nullablevaluefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_SEQUENCEFUNCTIONS
#include <bdeat_sequencefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_TYPECATEGORY
#include <bdeat_typecategory.h>
#endif

#ifndef INCLUDED_BDEAT_TYPENAME
#include <bdeat_typename.h>
#endif

#ifndef INCLUDED_BDESB_MEMOUTSTREAMBUF
#include <bdesb_memoutstreambuf.h>
#endif

#ifndef INCLUDED_BDEUT_STRINGREF
#include <bdeut_stringref.h>
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include <bslma_allocator.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include <bsls_objectbuffer.h>
#endif

#ifndef INCLUDED_BSL_OSTREAM
#include <bsl_ostream.h>
#endif

#ifndef INCLUDED_BSL_STRING
#include <bsl_string.h>
#endif

#ifndef INCLUDED_BSL_VECTOR
#include <bsl_vector.h>
#endif

namespace BloombergLP {

class baexml_Encoder_Context;

                             // ====================
                             // class baexml_Encoder
                             // ====================

class baexml_Encoder {
    // This 'class' contains the parameterized 'encode' functions that encode
    // 'bdeat' types in XML format.

    // FRIENDS
    friend class baexml_Encoder_Context;

  private:
    // PRIVATE TYPES
    class MemOutStream : public bsl::ostream
    {
        // This class provides stream for logging using 'bdesb_MemOutStreamBuf'
        // as a streambuf.  The logging stream is created on demand, i.e.,
        // during the first attempt to log message.
        bdesb_MemOutStreamBuf d_sb;

        // Not implemented:
        MemOutStream(const MemOutStream&);
        MemOutStream& operator=(const MemOutStream&);

      public:
        // CREATORS
        MemOutStream(bslma_Allocator *basicAllocator = 0);
            // Create a new stream using the specified 'basicAllocator'.

        virtual ~MemOutStream();
            // Destroy this stream and release memory back to the allocator.
            //
            // Although the compiler should generate this destructor
            // implicitly, xlC 8 breaks when the destructor is called by name
            // unless it is explicitly declared.

        // MANIPULATORS
        void reset();
            // Reset the internal streambuf to empty.

        // ACCESSORS
        const char *data() const;
            // Return a pointer to the memory containing the formatted values
            // formatted to this stream.  The data is not null-terminated
            // unless a null character was appended onto this stream.

        int length() const;
            // Return the length of of the formatted data, including null
            // characters appended to the stream, if any.
    };

  private:
    // DATA
    const baexml_EncoderOptions     *d_options;        // held, not owned
    bslma_Allocator                 *d_allocator;      // held, not owned

    bsls_ObjectBuffer<MemOutStream>  d_logArea;
        // placeholder for MemOutStream

    MemOutStream                    *d_logStream;
        // if not zero, log stream was created at the moment of first
        // logging and must be destroyed

    baexml_ErrorInfo::Severity       d_severity;       // error severity

    bsl::ostream                    *d_errorStream;    // held, not owned
    bsl::ostream                    *d_warningStream;  // held, not owned

    // PRIVATE MANIPULATORS
    baexml_ErrorInfo::Severity  logError(
                   const char             *text,
                   const bdeut_StringRef&  tag,
                   int                     formattingMode,
                   int                     index = -1);

    bsl::ostream& logStream();
        // Return the stream for logging.  Note the if stream has not
        // been created yet, it will be created during this call.

  public:
    // CREATORS
    baexml_Encoder(const baexml_EncoderOptions *options,
                   bslma_Allocator             *basicAllocator);

    baexml_Encoder(const baexml_EncoderOptions *options,
                   bsl::ostream                *errorStream   = 0,
                   bsl::ostream                *warningStream = 0,
                   bslma_Allocator             *basicAllocator = 0);
        // Construct a encoder object using the specified 'options'.  Errors
        // and warnings will be rendered to the optionally specified
        // 'errorStream' and 'warningStream' respectively.

    ~baexml_Encoder();
        // Destroy this object.  This destruction has no effect on objects
        // pointed-to by the pointers provided at construction.

    template <typename TYPE>
    int encode(bsl::streambuf *buffer, const TYPE& object);
        // Encode the specified non-modifiable 'object' to the specified
        // 'buffer'.  Return 0 on success, and a non-zero value otherwise.
        // Note that the encoder will use encoder options, error and warning
        // streams specified at the construction time.

    template <typename TYPE>
    int encodeToStream(bsl::ostream& stream, const TYPE& object);
        // Encode the specified non-modifiable 'object' to the specified
        // 'stream'.  Return 0 on success, and a non-zero value otherwise.
        // Note that the encoder will use encoder options, error and warning
        // streams specified at the construction time.

    template <typename TYPE>
    bsl::ostream& encode(bsl::ostream& stream, const TYPE& object);
        // Encode the specified non-modifiable 'object' to the specified
        // 'stream'.  Return a reference to 'stream'.  If an encoding error is
        // detected, 'stream.fail()' will be true on return.  Note that the
        // encoder will use encoder options, error and warning streams
        // specified at the construction time.  IMPORTANT: The use of
        // 'stream.fail()' to communicate errors to the caller has two
        // consequences: 1) if 'stream' is the same as the 'errorStream'
        // passed to the constructor, then the error message may be suppressed
        // (because of the output/error stream becoming invalidated) and 2) it
        // is important to call 'stream.clear()' after testing the stream
        // state.  To avoid these issues, we recommend that you use use
        // 'encodeToStream', above, instead of this version of 'encode'.

    template <typename TYPE>
    int encode(baexml_Formatter& formatter, const TYPE& object);
        // Encode the specified non-modifiable 'object' to the specified
        // 'formatter'.  Return 0 on success, and a non-zero value otherwise.
        // Note that encoder will use encoder options, error and warning
        // streams specified at the construction time.

    //ACCESSORS
    const baexml_EncoderOptions *options() const;
        // Return the encoder options.

    bool isCompact() const;
        // Return 'true' if the encoding style in the encoder options is
        // defined as 'baexml_EncodingStyle::BAEXML_COMPACT', and 'false'
        // otherwise.

    bsl::ostream *errorStream() const;
        // Return pointer to the error stream.

    bsl::ostream *warningStream() const;
        // Return pointer to the warning stream.

    baexml_ErrorInfo::Severity  errorSeverity() const;
        // Return the severity of the most severe warning or error encountered
        // during the last call to the 'encode' method.  The severity is reset
        // each time 'encode' is called.

    bdeut_StringRef loggedMessages() const;
        // Return a string containing any error, warning, or trace messages
        // that were logged during the last call to the 'encode' method.  The
        // log is reset each time 'encode' is called.
};

// ---- Anything below this line is implementation specific.  Do not use.  ----

                         // =============================
                         // struct baexml_Encoder_Context
                         // =============================

class baexml_Encoder_Context {
    // This 'struct' contains state that is maintained during encoding.  It
    // also contains methods for switching between pretty formatting and
    // compact formatting, based on the encoding options.

    baexml_Formatter  *d_formatter;
    baexml_Encoder    *d_encoder;

    // NOT IMPLEMENTED
    baexml_Encoder_Context(const baexml_Encoder_Context& other);
    baexml_Encoder_Context& operator=(const baexml_Encoder_Context& other);

  public:
    // CREATORS
    baexml_Encoder_Context(baexml_Formatter *formatter,
                           baexml_Encoder   *encoder);

    // ACCESSORS
    int status() const
    {
        return d_formatter->status();
    }

    const baexml_EncoderOptions& encoderOptions() const
    {
        return *d_encoder->options();
    }

    // MANIPULATORS
    bsl::ostream& rawOutputStream()
    {
        return d_formatter->rawOutputStream();
    }

    void invalidate()
    {
        rawOutputStream().setstate(bsl::ios_base::failbit);
    }

    baexml_ErrorInfo::Severity  logError(
                   const char             *text,
                   const bdeut_StringRef&  tag,
                   int                     formattingMode,
                   int                     index = -1)
    {
        return d_encoder->logError(text, tag, formattingMode, index);
    }

    template <typename TYPE>
    static void encode(const TYPE& object);

    // HELPER FUNCTIONS
    template<typename NAME_TYPE, typename VALUE_TYPE>
    void addAttribute(const NAME_TYPE&  name,
                      const VALUE_TYPE& value,
                      int               formattingMode)
    {
        d_formatter->addAttribute(name, value, formattingMode);
    }

    template<typename NAME_TYPE, typename VALUE_TYPE>
    void addAttribute(const NAME_TYPE&  name,
                      const VALUE_TYPE& value)
    {
        d_formatter->addAttribute(name,
                                  value,
                                  bdeat_FormattingMode::BDEAT_DEFAULT);
    }

    template <typename NAME_TYPE>
    void openElement(const NAME_TYPE& name)
    {
        d_formatter->openElement(name);
    }

    template <typename NAME_TYPE>
    void closeElement(const NAME_TYPE& name)
    {
        d_formatter->closeElement(name);
    }

};

                       // =================================
                       // class baexml_Encoder_EncodeObject
                       // =================================

class baexml_Encoder_EncodeObject {
    // Component-private class.  Do not use.
    // This struct encodes an object *with* enclosing tags.  Compared to the
    // 'EncoderUtil_EncodeValue' class below, this class prefixes the value
    // with an opening tag, and suffixes the value with a closing tag.  In
    // pseudocode, this is equivalent to:
    //..
    //  openTag()
    //  baexml_Encoder_EncodeValue()
    //  closeTag()
    //..
    // There is an overloaded version of 'bsl::vector<char>' because, based on
    // the formatting mode, this class needs to switch between encoding the
    // value in a single tag (i.e., when using BASE64, TEXT, IS_LIST or HEX)
    // and encoding the value in multiple tags (i.e., when repetition is used).

    // PRIVATE TYPES
    struct CanBeListOrRepetition { };
    struct CanBeRepetitionOnly   { };

    // PRIVATE DATA MEMBERS
    baexml_Encoder_Context *d_context_p;

  public:
    // IMPLEMENTATION MANIPULATORS
    template <typename TYPE>
    int executeImp(const TYPE&            object,
                   const bdeut_StringRef& tag,
                   int                    formattingMode,
                   bdeat_TypeCategory::Array);

    template <typename TYPE>
    int executeImp(const TYPE&            object,
                   const bdeut_StringRef& tag,
                   int                    formattingMode,
                   bdeat_TypeCategory::NullableValue);

    template <typename TYPE>
    int executeImp(const TYPE&            object,
                   const bdeut_StringRef& tag,
                   int                    formattingMode,
                   bdeat_TypeCategory::DynamicType);

    template <typename TYPE, typename ANY_CATEGORY>
    int executeImp(const TYPE&            object,
                   const bdeut_StringRef& tag,
                   int                    formattingMode,
                   ANY_CATEGORY);

    int executeImp(const bsl::vector<char>&  object,
                   const bdeut_StringRef&    tag,
                   int                       formattingMode,
                   bdeat_TypeCategory::Array);

    template <typename TYPE>
    int executeArrayListImp(const TYPE&            object,
                            const bdeut_StringRef& tag);

    template <typename TYPE>
    int executeArrayRepetitionImp(const TYPE&            object,
                                  const bdeut_StringRef& tag,
                                  int                    formattingMode);

  private:
    // NOT IMPLEMENTED
    baexml_Encoder_EncodeObject(const baexml_Encoder_EncodeObject&);
    baexml_Encoder_EncodeObject& operator=(const baexml_Encoder_EncodeObject&);

  public:
    // CREATORS
    explicit baexml_Encoder_EncodeObject(baexml_Encoder_Context *context);

    // Using compiler generated destructor:
    // ~baexml_Encoder_EncodeObject();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(const TYPE& object, const INFO_TYPE& info);

    template <typename TYPE>
    int execute(const TYPE&            object,
                const bdeut_StringRef& tag,
                int                    formattingMode);
};

                      // ================================
                      // class baexml_Encoder_EncodeValue
                      // ================================

class baexml_Encoder_EncodeValue {
    // Component-private class.  Do not use.
    // This class just encodes a value *without* any enclosing tags.

    // PRIVATE DATA MEMBERS
    baexml_Encoder_Context *d_context_p;

  public:
    // IMPLEMENTATION MANIPULATORS
    template <typename TYPE>
    int executeImp(const TYPE& object,
                   int         formattingMode,
                   bdeat_TypeCategory::Sequence);

    template <typename TYPE>
    int executeImp(const TYPE& object,
                   int         formattingMode,
                   bdeat_TypeCategory::Choice);

    template <typename TYPE>
    int executeImp(const TYPE& object,
                   int         formattingMode,
                   bdeat_TypeCategory::DynamicType);

    template <typename TYPE, typename ANY_CATEGORY>
    int executeImp(const TYPE& object,
                   int         formattingMode,
                   ANY_CATEGORY);

  private:
    // NOT IMPLEMENTED
    baexml_Encoder_EncodeValue(const baexml_Encoder_EncodeValue&);
    baexml_Encoder_EncodeValue& operator=(const baexml_Encoder_EncodeValue&);

  public:
    // CREATORS
    explicit baexml_Encoder_EncodeValue(baexml_Encoder_Context *context);

    // Using compiler generated destructor:
    // ~baexml_Encoder_EncodeValue();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(const TYPE& object, const INFO_TYPE& info);

    template <typename TYPE>
    int execute(const TYPE& object, int formattingMode);
};

                    // ======================================
                    // class baexml_Encoder_SequenceFirstPass
                    // ======================================

class baexml_Encoder_SequenceFirstPass {
    // Component private class.  Do not use.
    // This class is used as the first pass when encoding elements of a
    // sequence.  It basically does two things:
    //     o encode elements with the
    //       'bdeat_FormattingMode::BDEAT_IS_ATTRIBUTE' flag using the
    //       'baexml_Formatter::addAttribute' method.
    //     o looks for an element with the
    //       'bdeat_FormattingMode::BDEAT_IS_SIMPLE_CONTENT' flag and, if
    //       found, provides accessors to obtain the 'id' of the element.
    //       Note that the behavior is undefined unless there is only one
    //       element with 'IS_SIMPLE_CONTENT' flag and, if this element exist,
    //       all other elements must have 'IS_ATTRIBUTE' flag.

    // PRIVATE DATA MEMBERS
    baexml_Encoder_Context   *d_context_p;        // held, not owned
    bool                      d_hasSubElements;   // true if an element with
                                                  // neither 'IS_ATTRIBUTE' nor
                                                  // 'IS_SIMPLE_CONTENT' is
                                                  // found
    bdeut_NullableValue<int>  d_simpleContentId;  // the 'id' of the element
                                                  // with 'IS_SIMPLE_CONTENT'
                                                  // flag, if found

  public:
    // IMPLEMENTATION MANIPULATORS
    template <typename TYPE>
    int addAttributeImp(const TYPE&            object,
                        const bdeut_StringRef& name,
                        int                    formattingMode,
                        bdeat_TypeCategory::NullableValue);
    template <typename TYPE>
    int addAttributeImp(const TYPE&            object,
                        const bdeut_StringRef& name,
                        int                    formattingMode,
                        bdeat_TypeCategory::DynamicType);
    template <typename TYPE, typename ANY_CATEGORY>
    int addAttributeImp(const TYPE&            object,
                        const bdeut_StringRef& name,
                        int                    formattingMode,
                        ANY_CATEGORY);
        // Add an attribute with the specified 'name', the value of the
        // specified 'object', using the specified 'formattingMode'.  Note that
        // the last argument is used for overloading purposes only.

    template <typename TYPE>
    int addAttribute(const TYPE&            object,
                     const bdeut_StringRef& name,
                     int                    formattingMode);
        // Add an attribute with the specified 'name', the value of the
        // specified 'object', using the specified 'formattingMode'.

  private:
    // NOT IMPLEMENTED
    baexml_Encoder_SequenceFirstPass(const baexml_Encoder_SequenceFirstPass&);
    baexml_Encoder_SequenceFirstPass&
    operator=(const baexml_Encoder_SequenceFirstPass&);

  public:
    // CREATORS
    explicit baexml_Encoder_SequenceFirstPass(baexml_Encoder_Context *context);
        // Create a visitor for first pass for sequences.

    // Generated by compiler:
    // ~baexml_Encoder_SequenceFirstPass();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(const TYPE& object, const INFO_TYPE& info);
        // Called back when an element is visited.

    // ACCESSORS
    const bool& hasSubElements() const;
        // Return true if a sub-element is found, and false otherwise.

    const bdeut_NullableValue<int>& simpleContentId() const;
        // Return a null value if there is no element with 'IS_SIMPLE_CONTENT'
        // flag, or a non-null value with the integer 'id' of the element
        // otherwise.
};

                  // =======================================
                  // class baexml_Encoder_SequenceSecondPass
                  // =======================================

class baexml_Encoder_SequenceSecondPass {
    // Component-private class.  Do not use.
    // This class is used as the second pass when encoding elements of a
    // sequence.  It basically calls 'EncoderUtil_EncodeObject' for elements
    // that do not have 'IS_ATTRIBUTE' flag.  Note that the behavior is
    // undefined if there is an element with the 'IS_SIMPLE_CONTENT' flag.

    // DATA
    baexml_Encoder_EncodeObject d_encodeObjectFunctor;
        // functor used to encode sub-elements

    // NOT IMPLEMENTED
    baexml_Encoder_SequenceSecondPass(
                                     const baexml_Encoder_SequenceSecondPass&);
    baexml_Encoder_SequenceSecondPass& operator=(
                                     const baexml_Encoder_SequenceSecondPass&);

  public:
    // CREATORS
    explicit
    baexml_Encoder_SequenceSecondPass(baexml_Encoder_Context *context);
        // Create a visitor for the second pass for sequences.

    // Generated by compiler:
    // ~baexml_Encoder_SequenceSecondPass();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(const TYPE& object, const INFO_TYPE& info);
        // Called back when an element is visited.
};

// ============================================================================
//                               PROXY CLASSES
// ============================================================================

                // ===============================================
                // struct baexml_Encoder_EncodeObject_executeProxy
                // ===============================================

struct baexml_Encoder_EncodeObject_executeProxy {
    // Component-private struct.  Do not use.

    // DATA MEMBERS
    baexml_Encoder_EncodeObject *d_instance_p;
    const bdeut_StringRef       *d_tag_p;
    int                          d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(const TYPE& object)
    {
        return d_instance_p->execute(object, *d_tag_p, d_formattingMode);
    }
};

              // ==================================================
              // struct baexml_Encoder_EncodeObject_executeImpProxy
              // ==================================================

struct baexml_Encoder_EncodeObject_executeImpProxy {
    // Component-private struct.  Do not use.

    // DATA
    baexml_Encoder_EncodeObject *d_instance_p;
    const bdeut_StringRef       *d_tag_p;
    int                          d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(const TYPE&, bslmf_Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template <typename TYPE, typename ANY_CATEGORY>
    inline
    int operator()(const TYPE& object, ANY_CATEGORY category)
    {
        return d_instance_p->executeImp(object,
                                        *d_tag_p,
                                        d_formattingMode,
                                        category);
    }
};

               // =================================================
               // struct baexml_Encoder_EncodeValue_executeImpProxy
               // =================================================

struct baexml_Encoder_EncodeValue_executeImpProxy {
    // Component-private struct.  Do not use.

    // DATA MEMBERS
    baexml_Encoder_EncodeValue *d_instance_p;
    int                         d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(const TYPE&, bslmf_Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template <typename TYPE, typename ANY_CATEGORY>
    inline
    int operator()(const TYPE& object, ANY_CATEGORY category)
    {
        return d_instance_p->executeImp(object,
                                        d_formattingMode,
                                        category);
    }
};

         // =========================================================
         // struct baexml_Encoder_SequenceFirstPass_addAttributeProxy
         // =========================================================

struct baexml_Encoder_SequenceFirstPass_addAttributeProxy {
    // Component-private struct.  Do not use.

    // DATA MEMBERS
    baexml_Encoder_SequenceFirstPass *d_instance_p;
    const bdeut_StringRef            *d_name_p;
    int                               d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(const TYPE& object)
    {
        return d_instance_p->addAttribute(object,
                                          *d_name_p,
                                          d_formattingMode);
    }
};

        // ============================================================
        // struct baexml_Encoder_SequenceFirstPass_addAttributeImpProxy
        // ============================================================

struct baexml_Encoder_SequenceFirstPass_addAttributeImpProxy {
    // Component-private struct.  Do not use.

    // DATA MEMBERS
    baexml_Encoder_SequenceFirstPass *d_instance_p;
    const bdeut_StringRef            *d_name_p;
    int                               d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(const TYPE&, bslmf_Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template <typename TYPE, typename ANY_CATEGORY>
    inline
    int operator()(const TYPE& object, ANY_CATEGORY category)
    {
        return d_instance_p->addAttributeImp(object,
                                             *d_name_p,
                                             d_formattingMode,
                                             category);
    }
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                   // -------------------------------------
                   // class baexml_BerEncoder::MemOutStream
                   // -------------------------------------

inline
baexml_Encoder::MemOutStream::MemOutStream(bslma_Allocator *basicAllocator)
: bsl::ostream(0)
, d_sb(bslma_Default::allocator(basicAllocator))
{
    rdbuf(&d_sb);
}

// MANIPULATORS
inline
void baexml_Encoder::MemOutStream::reset()
{
    d_sb.reset();
}

// ACCESSORS
inline
const char* baexml_Encoder::MemOutStream::data() const
{
    return d_sb.data();
}

inline
int baexml_Encoder::MemOutStream::length() const
{
    return (int)d_sb.length();
}

                             // --------------------
                             // class baexml_Encoder
                             // --------------------

inline
bool baexml_Encoder::isCompact() const
{
    return baexml_EncodingStyle::BAEXML_COMPACT == d_options->encodingStyle();
}

inline
const baexml_EncoderOptions *baexml_Encoder::options() const
{
    return d_options;
}

inline
bsl::ostream *baexml_Encoder::errorStream() const
{
    return d_errorStream;
}

inline
bsl::ostream *baexml_Encoder::warningStream() const
{
    return d_warningStream;
}

inline
baexml_ErrorInfo::Severity baexml_Encoder::errorSeverity() const
{
    return d_severity;
}

inline
bdeut_StringRef baexml_Encoder::loggedMessages() const
{
    if (d_logStream) {
        return bdeut_StringRef(d_logStream->data(), d_logStream->length());
    }
    return bdeut_StringRef();
}

inline
bsl::ostream& baexml_Encoder::logStream()
{
    if (0 == d_logStream) {
        d_logStream = new(d_logArea.buffer()) MemOutStream(d_allocator);
    }
    return *d_logStream;
}

template <typename TYPE>
inline
int baexml_Encoder::encode(bsl::streambuf *buffer, const TYPE& object)
{
    bool bCompact = isCompact();

    baexml_Formatter formatter(buffer,
         bCompact ?  0 : d_options->initialIndentLevel(),
         bCompact ?  0 : d_options->spacesPerLevel(),
         bCompact ? -1 : d_options->wrapColumn());

    return encode(formatter, object);
}

template <typename TYPE>
inline
int baexml_Encoder::encodeToStream(bsl::ostream& stream, const TYPE& object)
{
    return encode(stream.rdbuf(), object);
}

template <typename TYPE>
inline
bsl::ostream& baexml_Encoder::encode(bsl::ostream& stream, const TYPE& object)
{
    bool bCompact = isCompact();

    baexml_Formatter formatter(stream,
         bCompact ?  0 : d_options->initialIndentLevel(),
         bCompact ?  0 : d_options->spacesPerLevel(),
         bCompact ? -1 : d_options->wrapColumn());

    encode(formatter, object);
    return stream;
}

template <typename TYPE>
int baexml_Encoder::encode(baexml_Formatter& formatter, const TYPE& object)
{
    d_severity = baexml_ErrorInfo::BAEXML_NO_ERROR;
    if (d_logStream != 0) {
        d_logStream->reset();
    }

    baexml_Encoder_Context context(&formatter,this);

    formatter.addHeader();

    const char *tag = d_options->tag().empty()
                    ? bdeat_TypeName::xsdName(object,
                                              d_options->formattingMode())
                    : d_options->tag().c_str();

    context.openElement(tag);

    if (!d_options->objectNamespace().empty()) {

        context.addAttribute("xmlns", d_options->objectNamespace());

        // Only declare the "xsi" namespace and schema location if an object
        // namespace was provided because only then can validation happen.
        context.addAttribute("xmlns:xsi",
                             "http://www.w3.org/2001/XMLSchema-instance");

        if (!d_options->schemaLocation().empty()) {
            context.addAttribute("xsi:schemaLocation",
                                 d_options->objectNamespace()
                                 + " "
                                 + d_options->schemaLocation());
        }
    }
//     else {
//         context.addAttribute("xmlns:xsi",
//                              "http://www.w3.org/2001/XMLSchema-instance");
//     }

    baexml_Encoder_EncodeValue encodeValue(&context);

    int rc = 0;
    if (0 != encodeValue.execute(object,d_options->formattingMode())) {

        logError("Failed to encode", tag, d_options->formattingMode());

        context.invalidate();
        rc = -1;
    }
    else {
        context.closeElement(tag);
    }

    switch (d_severity) {
      case baexml_ErrorInfo::BAEXML_NO_ERROR: {
      } break;
      case baexml_ErrorInfo::BAEXML_WARNING: {
        if (d_warningStream) {
            *d_warningStream << loggedMessages();
        }
      } break;
      default: {
        if (d_errorStream) {
            *d_errorStream << loggedMessages();
        }
      } break;
    }
    return rc;
}

                       // ---------------------------------
                       // class baexml_Encoder_EncodeObject
                       // ---------------------------------

// IMPLEMENTATION MANIPULATORS
template <typename TYPE>
inline
int
baexml_Encoder_EncodeObject::executeImp(const TYPE&            object,
                                        const bdeut_StringRef& tag,
                                        int                    formattingMode,
                                        bdeat_TypeCategory::Array)
{
    if (formattingMode & bdeat_FormattingMode::BDEAT_LIST) {
        return executeArrayListImp(object, tag);
    }
    // else { return ... } removed, to prevent warning with gcc-4.1.1
    // (reach end of non-void function), instead, have unconditional:

    return executeArrayRepetitionImp(object, tag, formattingMode);
}

template <typename TYPE>
inline
int
baexml_Encoder_EncodeObject::executeImp(const TYPE&            object,
                                        const bdeut_StringRef& tag,
                                        int                    formattingMode,
                                        bdeat_TypeCategory::NullableValue)
{
    enum { BAEXML_SUCCESS = 0 };

    if (bdeat_NullableValueFunctions::isNull(object)) {
        if (formattingMode & bdeat_FormattingMode::BDEAT_NILLABLE) {
            d_context_p->openElement(tag);
            if (!d_context_p->encoderOptions().objectNamespace().empty()) {
                // Only add the "xsi:nil" attribute if an object namespace was
                // provided because only then can validation happen.
                d_context_p->addAttribute("xsi:nil", "true");
            }
            d_context_p->closeElement(tag);
        }

        return d_context_p->status();
    }

    baexml_Encoder_EncodeObject_executeProxy proxy = {
        this,
        &tag,
        formattingMode
    };

    return bdeat_NullableValueFunctions::accessValue(object, proxy);
}

template <typename TYPE>
inline
int baexml_Encoder_EncodeObject::executeImp(
                                         const TYPE&            object,
                                         const bdeut_StringRef& tag,
                                         int                    formattingMode,
                                         bdeat_TypeCategory::DynamicType)
{
    baexml_Encoder_EncodeObject_executeImpProxy proxy = {
        this,
        &tag,
        formattingMode
    };

    return bdeat_TypeCategoryUtil::accessByCategory(object, proxy);
}

template <typename TYPE, typename ANY_CATEGORY>
int baexml_Encoder_EncodeObject::executeImp(
                                         const TYPE&            object,
                                         const bdeut_StringRef& tag,
                                         int                    formattingMode,
                                         ANY_CATEGORY)
{
    enum { BAEXML_FAILURE = -1 };

    bool isUntagged = formattingMode & bdeat_FormattingMode::BDEAT_UNTAGGED;

    if (!isUntagged) {
        d_context_p->openElement(tag);
    }

    baexml_Encoder_EncodeValue encodeValue(d_context_p);

    if (0 != encodeValue.execute(object, formattingMode)) {

        d_context_p->logError("Unable to encode value",
                              tag,
                              formattingMode);
        return BAEXML_FAILURE;
    }

    if (!isUntagged) {
        d_context_p->closeElement(tag);
    }

    int ret = d_context_p->status();

    if (ret) {
        d_context_p->logError("Formatter was invalidated for",
                              tag,
                              formattingMode);
    }

    return ret;
}

template <typename TYPE>
int baexml_Encoder_EncodeObject::executeArrayListImp(
                                                 const TYPE&            object,
                                                 const bdeut_StringRef& tag)
{
    d_context_p->openElement(tag);

    baexml_TypesPrintUtil::printList(d_context_p->rawOutputStream(),
                                     object,
                                     &d_context_p->encoderOptions());

    d_context_p->closeElement(tag);

    int ret = d_context_p->status();

    if (ret) {

        d_context_p->logError(
            "Error while encoding list for",
            tag,
            baexml_EncoderOptions::DEFAULT_INITIALIZER_FORMATTING_MODE);
    }

    return ret;
}

template <typename TYPE>
int baexml_Encoder_EncodeObject::executeArrayRepetitionImp(
                                         const TYPE&            object,
                                         const bdeut_StringRef& tag,
                                         int                    formattingMode)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    const int size = (int)bdeat_ArrayFunctions::size(object);

    baexml_Encoder_EncodeObject_executeProxy proxy = {
        this,
        &tag,
        formattingMode
    };

    for (int i = 0; i < size; ++i) {
        if (0 != bdeat_ArrayFunctions::accessElement(object, proxy, i)) {

            d_context_p->logError(
                "Error while encoding array element",
                tag,
                formattingMode,
                i);

            return BAEXML_FAILURE;
        }
    }

    return BAEXML_SUCCESS;
}

// CREATORS
inline
baexml_Encoder_EncodeObject::baexml_Encoder_EncodeObject(
                                               baexml_Encoder_Context *context)
: d_context_p(context)
{
    BSLS_ASSERT_SAFE(d_context_p);
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
inline
int baexml_Encoder_EncodeObject::operator()(const TYPE&      object,
                                            const INFO_TYPE& info)
{
    bdeut_StringRef name(info.name(), info.nameLength());

    return execute(object, name, info.formattingMode());
}

template <typename TYPE>
inline
int baexml_Encoder_EncodeObject::execute(const TYPE&            object,
                                         const bdeut_StringRef& tag,
                                         int                    formattingMode)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return executeImp(object, tag, formattingMode, TypeCategory());
}

                       // --------------------------------
                       // class baexml_Encoder_EncodeValue
                       // --------------------------------

// IMPLEMENTATION MANIPULATORS
template <typename TYPE>
inline
int baexml_Encoder_EncodeValue::executeImp(const TYPE& object,
                                           int         formattingMode,
                                           bdeat_TypeCategory::Sequence)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

#if defined(BDE_BUILD_TARGET_SAFE)
    int type = formattingMode & bdeat_FormattingMode::BDEAT_TYPE_MASK;

    BSLS_ASSERT_SAFE(bdeat_FormattingMode::BDEAT_DEFAULT == type);
#else
    (void) formattingMode;
#endif

    baexml_Encoder_SequenceFirstPass firstPass(d_context_p);

    if (0 != bdeat_SequenceFunctions::accessAttributes(object, firstPass)) {
        return BAEXML_FAILURE;
    }

    if (!firstPass.simpleContentId().isNull()) {
        baexml_Encoder_EncodeValue encodeValue(d_context_p);

        return bdeat_SequenceFunctions::accessAttribute(
                                          object,
                                          encodeValue,
                                          firstPass.simpleContentId().value());
    }

    if (firstPass.hasSubElements()) {
        baexml_Encoder_SequenceSecondPass secondPass(d_context_p);

        return bdeat_SequenceFunctions::accessAttributes(object, secondPass);
    }

    return BAEXML_SUCCESS;
}

template <typename TYPE>
inline
int baexml_Encoder_EncodeValue::executeImp(const TYPE& object,
                                           int         formattingMode,
                                           bdeat_TypeCategory::Choice)
{
    enum { BAEXML_FAILURE = -1 };

#if defined(BDE_BUILD_TARGET_SAFE)
    int type = formattingMode & bdeat_FormattingMode::BDEAT_TYPE_MASK;

    BSLS_ASSERT_SAFE(bdeat_FormattingMode::BDEAT_DEFAULT == type);
#endif

    if (bdeat_ChoiceFunctions::BDEAT_UNDEFINED_SELECTION_ID
                               == bdeat_ChoiceFunctions::selectionId(object)) {

        d_context_p->logError("Undefined selection is not allowed ",
                              "???",
                              formattingMode);
        return BAEXML_FAILURE;
    }

    baexml_Encoder_EncodeObject encodeObject(d_context_p);

    return bdeat_ChoiceFunctions::accessSelection(object, encodeObject);
}

template <typename TYPE>
inline
int baexml_Encoder_EncodeValue::executeImp(const TYPE& object,
                                           int         formattingMode,
                                           bdeat_TypeCategory::DynamicType)
{
    baexml_Encoder_EncodeValue_executeImpProxy proxy = {
        this,
        formattingMode
    };

    return bdeat_TypeCategoryUtil::accessByCategory(object, proxy);
}

template <typename TYPE, typename ANY_CATEGORY>
inline
int baexml_Encoder_EncodeValue::executeImp(const TYPE& object,
                                           int         formattingMode,
                                           ANY_CATEGORY)
{
    baexml_TypesPrintUtil::print(d_context_p->rawOutputStream(),
                                 object,
                                 formattingMode,
                                 &d_context_p->encoderOptions());

    return d_context_p->status();
}

// CREATORS
inline
baexml_Encoder_EncodeValue::baexml_Encoder_EncodeValue(
                                               baexml_Encoder_Context *context)
: d_context_p(context)
{
    BSLS_ASSERT_SAFE(d_context_p);
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
inline
int baexml_Encoder_EncodeValue::operator()(const TYPE&      object,
                                           const INFO_TYPE& info)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return executeImp(object, info.formattingMode(), TypeCategory());
}

template <typename TYPE>
inline
int baexml_Encoder_EncodeValue::execute(const TYPE& object,
                                        int         formattingMode)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return executeImp(object, formattingMode, TypeCategory());
}

                    // --------------------------------------
                    // class baexml_Encoder_SequenceFirstPass
                    // --------------------------------------

// IMPLEMENTATION MANIPULATORS
template <typename TYPE>
inline
int baexml_Encoder_SequenceFirstPass::addAttributeImp(
                                         const TYPE&            object,
                                         const bdeut_StringRef& name,
                                         int                    formattingMode,
                                         bdeat_TypeCategory::NullableValue)
{
    enum { BAEXML_SUCCESS = 0 };

    if (bdeat_NullableValueFunctions::isNull(object)) {
        return BAEXML_SUCCESS;
    }

    baexml_Encoder_SequenceFirstPass_addAttributeProxy proxy = {
        this,
        &name,
        formattingMode
    };

    return bdeat_NullableValueFunctions::accessValue(object, proxy);
}

template <typename TYPE>
inline
int baexml_Encoder_SequenceFirstPass::addAttributeImp(
                                         const TYPE&            object,
                                         const bdeut_StringRef& name,
                                         int                    formattingMode,
                                         bdeat_TypeCategory::DynamicType)
{
    baexml_Encoder_SequenceFirstPass_addAttributeImpProxy proxy = {
        this,
        &name,
        formattingMode
    };

    return bdeat_TypeCategoryUtil::accessByCategory(object, proxy);

}

template <typename TYPE, typename ANY_CATEGORY>
inline
int baexml_Encoder_SequenceFirstPass::addAttributeImp(
                                         const TYPE&            object,
                                         const bdeut_StringRef& name,
                                         int                    formattingMode,
                                         ANY_CATEGORY)
{
    d_context_p->addAttribute(name, object, formattingMode);

    int ret = d_context_p->status();

    if (ret) {
        d_context_p->logError("Failed to encode attribute",
                              name,
                              formattingMode);
    }

    return ret;
}

template <typename TYPE>
inline
int baexml_Encoder_SequenceFirstPass::addAttribute(
                                         const TYPE&            object,
                                         const bdeut_StringRef& name,
                                         int                    formattingMode)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return addAttributeImp(object, name, formattingMode, TypeCategory());
}

// CREATORS
inline
baexml_Encoder_SequenceFirstPass::baexml_Encoder_SequenceFirstPass(
                                               baexml_Encoder_Context *context)
: d_context_p(context)
, d_hasSubElements(false)
{
    BSLS_ASSERT_SAFE(d_context_p);
    BSLS_ASSERT_SAFE(d_simpleContentId.isNull());
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
int baexml_Encoder_SequenceFirstPass::operator()(const TYPE&      object,
                                                 const INFO_TYPE& info)
{
    enum { BAEXML_SUCCESS = 0 };

    int  formattingMode  = info.formattingMode();
    bool isSimpleContent = formattingMode
                         & bdeat_FormattingMode::BDEAT_SIMPLE_CONTENT;
    bool isAttribute     =
                        formattingMode & bdeat_FormattingMode::BDEAT_ATTRIBUTE;

    if (isSimpleContent) {
        BSLS_ASSERT_SAFE(!isAttribute);
        BSLS_ASSERT_SAFE(!d_hasSubElements);
        BSLS_ASSERT_SAFE(d_simpleContentId.isNull());

        d_simpleContentId.makeValue(info.id());
    }
    else if (isAttribute) {
        bdeut_StringRef name(info.name(), info.nameLength());

        return addAttribute(object, name, formattingMode);
    }
    else {
        BSLS_ASSERT_SAFE(d_simpleContentId.isNull());

        d_hasSubElements = true;
    }

    return BAEXML_SUCCESS;
}

// ACCESSORS
inline
const bool& baexml_Encoder_SequenceFirstPass::hasSubElements() const
{
    return d_hasSubElements;
}

inline
const bdeut_NullableValue<int>&
baexml_Encoder_SequenceFirstPass::simpleContentId() const
{
    return d_simpleContentId;
}

                    // ---------------------------------------
                    // class baexml_Encoder_SequenceSecondPass
                    // ---------------------------------------

// CREATORS
inline
baexml_Encoder_SequenceSecondPass::baexml_Encoder_SequenceSecondPass(
                                               baexml_Encoder_Context *context)
: d_encodeObjectFunctor(context)
{
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
int baexml_Encoder_SequenceSecondPass::operator()(const TYPE&      object,
                                                  const INFO_TYPE& info)
{
    enum { BAEXML_SUCCESS = 0 };

    int formattingMode = info.formattingMode();

    BSLS_ASSERT_SAFE(
               !(formattingMode & bdeat_FormattingMode::BDEAT_SIMPLE_CONTENT));

    if (!(formattingMode & bdeat_FormattingMode::BDEAT_ATTRIBUTE)) {
        return d_encodeObjectFunctor(object, info);
    }

    return BAEXML_SUCCESS;
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2006, 2008
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
