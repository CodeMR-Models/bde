// baexml_decoder.h         -*-C++-*-
#ifndef INCLUDED_BAEXML_DECODER
#define INCLUDED_BAEXML_DECODER

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide a generic translation from XML into C++ objects.
//
//@CLASSES:
//   baexml_Decoder: an XML decoder
//
//@AUTHOR: Shezan Baig (sbaig), Alexander Libman (alibman1@bloomberg.net)
//
//@CONTACT: Rohan Bhindwale (rbhindwa)
//
//@SEE_ALSO: baexml_decoderoptions, baexml_encoder, bdem_berdecoder
//
//@DESCRIPTION: This component provides a class 'baexml_Decoder' for decoding
// value-semantic objects in XML format.  The 'decode' methods are function
// templates that will decode any object that meets the requirements of a
// sequence or choice object as defined in the 'bdeat_sequencefunctions' and
// 'bdeat_choicefunctions' components.  These generic frameworks provide a
// common compile-time interface for manipulating struct-like and union-like
// objects.  In particular, 'bcem_aggregate' and the types generated by
// 'bas_codegen.pl' provide the necessary interface and can be decoded using
// this component.
//
// There are two usage models for using 'baexml_Decoder'.  The common case,
// when the type of object being decoded is known in advance, involves calling
// one of a set of 'decode' method templates that decode a specified
// value-semantic object from a specified stream or other input source.  The
// caller may specify the input for 'decode' as a file, an 'bsl::istream', an
// 'bsl::streambuf', or a memory buffer.
//
// A less common but more flexible usage model involves calling the 'open' to
// open the XML document from the specified input, then calling 'decode' to
// decode to an object without specifying the input source, and finally
// calling 'close' to close the input source.  The 'open' method positions the
// internal reader to the root element node, so the caller can examine the
// root element, decide what type of object is contained in the input
// stream/source, and construct an object of the needed type before calling
// 'decode' to read from the already open input source.  Thus the input data
// is not constrained to a single root element type.
//
// Although the XML format is very useful for debugging and for conforming to
// external data-interchange specifications, it is relatively expensive to
// encode and decode and relatively bulky to transmit.  It is more efficient
// to use a binary encoding (such as BER) if the encoding format is under your
// control.  (See 'bdem_berdecoder'.)
//
///Usage Example 1
///---------------
// Suppose we have the following XML schema inside a file called
// 'employee.xsd':
//..
//  <?xml version='1.0' encoding='UTF-8'?>
//  <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
//             xmlns:test='http://bloomberg.com/schemas/test'
//             targetNamespace='http://bloomberg.com/schemas/test'
//             elementFormDefault='unqualified'>
//
//      <xs:complexType name='Address'>
//          <xs:sequence>
//              <xs:element name='street' type='xs:string'/>
//              <xs:element name='city'   type='xs:string'/>
//              <xs:element name='state'  type='xs:string'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:complexType name='Employee'>
//          <xs:sequence>
//              <xs:element name='name'        type='xs:string'/>
//              <xs:element name='homeAddress' type='test:Address'/>
//              <xs:element name='age'         type='xs:int'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:element name='Address' type='test:Address'/>
//      <xs:element name='Employee' type='test:Employee'/>
//
//  </xs:schema>
//..
// Using the 'bas_codegen.pl' tool, we can generate C++ classes for this
// schema:
//..
//  $ bas_codegen.pl -m msg -p test -E xsdfile.xsd
//..
// This tool will generate the header and implementation files for the
// 'test_address' and 'test_employee' components in the current directory.
//
// The following function decodes an XML string into a 'test::Employee' object
// and verifies the results:
//..
//  #include <test_employee.h>
//  #include <baexml_decoder.h>
//  #include <baexml_decoderoptions.h>
//  #include <baexml_errorinfo.h>
//  #include <baexml_minireader.h>
//  #include <bsl_sstream.h>
//
//  using namespace BloombergLP;
//
//  int main()
//  {
//      const char INPUT[] = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
//                           "<Employee>\n"
//                           "    <name>Bob</name>\n"
//                           "    <homeAddress>\n"
//                           "        <street>Some Street</street>\n"
//                           "        <city>Some City</city>\n"
//                           "        <state>Some State</state>\n"
//                           "    </homeAddress>\n"
//                           "    <age>21</age>\n"
//                           "</Employee>\n";
//
//      bsl::stringstream ss(INPUT);
//
//      test::Employee bob;
//
//      baexml_DecoderOptions options;
//      baexml_MiniReader     reader;
//      baexml_ErrorInfo      errInfo;
//
//      baexml_Decoder decoder(&options, &reader, &errInfo);
//
//      decoder.decode(ss, &bob);
//
//      assert(ss);
//      assert("Bob"         == bob.name());
//      assert("Some Street" == bob.homeAddress().street());
//      assert("Some City"   == bob.homeAddress().city());
//      assert("Some State"  == bob.homeAddress().state());
//      assert(21            == bob.age());
//
//      return 0;
//  }
//..
///Usage Example 2
///---------------
// The following snippets of code illustrate how to pass an error stream and
// warning stream to the 'decode' function.  We will use the same
// 'test_employee' component from the previous usage example.  Note that the
// input XML string contains an error.  (The 'homeAddress' object has an
// element called 'country', which does not exist in the schema.):
//..
//  #include <test_employee.h>
//  #include <baexml_decoder.h>
//  #include <baexml_decoderoptions.h>
//  #include <baexml_errorinfo.h>
//  #include <baexml_minireader.h>
//  #include <bsl_sstream.h>
//
//  using namespace BloombergLP;
//
//  int main()
//  {
//      const char INPUT[] = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
//                           "<Employee>\n"
//                           "    <name>Bob</name>\n"
//                           "    <homeAddress>\n"
//                           "        <street>Some Street</street>\n"
//                           "        <city>Some City</city>\n"
//                           "        <state>Some State</state>\n"
//                           "        <country>Some Country</country>\n"
//                           "    </homeAddress>\n"
//                           "    <age>21</age>\n"
//                           "</Employee>\n";
//
//      bsl::stringstream ss(INPUT);
//
//      test::Employee bob;
//
//      baexml_DecoderOptions options;
//      baexml_MiniReader     reader;
//      baexml_ErrorInfo      errInfo;
//
//      options.setSkipUnknownElements(false);
//      baexml_Decoder decoder(&options, &reader, &errInfo,
//                             &bsl::cerr, &bsl::cerr);
//      decoder.decode(ss, &bob);
//
//      assert(!ss);
//
//      return 0;
//  }
//..
// Note that the input stream is invalidated to indicate that an error
// occurred.  Also note that the following error message will be printed on
// 'bsl::cerr':
//..
//  employee.xml:8.18: Error: Unable to decode sub-element 'country'.\n"
//  employee.xml:8.18: Error: Unable to decode sub-element 'homeAddress'.\n";
//..
// The following snippets of code illustrate how to open decoder and read the
// first node before calling 'decode':
//..
//  int main()
//  {
//      const char INPUT[] =
//          "<?xml version='1.0' encoding='UTF-8' ?>\n"
//          "<Employee xmlns='http://www.bde.com/bdem_test'>\n"
//          "    <name>Bob</name>\n"
//          "    <homeAddress>\n"
//          "        <street>Some Street</street>\n"
//          "        <state>Some State</state>\n"
//          "        <city>Some City</city>\n"
//          "        <country>Some Country</country>\n"
//          "    </homeAddress>\n"
//          "    <age>21</age>\n"
//          "</Employee>\n";
//
//      baexml_MiniReader     reader;
//      baexml_ErrorInfo      errInfo;
//      baexml_DecoderOptions options;
//
//      baexml_Decoder decoder(&options, &reader, &errInfo,
//                             &bsl::cerr, &bsl::cerr);
//
//..
// Now we open the document, but we don't begin decoding yet:
//..
//      int rc = decoder.open(INPUT, sizeof(INPUT) - 1);
//      assert(0 == rc);
//..
// Depending on the value of the first node, we can now determine whether the
// document is an 'Address' object or an 'Employee' object, and construct the
// target object accordingly:
//..
//      if (0 == bsl::strcmp(reader.nodeLocalName(), "Address")) {
//          test::Address addr;
//          rc = decoder.decode(&addr);
//          bsl::cout << addr;
//      }
//      else {
//          test::Employee bob;
//          rc = decoder.decode(&bob);
//          bsl::cout << bob;
//      }
//
//      assert(0 == rc);
//..
// When decoding is complete, we must close the decoder object:
//..
//      decoder.close();
//      return 0;
//  }
//..

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BAEXML_DECODEROPTIONS
#include <baexml_decoderoptions.h>
#endif

#ifndef INCLUDED_BAEXML_BASE64PARSER
#include <baexml_base64parser.h>
#endif

#ifndef INCLUDED_BAEXML_HEXPARSER
#include <baexml_hexparser.h>
#endif

#ifndef INCLUDED_BAEXML_LISTPARSER
#include <baexml_listparser.h>
#endif

#ifndef INCLUDED_BAEXML_TYPESPARSERUTIL
#include <baexml_typesparserutil.h>
#endif

#ifndef INCLUDED_BAEXML_ERRORINFO
#include <baexml_errorinfo.h>
#endif

#ifndef INCLUDED_BAEXML_READER
#include <baexml_reader.h>
#endif

#ifndef INCLUDED_BDEAT_ARRAYFUNCTIONS
#include <bdeat_arrayfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CHOICEFUNCTIONS
#include <bdeat_choicefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CUSTOMIZEDTYPEFUNCTIONS
#include <bdeat_customizedtypefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_FORMATTINGMODE
#include <bdeat_formattingmode.h>
#endif

#ifndef INCLUDED_BDEAT_NULLABLEVALUEFUNCTIONS
#include <bdeat_nullablevaluefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_SEQUENCEFUNCTIONS
#include <bdeat_sequencefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_TYPECATEGORY
#include <bdeat_typecategory.h>
#endif

#ifndef INCLUDED_BDEAT_VALUETYPEFUNCTIONS
#include <bdeat_valuetypefunctions.h>
#endif

#ifndef INCLUDED_BDEU_STRING
#include <bdeu_string.h>
#endif

#ifndef INCLUDED_BDEUT_STRINGREF
#include <bdeut_stringref.h>
#endif

#ifndef INCLUDED_BDESB_MEMOUTSTREAMBUF
#include <bdesb_memoutstreambuf.h>
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include <bslma_allocator.h>
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include <bslma_default.h>
#endif

#ifndef INCLUDED_BSLMF_IF
#include <bslmf_if.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include <bsls_objectbuffer.h>
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include <bsl_algorithm.h>            // bsl::min
#endif

#ifndef INCLUDED_BSL_ISTREAM
#include <bsl_istream.h>
#endif

#ifndef INCLUDED_BSL_MAP
#include <bsl_map.h>
#endif

#ifndef INCLUDED_BSL_OSTREAM
#include <bsl_ostream.h>
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include <bsl_streambuf.h>
#endif

#ifndef INCLUDED_BSL_STRING
#include <bsl_string.h>
#endif

#ifndef INCLUDED_BSL_VECTOR
#include <bsl_vector.h>
#endif

#ifndef INCLUDED_BSL_CSTRING
#include <bsl_cstring.h>
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include <bsl_cstdlib.h>
#endif

#ifndef INCLUDED_BSL_CERRNO
#include <bsl_cerrno.h>
#endif

namespace BloombergLP {

class baexml_Reader;
class baexml_ErrorInfo;
class baexml_Decoder;

                      // ===================================
                      // class baexml_Decoder_ElementContext
                      // ===================================

class baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This protocol class contain functions related to parsing XML elements.
    // When the Decoder reads the XML document, it forwards the information
    // about the current node as events to this protocol.  There are several
    // implementations of this protocol, depending on the type of element.
    // The correct implementation for each type is selected by the
    // 'baexml_Decoder_SelectContext' meta-function.  Each of the functions
    // take a 'context' parameter, which contains members related to the
    // context of the decoder.

  public:
    virtual ~baexml_Decoder_ElementContext();
        // For syntactic purposes only.

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder) = 0;

    virtual int endElement(baexml_Decoder   *decoder) = 0;

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder) = 0;

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder) = 0;

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder) = 0;

    int beginParse(baexml_Decoder *decoder);
};

                      // ====================
                      // class baexml_Decoder
                      // ====================

class baexml_Decoder {
    // Engine for decoding value-semantic objects in XML format.  The 'decode'
    // methods are function templates that will decode any object that meets
    // the requirements of a sequence or choice object as defined in the
    // 'bdeat_sequencefunctions' and 'bdeat_choicefunctions' components.
    // These generic frameworks provide a common compile-time interface for
    // manipulating struct-like and union-like objects.  In particular,
    // 'bcem_aggregate' and the types generated by 'bas_codegen.pl' provide
    // the necessary interface and can be decoded using this component.

    friend class  baexml_Decoder_ElementContext;
    friend struct baexml_Decoder_decodeImpProxy;
    friend class  baexml_Decoder_ErrorLogger;

    // PRIVATE TYPES
    class MemOutStream : public bsl::ostream {
        // This class provides stream for logging using 'bdesb_MemOutStreamBuf'
        // as a streambuf.  The logging stream is created on demand, i.e.,
        // during the first attempt to log message.
        bdesb_MemOutStreamBuf d_sb;

        // NOT IMPLEMENTED
        MemOutStream(const MemOutStream&);
        MemOutStream& operator=(const MemOutStream&);

      public:
        // CREATORS
        MemOutStream(bslma_Allocator *basicAllocator = 0);
            // Create a new stream using the specified 'basicAllocator'.

        virtual ~MemOutStream();
            // Destroy this stream and release memory back to the allocator.

        // MANIPULATORS
        void reset();
            // Reset the internal streambuf to empty.

        // ACCESSORS
        const char *data() const;
            // Return a pointer to the memory containing the formatted values
            // formatted to this stream.  The data is not null-terminated
            // unless a null character was appended onto this stream.

        int length() const;
            // Return the length of of the formatted data, including null
            // characters appended to the stream, if any.
    };

    // DATA
    const baexml_DecoderOptions     *d_options;        // held, not owned
    baexml_Reader                   *d_reader;         // held, not owned
    baexml_ErrorInfo                *d_errorInfo;      // held, not owned

    bslma_Allocator                 *d_allocator;      // held, not owned

    bsls_ObjectBuffer<MemOutStream>  d_logArea;
        // placeholder for MemOutStream

    MemOutStream                    *d_logStream;
        // if not zero, log stream was created at the moment of first
        // logging and must be destroyed

    bsl::ostream                    *d_errorStream;    // held, not owned
    bsl::ostream                    *d_warningStream;  // held, not owned

    bsl::string                      d_sourceUri;      // URI of input document
    int                              d_errorCount;     // error count
    int                              d_warningCount;   // warning count

    int                              d_numUnknownElementsSkipped;
                                                       // number of unknown
                                                       // elements skipped

    bool                             d_fatalError;     // fatal error flag
    int                              d_remainingDepth;
        // remaining number of nesting levels allowed

    // NOT IMPLEMENTED
    baexml_Decoder(const baexml_Decoder&);
    baexml_Decoder operator=(const baexml_Decoder&);

  private:
    // PRIVATE MANIPULATORS
    bsl::ostream& logStream();
        // Return the stream for logging.  Note the if stream has not
        // been created yet, it will be created during this call.

    void resetErrors();
    int  checkForReaderErrors();
    int  checkForErrors(const baexml_ErrorInfo& errInfo);

    void setDecoderError(baexml_ErrorInfo::Severity severity,
                         bdeut_StringRef            msg);

    int  readTopElement();
    int  parse(baexml_Decoder_ElementContext *context);

    template <typename TYPE>
    int decodeImp(TYPE *object, bdeat_TypeCategory::DynamicType);

    template <typename TYPE, typename ANY_CATEGORY>
    int decodeImp(TYPE *object, ANY_CATEGORY);

  public:
    // CREATORS
    baexml_Decoder(const baexml_DecoderOptions *options,
                   baexml_Reader               *reader,
                   baexml_ErrorInfo            *errInfo,
                   bslma_Allocator             *basicAllocator);

    baexml_Decoder(const baexml_DecoderOptions *options,
                   baexml_Reader               *reader,
                   baexml_ErrorInfo            *errInfo = 0,
                   bsl::ostream                *errorStream = 0,
                   bsl::ostream                *warningStream = 0,
                   bslma_Allocator             *basicAllocator = 0);
        // Construct a decoder object using the specified 'options' and the
        // specified 'reader' to perform the XML-level parsing.  If the
        // (optionally) specified 'errorInfo' is non-null, it is used to store
        // information about most serious error encountered during parsing.
        // During parsing, error and warning messages will be written to the
        // (optionally) specified 'errorStream' and 'warningStream'
        // respectively.  The behavior is undefined unless 'options' and
        // 'reader' are both non-zero.  The behavior becomes undefined if the
        // objects pointed to by any of the arguments is destroyed before this
        // object has completed parsing.

    ~baexml_Decoder();
        // Call 'close' and destroy this object.

    // MANIPULATORS
    void close();
        // Put the associated 'baexml_Reader' object (i.e., the 'reader'
        // specified at construction) into a closed state.

    int open(bsl::istream& stream, const char *uri = 0);
        // Open the associated 'baexml_Reader' object (see
        // 'baexml_Reader::open') to read XML data from the specified
        // 'stream'.  The (optionally) specified 'uri' is used for identifying
        // the input document in error messages.  Return 0 on success and
        // non-zero otherwise.

    int open(bsl::streambuf *buffer, const char *uri = 0);
        // Open the associated 'baexml_Reader' object (see
        // 'baexml_Reader::open') to read XML data from the specified stream
        // 'buffer'.  The (optionally) specified 'uri' is used for identifying
        // the input document in error messages.  Return 0 on success and
        // non-zero otherwise.

    int open(const char *buffer, bsl::size_t length, const char *uri = 0);
        // Open the associated 'baexml_Reader' object (see
        // 'baexml_Reader::open') to read XML data from memory at the
        // specified 'buffer', with the specified 'length'.  The (optionally)
        // specified 'uri' is used for identifying the input document in error
        // messages.  Return 0 on success and non-zero otherwise.

    int open(const char *filename);
        // Open the associated 'baexml_Reader' object (see
        // 'baexml_Reader::open') to read XML data from the file with the
        // specified 'filename'.  Return 0 on success and non-zero otherwise.

    template <typename TYPE>
    bsl::istream& decode(bsl::istream&  stream,
                         TYPE          *object,
                         const char    *uri = 0);
        // Decode the specified 'object' of parameterized 'TYPE' from the
        // specified input 'stream'.  Return a reference to the modifiable
        // 'stream'.  If a decoding error is detected, 'stream.fail()' will be
        // 'true' after this method returns.  The (optionally) specified 'uri'
        // is used for identifying the input document in error messages.  A
        // compilation error will result unless 'TYPE' conforms to the
        // requirements of a 'bdeat' sequence or choice, as described in
        // 'bdeat_sequencefunctions' and 'bdeat_choicefunctions'.

    template <typename TYPE>
    int decode(bsl::streambuf *buffer,
               TYPE           *object,
               const char     *uri = 0);
        // Decode the specified 'object' of parameterized 'TYPE' from the
        // specified stream 'buffer'.  The (optionally) specified 'uri' is
        // used for identifying the input document in error messages.  Return
        // 0 on success, and a non-zero value otherwise.  A compilation error
        // will result unless 'TYPE' conforms to the requirements of a bdeat
        // sequence or choice, as described in 'bdeat_sequencefunctions' and
        // 'bdeat_choicefunctions'.

    template <typename TYPE>
    int decode(const char  *buffer,
               bsl::size_t  length,
               TYPE        *object,
               const char  *uri = 0);
        // Decode the specified 'object' of parameterized 'TYPE' from the
        // memory at the specified 'buffer' address, having the specified
        // 'length'.  The (optionally) specified 'uri' is used for identifying
        // the input document in error messages.  Return 0 on success, and a
        // non-zero value otherwise.  A compilation error will result unless
        // 'TYPE' conforms to the requirements of a bdeat sequence or choice,
        // as described in 'bdeat_sequencefunctions' and
        // 'bdeat_choicefunctions'.

    template <typename TYPE>
    int decode(const char *filename, TYPE *object);
        // Decode the specified 'object' of parameterized 'TYPE' from the file
        // with the specified 'filename'.  Return 0 on success, and a non-zero
        // value otherwise.  A compilation error will result unless 'TYPE'
        // conforms to the requirements of a bdeat sequence or choice, as
        // described in 'bdeat_sequencefunctions' and 'bdeat_choicefunctions'.

    template <typename TYPE>
    int decode(TYPE *object);
        // Decode the specified 'object' of parameterized 'TYPE' from the
        // input source specified by a previous call to 'open' and leave the
        // reader in an open state.  Return 0 on success, and a non-zero value
        // otherwise.  A compilation error will result unless 'TYPE' conforms
        // to the requirements of a bdeat sequence or choice, as described in
        // 'bdeat_sequencefunctions' and 'bdeat_choicefunctions'.  The
        // behavior is undefined unless this call was preceded by a prior
        // successful call to 'open'

    void setNumUnknownElementsSkipped(int value);
        // Set the number of unknown elements skipped by the decoder during
        // the current decoding operation to the specified 'value'.  The
        // behavior is undefined unless '0 <= value'.

    //ACCESSORS
    const baexml_DecoderOptions *options() const;
        // Return a pointer to the non-modifiable decoder options provided at
        // construction.

    baexml_Reader               *reader() const;
        // Return the a pointer to the modifiable reader associated with this
        // decoder (i.e., the 'reader' pointer provided at construction).

    baexml_ErrorInfo            *errorInfo() const;
        // Return a pointer to the modifiable error-reporting structure
        // associated with this decoder (i.e., the 'errInfo' pointer provided
        // at construction).  The value stored in the error structure is reset
        // to indicate no error on a successful call to 'open'.

    bsl::ostream *errorStream() const;
        // Return pointer to the error stream.

    bsl::ostream *warningStream() const;
        // Return pointer to the warning stream.

    int numUnknownElementsSkipped() const;
        // Return the number of unknown elements that were skipped during the
        // previous decoding operation.  Note that unknown elements are skipped
        // only if 'true == options()->skipUnknownElements()'.

    baexml_ErrorInfo::Severity  errorSeverity() const;
        // Return the severity of the most severe warning or error encountered
        // during the last call to the 'encode' method.  The severity is reset
        // each time 'decode' is called.

    bdeut_StringRef loggedMessages() const;
        // Return a string containing any error, warning, or trace messages
        // that were logged during the last call to the 'decode' method.  The
        // log is reset each time 'decode' is called.

    int  errorCount() const;
        // Return the number of errors that occurred during decoding.  This
        // number is reset to zero on a call to 'open'.

    int  warningCount() const;
        // Return the number of warnings that occurred during decoding.  This
        // number is reset to zero on a call to 'open'.
};

                       // ================================
                       // class baexml_Decoder_ErrorLogger
                       // ================================

class baexml_Decoder_ErrorLogger {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This class is used for logging errors and warnings.  The usage of this
    // class is simplified with macros, which are defined below.

    // DATA
    baexml_Decoder::MemOutStream   d_stream;
    baexml_ErrorInfo::Severity     d_severity;    // severity
    baexml_Decoder                *d_decoder;     // context

  private:
    // NOT IMPLEMENTED
    baexml_Decoder_ErrorLogger(const baexml_Decoder_ErrorLogger&);
    baexml_Decoder_ErrorLogger& operator=(const baexml_Decoder_ErrorLogger&);

  public:
    // CREATORS
    baexml_Decoder_ErrorLogger(baexml_ErrorInfo::Severity  severity,
                               baexml_Decoder             *decoder)
        // Construct a logger for the specified 'decoder'.
    : d_stream   (decoder->d_allocator)
    , d_severity (severity)
    , d_decoder  (decoder)
    {
    }

    ~baexml_Decoder_ErrorLogger()
        // Set the decoder's error message to the contents of the message
        // stream.
    {
        d_decoder->setDecoderError(d_severity,
                                   bdeut_StringRef(d_stream.data(),
                                                   d_stream.length()));
    }

    bsl::ostream& stream()
    {
        return d_stream;
    }
};

// ---  Anything below this line is implementation specific.  Do not use.  ----

// LOGGING MACROS
#define BAEXML_DECODER_LOG_ERROR(reporter)                     \
    do {                                                       \
        baexml_Decoder_ErrorLogger                             \
            logger(baexml_ErrorInfo::BAEXML_ERROR, reporter);  \
        logger.stream()
    // Usage: BAEXML_LOG_ERROR(myDecoder) << "Message"
    //                                    << value << BAEXML_DECODER_LOG_END;

#define BAEXML_DECODER_LOG_WARNING(reporter)                   \
    do {                                                       \
        baexml_Decoder_ErrorLogger                             \
           logger(baexml_ErrorInfo::BAEXML_WARNING, reporter); \
        logger.stream()
    // Usage: BAEXML_LOG_WARNING(myDecoder) << "Message"
    //                                      << value << BAEXML_DECODER_LOG_END;

#define BAEXML_DECODER_LOG_END     \
        bsl::flush;                \
    } while (false)
    // See usage of BAEXML_DECODER_LOG_ERROR and BAEXML_DECODER_LOG_WARNING,
    // above.

// FORWARD DECLARATIONS

class baexml_Decoder_ElementContext;

template <typename TYPE>
class baexml_Decoder_ChoiceContext;
template <typename TYPE>
class baexml_Decoder_CustomizedContext;
template <typename TYPE, typename PARSER>
class baexml_Decoder_PushParserContext;
template <typename TYPE>
class baexml_Decoder_SequenceContext;
template <typename TYPE>
class baexml_Decoder_SimpleContext;
template <typename TYPE>
class baexml_Decoder_UTF8Context;

class baexml_Decoder_UnknownElementContext;

class baexml_Decoder_StdStringContext;      // proxy context
class baexml_Decoder_StdVectorCharContext;  // proxy context

                     // =====================================
                     // class baexml_Decoder_ListParser<TYPE>
                     // =====================================

template <typename TYPE>
class baexml_Decoder_ListParser {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This is a wrapper around 'baexml_ListParser<TYPE>'.  The
    // 'baexml_Decoder_PushParserContext' class needs a default constructible
    // push parser.  However, 'baexml_ListParser<TYPE>' is not default
    // constructible - it requires an 'parseElementCallback'.  This wrapper
    // provides a default constructor that passes
    // 'baexml_TypesParserUtil::parseDefault' as the callback.

    // PRIVATE TYPES
    typedef typename
    baexml_ListParser<TYPE>::ParseElementFunction ParseElementFunction;
    typedef typename
    baexml_ListParser<TYPE>::ParseElementCallback ParseElementCallback;

    // DATA
    baexml_ListParser<TYPE> d_imp;  // implementation object

  private:
    // NOT IMPLEMENTED
    baexml_Decoder_ListParser(const baexml_Decoder_ListParser&);
    baexml_Decoder_ListParser& operator=(const baexml_Decoder_ListParser&);

    // COMPILER BUG WORKAROUNDS
    static ParseElementCallback convert(ParseElementFunction func)
        // This function is provided to work around a bug in the AIX compiler.
        // It incorrectly complains that the following constructor initializer
        // list for 'd_imp' is invalid:
        //..
        // : d_imp((ParseElementFunction)&baexml_TypesParserUtil::parseDefault)
        //..
        // The error message generated by the AIX compiler is:
        //..
        // An object of type "BloombergLP::baexml_ListParser<TYPE>" cannot be
        // constructed from an rvalue of type "ParseElementFunction".
        //..
        // To work around this, an explicit 'convert' function is used to aid
        // the conversion.
    {
        ParseElementCallback temp(func);
        return temp;
    }

  public:
    // CREATORS
    baexml_Decoder_ListParser()
    : d_imp(convert(&baexml_TypesParserUtil::parseDefault))
    {
    }

    // Using destructor generated by compiler:
    // ~baexml_Decoder_ListParser();

    // MANIPULATORS
    int beginParse(TYPE *object)
    {
        return d_imp.beginParse(object);
    }

    int endParse()
    {
        return d_imp.endParse();
    }

    template <typename INPUT_ITERATOR>
    int pushCharacters(INPUT_ITERATOR begin, INPUT_ITERATOR end)
    {
        return d_imp.pushCharacters(begin, end);
    }
};

                // ==============================================
                // struct baexml_Decoder_InstantiateContext<TYPE>
                // ==============================================

template <typename CATEGORY, typename TYPE>
struct baexml_Decoder_InstantiateContext;
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This 'struct' instantiates a context for the parameterized 'TYPE' that
    // falls under the parameterized 'CATEGORY'.

template <typename TYPE>
struct baexml_Decoder_InstantiateContext<bdeat_TypeCategory::Array, TYPE>
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef baexml_Decoder_PushParserContext<TYPE,
                                        baexml_Decoder_ListParser<TYPE> > Type;
};

template <>
struct baexml_Decoder_InstantiateContext<bdeat_TypeCategory::Array,
                                      bsl::vector<char> >
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef baexml_Decoder_StdVectorCharContext Type;
};

template <typename TYPE>
struct baexml_Decoder_InstantiateContext<bdeat_TypeCategory::Choice, TYPE>
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef baexml_Decoder_ChoiceContext<TYPE> Type;
};

template <typename TYPE>
struct baexml_Decoder_InstantiateContext<bdeat_TypeCategory::Sequence, TYPE>
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef baexml_Decoder_SequenceContext<TYPE> Type;
};

template <typename TYPE>
struct baexml_Decoder_InstantiateContext<bdeat_TypeCategory::Simple, TYPE>
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef baexml_Decoder_SimpleContext<TYPE> Type;
};

template <>
struct
baexml_Decoder_InstantiateContext<bdeat_TypeCategory::Simple, bsl::string>
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef baexml_Decoder_StdStringContext Type;
};

template <typename TYPE>
struct
baexml_Decoder_InstantiateContext<bdeat_TypeCategory::CustomizedType, TYPE>
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Note: Customized are treated as simple types (i.e., they are parsed by
    // 'baexml_TypesParserUtil').
    typedef baexml_Decoder_CustomizedContext<TYPE> Type;
};

template <typename TYPE>
struct baexml_Decoder_InstantiateContext<bdeat_TypeCategory::Enumeration, TYPE>
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Note: Enums are treated as simple types (i.e., they are parsed by
    // 'baexml_TypesParserUtil').

    typedef baexml_Decoder_SimpleContext<TYPE> Type;
};

                   // ========================================
                   // struct baexml_Decoder_SelectContext<TYPE>
                   // ========================================

template <typename TYPE>
struct baexml_Decoder_SelectContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This meta-function is used to select a context for the parameterized
    // 'TYPE'.

  private:
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

  public:
    typedef typename
    baexml_Decoder_InstantiateContext<TypeCategory, TYPE>::Type Type;
};

                   // ========================================
                   // class baexml_Decoder_ChoiceContext<TYPE>
                   // ========================================

template <typename TYPE>
class baexml_Decoder_ChoiceContext :  public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This is the context for types that fall under
    // 'bdeat_TypeCategory::Choice'.

    // DATA
    bool         d_isSelectionMade;
    TYPE        *d_object_p;
    bool         d_selectionIsRepeatable;
    bsl::string  d_selectionName;

    // NOT IMPLEMENTED
    baexml_Decoder_ChoiceContext(const baexml_Decoder_ChoiceContext&);
    baexml_Decoder_ChoiceContext& operator=(
                                 const baexml_Decoder_ChoiceContext&);

  public:
    // CREATORS
    baexml_Decoder_ChoiceContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    // ~baexml_Decoder_ChoiceContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                     // ====================================
                     // class baexml_Decoder_NillableContext
                     // ====================================

class baexml_Decoder_NillableContext :  public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Context for elements that have
    // 'bdeat_FormattingMode::BDEAT_NILLABLE'.  It acts as a proxy and
    // forwards all callbacks to the held 'd_elementContext_p'.  If
    // 'endElement' is called directly after 'startElement', then the
    // 'isNil()' accessor will return true.

    // DATA
    baexml_Decoder_ElementContext *d_elementContext_p;
    bool                           d_isNil;

    // NOT IMPLEMENTED
    baexml_Decoder_NillableContext(const baexml_Decoder_NillableContext&);
    baexml_Decoder_NillableContext& operator=(
                                   const baexml_Decoder_NillableContext&);

  public:
    // CREATORS
    baexml_Decoder_NillableContext();

    ~baexml_Decoder_NillableContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);

    // MANIPULATORS
    void setElementContext(baexml_Decoder_ElementContext *elementContext);
        // Set the element context to the specified 'elementContext'.  The
        // behavior of all methods in this class are undefined if this method
        // has not been called.

    // ACCESSORS
    bool isNil() const;
        // Return 'true' if the element is nil.
};

             // ====================================================
             // class baexml_Decoder_PushParserContext<TYPE, PARSER>
             // ====================================================

template <typename TYPE, typename PARSER>
class baexml_Decoder_PushParserContext : public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Context for types that use one of the following push parsers:
    //..
    //    o baexml_Base64Parser
    //    o baexml_HexParser
    //    o baexml_Decoder_ListParser
    //..

    // DATA
    int     d_formattingMode;
    TYPE   *d_object_p;
    PARSER  d_parser;

    // NOT IMPLEMENTED
    baexml_Decoder_PushParserContext(const baexml_Decoder_PushParserContext&);
    baexml_Decoder_PushParserContext& operator=(
                                     const baexml_Decoder_PushParserContext&);

  public:
    // CREATORS
    baexml_Decoder_PushParserContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    // ~baexml_Decoder_PushParserContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                  // ==========================================
                  // class baexml_Decoder_SequenceContext<TYPE>
                  // ==========================================

template <typename TYPE>
class baexml_Decoder_SequenceContext : public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Context for types that fall under 'bdeat_TypeCategory::Sequence'.

    // DATA
    bdeut_NullableValue<int>  d_simpleContentId;
    TYPE                     *d_object_p;

    // NOT IMPLEMENTED
    baexml_Decoder_SequenceContext(const baexml_Decoder_SequenceContext&);
    baexml_Decoder_SequenceContext& operator=(
                                   const baexml_Decoder_SequenceContext&);

  public:
    // CREATORS
    baexml_Decoder_SequenceContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    // ~baexml_Decoder_SequenceContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                   // ========================================
                   // class baexml_Decoder_SimpleContext<TYPE>
                   // ========================================

template <typename TYPE>
class baexml_Decoder_SimpleContext : public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Context for simple types (uses baexml_TypesParserUtil).

    // DATA
    //bsl::string  d_chars;
    int            d_formattingMode;
    TYPE          *d_object_p;

    // NOT IMPLEMENTED
    baexml_Decoder_SimpleContext(const baexml_Decoder_SimpleContext&);
    baexml_Decoder_SimpleContext&
    operator=(const baexml_Decoder_SimpleContext&);

  public:
    // CREATORS
    baexml_Decoder_SimpleContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    // ~baexml_Decoder_SimpleContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                   // ============================================
                   // class baexml_Decoder_CustomizedContext<TYPE>
                   // ============================================

template <typename TYPE>
class baexml_Decoder_CustomizedContext : public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This is the context for types that fall under
    // 'bdeat_TypeCategory::Customized'.

    typedef typename
    bdeat_CustomizedTypeFunctions::BaseType<TYPE>::Type BaseType;

    typedef typename
    baexml_Decoder_InstantiateContext<bdeat_TypeCategory::Simple,
                                      BaseType>::Type BaseContext;
    // DATA
    TYPE       *d_object;
    BaseType    d_baseObj;
    BaseContext d_baseContext;

    // NOT IMPLEMENTED
    baexml_Decoder_CustomizedContext(const baexml_Decoder_CustomizedContext&);
    baexml_Decoder_CustomizedContext& operator=(
                                     const baexml_Decoder_CustomizedContext&);

  public:
    // CREATORS
    baexml_Decoder_CustomizedContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    // ~baexml_Decoder_CustomizedContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char    *chars,
                              unsigned int   length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                  // ==========================================
                  // class baexml_Decoder_UnknownElementContext
                  // ==========================================

class baexml_Decoder_UnknownElementContext :
                                         public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Context for unknown elements.  This context is used when an unknown
    // element is found, and the user selected.

  private:
    // NOT IMPLEMENTED
    baexml_Decoder_UnknownElementContext(
                                  const baexml_Decoder_UnknownElementContext&);
    baexml_Decoder_UnknownElementContext& operator=(
                                  const baexml_Decoder_UnknownElementContext&);

  public:
    // CREATORS
    baexml_Decoder_UnknownElementContext();

    // Using compiler generated destructor:
    // ~baexml_Decoder_UnknownElementContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                       // ================================
                       // class baexml_Decoder_UTF8Context
                       // ================================

template <typename TYPE>
class baexml_Decoder_UTF8Context : public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Context for UTF8 strings (i.e., 'bsl::string' and 'bsl::vector<char>').

    // DATA
    TYPE *d_object_p;

    // NOT IMPLEMENTED
    baexml_Decoder_UTF8Context(const baexml_Decoder_UTF8Context&);
    baexml_Decoder_UTF8Context& operator=(const baexml_Decoder_UTF8Context&);

  public:
    // CREATORS
    baexml_Decoder_UTF8Context(TYPE *object, int formattingMode);

    // Generated by compiler:
    // ~baexml_Decoder_UTF8Context();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                     // =====================================
                     // class baexml_Decoder_StdStringContext
                     // =====================================

class baexml_Decoder_StdStringContext : public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Proxy context for 'bsl::string'.  This is just a proxy context.  It will
    // forward all callbacks to the appropriate context, based on the
    // formatting mode.

  public:
    // TYPES
    // Note that these typedefs need to be made public because Sun compiler
    // complains that they are inaccessible from the union (below).
    typedef baexml_Decoder_PushParserContext<bsl::string,
                                          baexml_Base64Parser<bsl::string> >
                                                                Base64Context;
    typedef baexml_Decoder_PushParserContext<bsl::string,
                                          baexml_HexParser<bsl::string> >
                                                                HexContext;
    typedef baexml_Decoder_UTF8Context<bsl::string>             UTF8Context;

  private:
    // DATA
    union {
        bsls_ObjectBuffer<Base64Context> d_base64Context;
        bsls_ObjectBuffer<HexContext>    d_hexContext;
        bsls_ObjectBuffer<UTF8Context>   d_utf8Context;
    };

    baexml_Decoder_ElementContext *d_context_p;

    // NOT IMPLEMENTED
    baexml_Decoder_StdStringContext(const baexml_Decoder_StdStringContext&);
    baexml_Decoder_StdStringContext& operator=(
                                    const baexml_Decoder_StdStringContext&);

  public:
    // CREATORS
    baexml_Decoder_StdStringContext(bsl::string *object, int formattingMode);

    virtual ~baexml_Decoder_StdStringContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                   // =========================================
                   // class baexml_Decoder_StdVectorCharContext
                   // =========================================

class baexml_Decoder_StdVectorCharContext :
                                         public baexml_Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Proxy context for 'bsl::string'.  This is just a proxy context.  It will
    // forward all callbacks to the appropriate context, based on the
    // formatting mode.

  public:
    // TYPES
    // Note that these typedefs need to be made public because Sun compiler
    // complains that they are inaccessible from the union (below).
    typedef baexml_Decoder_PushParserContext<
                                      bsl::vector<char>,
                                      baexml_Base64Parser<bsl::vector<char> > >
                                                                 Base64Context;
    typedef baexml_Decoder_PushParserContext<
                                         bsl::vector<char>,
                                         baexml_HexParser<bsl::vector<char> > >
                                                                 HexContext;
    typedef
    baexml_Decoder_PushParserContext<
                                bsl::vector<char>,
                                baexml_Decoder_ListParser<bsl::vector<char> > >
                                                                 ListContext;
    typedef baexml_Decoder_UTF8Context<bsl::vector<char> >       UTF8Context;

  private:
    // DATA
    union {
        bsls_ObjectBuffer<Base64Context> d_base64Context;
        bsls_ObjectBuffer<HexContext>    d_hexContext;
        bsls_ObjectBuffer<ListContext>   d_listContext;
        bsls_ObjectBuffer<UTF8Context>   d_utf8Context;
    };

    baexml_Decoder_ElementContext *d_context_p;

    // NOT IMPLEMENTED
    baexml_Decoder_StdVectorCharContext(
                                   const baexml_Decoder_StdVectorCharContext&);
    baexml_Decoder_StdVectorCharContext& operator=(
                                   const baexml_Decoder_StdVectorCharContext&);

  public:
    // CREATORS
    baexml_Decoder_StdVectorCharContext(bsl::vector<char> *object,
                                        int                formattingMode);

    virtual ~baexml_Decoder_StdVectorCharContext();

    // CALLBACKS
    virtual int startElement(baexml_Decoder *decoder);

    virtual int endElement(baexml_Decoder *decoder);

    virtual int addCharacters(const char     *chars,
                              unsigned int    length,
                              baexml_Decoder *decoder);

    virtual int parseAttribute(const char     *name,
                               const char     *value,
                               bsl::size_t     lenValue,
                               baexml_Decoder *decoder);

    virtual int parseSubElement(const char     *elementName,
                                baexml_Decoder *decoder);
};

                  // ===========================================
                  // class baexml_Decoder_PrepareSequenceContext
                  // ===========================================

class baexml_Decoder_PrepareSequenceContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This class does one thing:
    //..
    //  o finds an element that has the 'IS_SIMPLE_CONTENT' flag set
    //..

    // DATA
    bdeut_NullableValue<int> *d_simpleContentId_p; // held, not owned

    // NOT IMPLEMENTED
    baexml_Decoder_PrepareSequenceContext(
                                 const baexml_Decoder_PrepareSequenceContext&);
    baexml_Decoder_PrepareSequenceContext& operator=(
                                 const baexml_Decoder_PrepareSequenceContext&);

  public:
    // CREATORS
    baexml_Decoder_PrepareSequenceContext(
                                    bdeut_NullableValue<int> *simpleContentId);

    // Using compiler generated destructor:
    // ~baexml_Decoder_PrepareSequenceContext();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(const TYPE&      object,
                   const INFO_TYPE& info);
};

                // ===============================================
                // class baexml_Decoder_ParseSequenceSimpleContent
                // ===============================================

class baexml_Decoder_ParseSequenceSimpleContent {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Parse simple content.

    // DATA
    //const bsl::string *d_chars_p;  // content characters
    const char          *d_chars_p;  // content characters
    bsl::size_t          d_len;
    baexml_Decoder      *d_decoder;  // error logger (held)

    // NOT IMPLEMENTED
    baexml_Decoder_ParseSequenceSimpleContent(
                             const baexml_Decoder_ParseSequenceSimpleContent&);
    baexml_Decoder_ParseSequenceSimpleContent& operator=(
                             const baexml_Decoder_ParseSequenceSimpleContent&);

  public:
    // CREATORS
    baexml_Decoder_ParseSequenceSimpleContent(baexml_Decoder *decoder,
                                           const char        *chars,
                                           bsl::size_t        len);
                                           //const bsl::string         *chars);

    // Generated by compiler:
    // ~baexml_Decoder_ParseSequenceSimpleContent();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(TYPE *object, const INFO_TYPE& info);

    template <typename INFO_TYPE>
    int operator()(bsl::string *object, const INFO_TYPE& info);
};

                 // ============================================
                 // class baexml_Decoder_ParseSequenceSubElement
                 // ============================================

class baexml_Decoder_ParseSequenceSubElement {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // This is similar to 'baexml_Decoder_ParseObject'.

    // DATA
    baexml_Decoder *d_decoder;        // held, not owned
    const char     *d_elementName_p;  // held, not owned
    bsl::size_t     d_lenName;

    // NOT IMPLEMENTED
    baexml_Decoder_ParseSequenceSubElement(
                                const baexml_Decoder_ParseSequenceSubElement&);
    baexml_Decoder_ParseSequenceSubElement& operator=(
                                const baexml_Decoder_ParseSequenceSubElement&);

  public:
    // CREATORS
    baexml_Decoder_ParseSequenceSubElement(
                                     baexml_Decoder  *decoder,
                                     const char      *elementName,
                                     bsl::size_t      lenName);

    // Using compiler-generated destructor:
    // ~baexml_Decoder_ParseSequenceSubElement();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(TYPE             *object,
                   const INFO_TYPE&  info);

    template <typename TYPE>
    int execute(TYPE *object, int id, int formattingMode);
};

                      // ===================================
                      // class baexml_Decoder_ParseAttribute
                      // ===================================

class baexml_Decoder_ParseAttribute {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Parse an attribute.

    // DATA
    baexml_Decoder *d_decoder;     // error logger (held)
    bool            d_failed;      // set to true if parsing failed

    const char     *d_name_p;      // attribute name (held)
    const char     *d_value_p;     // attribute value (held)
    bsl::size_t     d_value_length;

  public:
    // IMPLEMENTATION MANIPULATORS
    template <typename TYPE>
    int executeImp(TYPE *object, int formattingMode,
                   bdeat_TypeCategory::NullableValue);
    template <typename TYPE>
    int executeImp(TYPE *object, int formattingMode,
                   bdeat_TypeCategory::DynamicType);
    template <typename TYPE, typename ANY_CATEGORY>
    int executeImp(TYPE *object, int formattingMode, ANY_CATEGORY);

  private:
    // NOT IMPLEMENTED
    baexml_Decoder_ParseAttribute(const baexml_Decoder_ParseAttribute&);
    baexml_Decoder_ParseAttribute&
    operator=(const baexml_Decoder_ParseAttribute&);

  public:
    // CREATORS
    baexml_Decoder_ParseAttribute(baexml_Decoder *decoder,
                                  const char     *name,
                                  const char     *value,
                                  bsl::size_t     lengthValue);

    // Generated by compiler:
    // ~baexml_Decoder_ParseAttribute();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(TYPE *object, const INFO_TYPE& info);

    template <typename TYPE>
    int execute(TYPE *object, int formattingMode);

    // ACCESSORS
    bool failed() const;
};

                       // ================================
                       // class baexml_Decoder_ParseObject
                       // ================================

class baexml_Decoder_ParseObject {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    // Parse the visited object.

    // PRIVATE TYPES
    struct CanBeListOrRepetition { };
    struct CanBeRepetitionOnly   { };

    // DATA
    baexml_Decoder *d_decoder;        // held, not owned
    const char     *d_elementName_p;  // held, not owned
    bsl::size_t     d_lenName;

    // NOT IMPLEMENTED
    baexml_Decoder_ParseObject(const baexml_Decoder_ParseObject&);
    baexml_Decoder_ParseObject& operator=(const baexml_Decoder_ParseObject&);

  public:
    // IMPLEMENTATION MANIPULATORS
    int executeImp(bsl::vector<char> *object, int formattingMode,
                   bdeat_TypeCategory::Array);

    template <typename TYPE>
    int executeImp(bsl::vector<TYPE> *object, int formattingMode,
                   bdeat_TypeCategory::Array);

    template <typename TYPE>
    int executeImp(TYPE *object, int formattingMode,
                   bdeat_TypeCategory::Array);

    template <typename TYPE>
    int executeImp(TYPE *object, int formattingMode,
                   bdeat_TypeCategory::Sequence);

    template <typename TYPE>
    int executeImp(TYPE *object, int formattingMode,
                   bdeat_TypeCategory::Choice);

    template <typename TYPE>
    int executeImp(TYPE *object, int formattingMode,
                   bdeat_TypeCategory::NullableValue);

    template <typename TYPE>
    int executeImp(TYPE *object, int formattingMode,
                   bdeat_TypeCategory::CustomizedType);

    template <typename TYPE>
    int executeImp(TYPE *object, int formattingMode,
                   bdeat_TypeCategory::DynamicType);

    template <typename TYPE, typename ANY_CATEGORY>
    int executeImp(TYPE *object, int formattingMode,
                   ANY_CATEGORY);

    template <typename TYPE>
    int executeArrayImp(TYPE *object, int formattingMode,
                        CanBeListOrRepetition);

    template <typename TYPE>
    int executeArrayImp(TYPE *object, int formattingMode,
                        CanBeRepetitionOnly);

    template <typename TYPE>
    int executeArrayRepetitionImp(TYPE *object, int formattingMode);

  public:
    // CREATORS
    baexml_Decoder_ParseObject(
                            baexml_Decoder *decoder,
                            const char     *elementName,
                            bsl::size_t     lenName);

    // Using compiler-generated destructor:
    // ~baexml_Decoder_ParseObject();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(TYPE             *object,
                   const INFO_TYPE&  info);

    template <typename TYPE>
    int execute(TYPE *object, int formattingMode);
};

                   // ========================================
                   // class baexml_Decoder_ParseNillableObject
                   // ========================================

class baexml_Decoder_ParseNillableObject {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    int                             d_formattingMode;
    baexml_Decoder_NillableContext  d_nillableContext;
    baexml_Decoder                 *d_decoder;

  public:
    // IMPLEMENTATION MANIPULATORS
    template <typename TYPE>
    int executeImp(TYPE *object, bdeat_TypeCategory::DynamicType);

    template <typename TYPE, typename ANY_CATEGORY>
    int executeImp(TYPE *object, ANY_CATEGORY);

  private:
    // NOT IMPLEMENTED
    baexml_Decoder_ParseNillableObject(
        const baexml_Decoder_ParseNillableObject&);
    baexml_Decoder_ParseNillableObject& operator=(
                                    const baexml_Decoder_ParseNillableObject&);

  public:
    baexml_Decoder_ParseNillableObject(baexml_Decoder *decoder,
                                    int                 formattingMode);
        // Construct a functor to parse nillable objects.

    // Using compiler-generated destructor:
    // ~baexml_Decoder_ParseNillableObject();

    // MANIPULATORS
    template <typename TYPE>
    int operator()(TYPE *object);
        // Visit the specified 'object'.

    // ACCESSORS
    bool isNil() const;
        // Return 'true' if the value was nil, and false otherwise.
};

// ============================================================================
//                               PROXY CLASSES
// ============================================================================

                 // ====================================
                 // struct baexml_Decoder_decodeImpProxy
                 // ====================================

struct baexml_Decoder_decodeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    baexml_Decoder *d_decoder;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(TYPE *, bslmf_Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template <typename TYPE, typename ANY_CATEGORY>
    inline
    int operator()(TYPE *object, ANY_CATEGORY category)
    {
        return d_decoder->decodeImp(object, category);
    }
};

         // ============================================================
         // struct baexml_Decoder_PrepareSequenceContext_executeImpProxy
         // ============================================================

struct baexml_Decoder_PrepareSequenceContext_executeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    baexml_Decoder_PrepareSequenceContext *d_instance_p;
    int                                    d_formattingMode;
    int                                    d_id;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(const TYPE&, bslmf_Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template <typename TYPE, typename ANY_CATEGORY>
    inline
    int operator()(const TYPE& object, ANY_CATEGORY category)
    {
        d_instance_p->executeImp(object, d_formattingMode, d_id, category);
        return 0;
    }
};

               // =================================================
               // struct baexml_Decoder_ParseAttribute_executeProxy
               // =================================================

struct baexml_Decoder_ParseAttribute_executeProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    baexml_Decoder_ParseAttribute *d_instance_p;
    int                            d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(TYPE *object)
    {
        return d_instance_p->execute(object, d_formattingMode);
    }
};

             // ====================================================
             // struct baexml_Decoder_ParseAttribute_executeImpProxy
             // ====================================================

struct baexml_Decoder_ParseAttribute_executeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    baexml_Decoder_ParseAttribute *d_instance_p;
    int                            d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(TYPE *, bslmf_Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template <typename TYPE, typename ANY_CATEGORY>
    inline
    int operator()(TYPE *object, ANY_CATEGORY category)
    {
        return d_instance_p->executeImp(object, d_formattingMode, category);
    }
};

                // ==============================================
                // struct baexml_Decoder_ParseObject_executeProxy
                // ==============================================

struct baexml_Decoder_ParseObject_executeProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    baexml_Decoder_ParseObject *d_instance_p;
    int                         d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(TYPE *object)
    {
        return d_instance_p->execute(object, d_formattingMode);
    }
};

               // =================================================
               // struct baexml_Decoder_ParseObject_executeImpProxy
               // =================================================

struct baexml_Decoder_ParseObject_executeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    baexml_Decoder_ParseObject *d_instance_p;
    int                      d_formattingMode;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(TYPE *, bslmf_Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template <typename TYPE, typename ANY_CATEGORY>
    inline
    int operator()(TYPE *object, ANY_CATEGORY category)
    {
        return d_instance_p->executeImp(object, d_formattingMode, category);
    }
};

           // =========================================================
           // struct baexml_Decoder_ParseNillableObject_executeImpProxy
           // =========================================================

struct baexml_Decoder_ParseNillableObject_executeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    baexml_Decoder_ParseNillableObject *d_instance_p;

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // FUNCTIONS
    template <typename TYPE>
    inline
    int operator()(TYPE *, bslmf_Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template <typename TYPE, typename ANY_CATEGORY>
    inline
    int operator()(TYPE *object, ANY_CATEGORY category)
    {
        return d_instance_p->executeImp(object, category);
    }
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                         // ----------------------------------
                         // class baexml_Decoder::MemOutStream
                         // ----------------------------------

inline
baexml_Decoder::MemOutStream::MemOutStream(bslma_Allocator *basicAllocator)
: bsl::ostream(0)
, d_sb(bslma_Default::allocator(basicAllocator))
{
    rdbuf(&d_sb);
}

// MANIPULATORS
inline
void baexml_Decoder::MemOutStream::reset()
{
    d_sb.reset();
}

// ACCESSORS
inline
const char *baexml_Decoder::MemOutStream::data() const
{
    return d_sb.data();
}

inline
int baexml_Decoder::MemOutStream::length() const
{
    return (int)d_sb.length();
}

inline
void baexml_Decoder::setNumUnknownElementsSkipped(int value)
{
    BSLS_ASSERT_SAFE(0 <= value);

    d_numUnknownElementsSkipped = value;
}

                             // --------------------
                             // class baexml_Decoder
                             // --------------------

inline
const baexml_DecoderOptions *baexml_Decoder::options() const
{
    return d_options;
}

inline
baexml_Reader *baexml_Decoder::reader() const
{
    return d_reader;
}

inline
baexml_ErrorInfo *baexml_Decoder::errorInfo() const
{
    return d_errorInfo;
}

inline
bsl::ostream *baexml_Decoder::errorStream() const
{
    return d_errorStream;
}

inline
int baexml_Decoder::numUnknownElementsSkipped() const
{
    return d_numUnknownElementsSkipped;
}

inline
bsl::ostream *baexml_Decoder::warningStream() const
{
    return d_warningStream;
}

inline
int baexml_Decoder::errorCount() const
{
    return d_errorCount;
}

inline
int baexml_Decoder::warningCount() const
{
    return d_warningCount;
}

inline
int baexml_Decoder::open(bsl::istream& stream, const char *uri)
{
    return open(stream.rdbuf(), uri);
}

template <typename TYPE>
bsl::istream& baexml_Decoder::decode(bsl::istream&  stream,
                                     TYPE          *object,
                                     const char    *uri)
{
    if (!stream.good()) {

        BAEXML_DECODER_LOG_ERROR(this)
                << "The input stream is invalid. "
                << "Unable to decode XML object. "
                << BAEXML_DECODER_LOG_END;

        return stream;
    }

    if (0 != this->decode(stream.rdbuf(), object, uri)) {
        stream.setstate(bsl::ios_base::failbit);
    }

    return stream;
}

template <typename TYPE>
int
baexml_Decoder::decode(bsl::streambuf *buffer, TYPE *object, const char *uri)
{
    if (this->open(buffer, uri) != 0) {

        return this->errorCount();

    }

    int ret = this->decode(object);

    switch(errorSeverity()) {
      case baexml_ErrorInfo::BAEXML_NO_ERROR:
        break;
      case baexml_ErrorInfo::BAEXML_WARNING:
        if (d_warningStream) {
            *d_warningStream << loggedMessages();
        }
        break;
      default:
        if (d_errorStream) {
            *d_errorStream << loggedMessages();
        }
        break;
    }

    this->close();
    return ret;
}

template <typename TYPE>
int baexml_Decoder::decode(const char  *buffer,
                           bsl::size_t  buflen,
                           TYPE        *object,
                           const char  *uri)
{
    if (this->open(buffer, buflen, uri) != 0) {

        return this->errorCount();
    }

    int ret = this->decode(object);
    this->close();
    return ret;
}

template <typename TYPE>
int baexml_Decoder::decode(const char *filename, TYPE *object)
{
    if (this->open(filename) != 0) {

        return this->errorCount();
    }

    int ret = this->decode(object);
    this->close();
    return ret;
}

template <typename TYPE>
inline
int baexml_Decoder::decode(TYPE *object)
{
    bdeat_ValueTypeFunctions::reset(object);

    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    this->decodeImp(object, TypeCategory());

    return this->errorCount();
}

template <typename TYPE>
inline
int baexml_Decoder::decodeImp(TYPE *object,
                              bdeat_TypeCategory::DynamicType)
{
    baexml_Decoder_decodeImpProxy proxy = { this };
    return bdeat_TypeCategoryUtil::manipulateByCategory(object, proxy);
}

template <typename TYPE, typename ANY_CATEGORY>
inline
int baexml_Decoder::decodeImp(TYPE *object, ANY_CATEGORY)
{
    typedef typename
    baexml_Decoder_InstantiateContext<ANY_CATEGORY, TYPE>::Type ContextType;

    ContextType elementContext(object, d_options->formattingMode());

    return elementContext.beginParse(this);
}

                   // ----------------------------------------
                   // class baexml_Decoder_ChoiceContext<TYPE>
                   // ----------------------------------------

template <typename TYPE>
inline
baexml_Decoder_ChoiceContext<TYPE>::baexml_Decoder_ChoiceContext(
                                                          TYPE *object,
                                                          int   formattingMode)
: d_isSelectionMade(false)
, d_object_p(object)
, d_selectionIsRepeatable(false)
, d_selectionName()
{
    (void) formattingMode;
    BSLS_ASSERT_SAFE(bdeat_FormattingMode::BDEAT_DEFAULT ==
                     (formattingMode & bdeat_FormattingMode::BDEAT_TYPE_MASK));
}

// CALLBACKS

template <typename TYPE>
int baexml_Decoder_ChoiceContext<TYPE>::startElement(baexml_Decoder *)
{
    enum { BAEXML_SUCCESS = 0 };

    d_isSelectionMade = false;  // no selection seen yet

    return BAEXML_SUCCESS;
}

template <typename TYPE>
int baexml_Decoder_ChoiceContext<TYPE>::endElement(baexml_Decoder *decoder)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    if (!d_isSelectionMade) {
        BAEXML_DECODER_LOG_ERROR(decoder)
                 << "No elements selected in choice."
                 << BAEXML_DECODER_LOG_END;

        return BAEXML_FAILURE;  // will trigger failure in parser
    }

    return BAEXML_SUCCESS;
}

template <typename TYPE>
int baexml_Decoder_ChoiceContext<TYPE>::addCharacters(const char *chars,
                                                   unsigned int length,
                                                   baexml_Decoder *decoder)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    BSLS_ASSERT_SAFE(0 != length);

    const char *begin = chars;
    const char *end   = begin + length;

    bdeu_String::skipLeadingTrailing(&begin, &end);

    if (begin != end) {
        BAEXML_DECODER_LOG_ERROR(decoder)
                         << "Invalid characters \""
                         << bsl::string(begin, end - begin)
                         << "\" when parsing choice."
                         << BAEXML_DECODER_LOG_END;

        return BAEXML_FAILURE;  // will trigger failure in parser
    }

    return BAEXML_SUCCESS;
}

template <typename TYPE>
inline
int baexml_Decoder_ChoiceContext<TYPE>::parseAttribute(const char     *,
                                                       const char     *,
                                                       bsl::size_t     ,
                                                       baexml_Decoder *)
{
    enum { BAEXML_ATTRIBUTE_IGNORED = 0 };

    return BAEXML_ATTRIBUTE_IGNORED;
}

template <typename TYPE>
int baexml_Decoder_ChoiceContext<TYPE>::parseSubElement(
                                                   const char     *elementName,
                                                   baexml_Decoder *decoder)
{
    enum { BAEXML_FAILURE = -1 };

    const int lenName = static_cast<int>(bsl::strlen(elementName));

    if (d_isSelectionMade
     && (!d_selectionIsRepeatable || d_selectionName != elementName))
    {
        BAEXML_DECODER_LOG_ERROR(decoder)
                            << "Only one selection is permitted inside choice."
                            << BAEXML_DECODER_LOG_END;

        return BAEXML_FAILURE;
    }

    if (!d_isSelectionMade) {
        d_isSelectionMade = true;

        if (decoder->options()->skipUnknownElements()
         && false == bdeat_ChoiceFunctions::hasSelection(*d_object_p,
                                                         elementName,
                                                         lenName)) {
            decoder->setNumUnknownElementsSkipped(
                                     decoder->numUnknownElementsSkipped() + 1);
            d_selectionIsRepeatable = true;  // assume repeatable
            d_selectionName.assign(elementName, lenName);

            baexml_Decoder_UnknownElementContext unknownElement;
            return unknownElement.beginParse(decoder);
        }

        if (0 != bdeat_ChoiceFunctions::makeSelection(d_object_p,
                                                      elementName,
                                                      lenName)) {
            BAEXML_DECODER_LOG_ERROR(decoder)
                                              << "Unable to make selection: \""
                                              << elementName
                                              << "\"."
                                              << BAEXML_DECODER_LOG_END;

            return BAEXML_FAILURE;
        }

        d_selectionIsRepeatable = true;  // TBD: check if repeatable
        d_selectionName.assign(elementName, lenName);
    }

    baexml_Decoder_ParseObject parseObject(decoder, elementName, lenName);

    return bdeat_ChoiceFunctions::manipulateSelection(d_object_p, parseObject);
}

             // ----------------------------------------------------
             // class baexml_Decoder_PushParserContext<TYPE, PARSER>
             // ----------------------------------------------------

// CREATORS
template <typename TYPE, typename PARSER>
inline
baexml_Decoder_PushParserContext<TYPE, PARSER>::
                         baexml_Decoder_PushParserContext(TYPE *object,
                                                          int   formattingMode)
: d_formattingMode(formattingMode)
, d_object_p(object)
{
}

// CALLBACKS

template <typename TYPE, typename PARSER>
int baexml_Decoder_PushParserContext<TYPE, PARSER>::startElement(
                                          baexml_Decoder *decoder)
{
    int result = d_parser.beginParse(d_object_p);

    if (0 != result) {
        BAEXML_DECODER_LOG_ERROR(decoder)
                    << "Unable to begin parsing list or binary type"

                    << "\"."
                    << BAEXML_DECODER_LOG_END;
    }

    return result;
}

template <typename TYPE, typename PARSER>
int baexml_Decoder_PushParserContext<TYPE, PARSER>::endElement(
                                          baexml_Decoder *decoder)
{
    int result = d_parser.endParse();

    if (0 != result) {
        BAEXML_DECODER_LOG_ERROR(decoder)
                    << "Unable to end parsing list or binary type"
                    << "\"."
                    << BAEXML_DECODER_LOG_END;
    }

    return result;
}

template <typename TYPE, typename PARSER>
int baexml_Decoder_PushParserContext<TYPE, PARSER>::addCharacters(
                                                       const char     *chars,
                                                       unsigned int    length,
                                                       baexml_Decoder *decoder)
{
    const char *begin = chars;
    const char *end   = begin + length;

    int result = d_parser.pushCharacters(begin, end);

    if (0 != result) {
        BAEXML_DECODER_LOG_ERROR(decoder)
              << "Unable to push \"" << chars
              << "\" when parsing list or binary type"

              << "\"."
              << BAEXML_DECODER_LOG_END;
    }

    return result;
}

template <typename TYPE, typename PARSER>
inline
int baexml_Decoder_PushParserContext<TYPE, PARSER>::parseAttribute(
                                                      const char     *,
                                                      const char     *,
                                                      bsl::size_t     ,
                                                      baexml_Decoder *)
{
    enum { BAEXML_ATTRIBUTE_IGNORED = 0 };

    return BAEXML_ATTRIBUTE_IGNORED;
}

template <typename TYPE, typename PARSER>
int baexml_Decoder_PushParserContext<TYPE, PARSER>::parseSubElement(
                                                   const char     *elementName,
                                                   baexml_Decoder *decoder)
{
    enum { BAEXML_FAILURE = -1 };

    BAEXML_DECODER_LOG_ERROR(decoder)
                  << "Unexpected sub-element \"" << elementName
                  << "\" when parsing list or binary type"
                  << "\"."
                  << BAEXML_DECODER_LOG_END;

    return BAEXML_FAILURE;
}

                  // ------------------------------------------
                  // class baexml_Decoder_SequenceContext<TYPE>
                  // ------------------------------------------

// CREATORS
template <typename TYPE>
inline
baexml_Decoder_SequenceContext<TYPE>::baexml_Decoder_SequenceContext(
                                                          TYPE *object,
                                                          int   formattingMode)
: d_object_p(object)
{
    (void) formattingMode;
    BSLS_ASSERT_SAFE(bdeat_FormattingMode::BDEAT_DEFAULT ==
                     (formattingMode & bdeat_FormattingMode::BDEAT_TYPE_MASK));
}

// CALLBACKS

template <typename TYPE>
int baexml_Decoder_SequenceContext<TYPE>::startElement(
                                          baexml_Decoder *decoder)
{
    //d_chars.clear();

    baexml_Decoder_PrepareSequenceContext prepareSequenceContext(
                                                           &d_simpleContentId);

    int ret = bdeat_SequenceFunctions::accessAttributes(
                                                       *d_object_p,
                                                       prepareSequenceContext);

    if (0 != ret) {
        BAEXML_DECODER_LOG_ERROR(decoder)
                                       << "Unable to prepare sequence context!"
                                       << BAEXML_DECODER_LOG_END;
    }

    return ret;
}

template <typename TYPE>
int baexml_Decoder_SequenceContext<TYPE>::endElement(baexml_Decoder *)
{
    enum { BAEXML_SUCCESS = 0 };

    return BAEXML_SUCCESS;
}

template <typename TYPE>
int baexml_Decoder_SequenceContext<TYPE>::addCharacters(
                                                       const char     *chars,
                                                       unsigned int    length,
                                                       baexml_Decoder *decoder)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    BSLS_ASSERT_SAFE(0 != length);

    if (d_simpleContentId.isNull()) {

        const char *begin = chars;
        const char *end   = begin + length;

        bdeu_String::skipLeadingTrailing(&begin, &end);

        if (begin != end) {
            BAEXML_DECODER_LOG_ERROR(decoder)
                                             << "Unexpected characters: \""
                                             << bsl::string(begin, end - begin)
                                             << "\"."
                                             << BAEXML_DECODER_LOG_END;

            return BAEXML_FAILURE;
        }
        return BAEXML_SUCCESS;
    }

    baexml_Decoder_ParseSequenceSimpleContent parseSimpleContent(decoder,
                                                                 chars,
                                                                 length);

    return bdeat_SequenceFunctions::manipulateAttribute(
                                            d_object_p,
                                            parseSimpleContent,
                                            d_simpleContentId.value());
}

template <typename TYPE>
int baexml_Decoder_SequenceContext<TYPE>::parseAttribute(
                                                      const char     *name,
                                                      const char     *value,
                                                      bsl::size_t     lenValue,
                                                      baexml_Decoder *decoder)
{
    enum { BAEXML_SUCCESS = 0, ATTRIBUTE_IGNORED = 0, BAEXML_FAILURE = -1 };

    const int lenName = static_cast<int>(bsl::strlen(name));

    baexml_Decoder_ParseAttribute visitor(decoder, name, value, lenValue);

    if (0 != bdeat_SequenceFunctions::manipulateAttribute(d_object_p,
                                                          visitor,
                                                          name,
                                                          lenName)) {
        if (visitor.failed()) {
            return BAEXML_FAILURE;
        }
        return ATTRIBUTE_IGNORED;
    }

    return BAEXML_SUCCESS;
}

template <typename TYPE>
int baexml_Decoder_SequenceContext<TYPE>::parseSubElement(
                                                   const char     *elementName,
                                                   baexml_Decoder *decoder)
{
    enum { BAEXML_FAILURE = -1 };

    const int lenName = static_cast<int>(bsl::strlen(elementName));

    if (decoder->options()->skipUnknownElements()
     && false == bdeat_SequenceFunctions::hasAttribute(*d_object_p,
                                                       elementName,
                                                       lenName)) {
        decoder->setNumUnknownElementsSkipped(
                                     decoder->numUnknownElementsSkipped() + 1);
        baexml_Decoder_UnknownElementContext unknownElement;
        return unknownElement.beginParse(decoder);
    }

    baexml_Decoder_ParseSequenceSubElement visitor(decoder,
                                                   elementName,
                                                   lenName);

    return bdeat_SequenceFunctions::manipulateAttribute(d_object_p,
                                                        visitor,
                                                        elementName,
                                                        lenName);
}

                   // ----------------------------------------
                   // class baexml_Decoder_SimpleContext<TYPE>
                   // ----------------------------------------

// CREATORS
template <typename TYPE>
inline
baexml_Decoder_SimpleContext<TYPE>::baexml_Decoder_SimpleContext(
                                                          TYPE *object,
                                                          int   formattingMode)
: d_formattingMode(formattingMode)
, d_object_p(object)
{
}

// CALLBACKS

template <typename TYPE>
int baexml_Decoder_SimpleContext<TYPE>::startElement(baexml_Decoder *)
{
    enum { BAEXML_SUCCESS = 0 };

    //d_chars.clear();

    return BAEXML_SUCCESS;
}

template <typename TYPE>
int baexml_Decoder_SimpleContext<TYPE>::endElement(baexml_Decoder *)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    return BAEXML_SUCCESS;
}

template <typename TYPE>
int baexml_Decoder_SimpleContext<TYPE>::addCharacters(const char     *chars,
                                                      unsigned int    length,
                                                      baexml_Decoder *decoder)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    const char *begin = chars;
    const char *end   = begin + length;

    bdeu_String::skipLeadingTrailing(&begin, &end);

    if (0 != baexml_TypesParserUtil::parse(d_object_p,
                                           begin,
                                           static_cast<int>(end - begin),
                                           d_formattingMode)) {
        BAEXML_DECODER_LOG_ERROR(decoder)
                    << "Unable to parse \""
                    << bsl::string(begin, end)
                    << "\" when parsing list or binary type"
                    << "\".\n"
                    << BAEXML_DECODER_LOG_END;

        return BAEXML_FAILURE;
    }

    return BAEXML_SUCCESS;
}

template <typename TYPE>
inline
int baexml_Decoder_SimpleContext<TYPE>::parseAttribute(
                                                      const char     *,
                                                      const char     *,
                                                      bsl::size_t     ,
                                                      baexml_Decoder *)
{
    enum { ATTRIBUTE_IGNORED = 0 };

    return ATTRIBUTE_IGNORED;
}

template <typename TYPE>
int baexml_Decoder_SimpleContext<TYPE>::parseSubElement(
                                                   const char     *elementName,
                                                   baexml_Decoder *decoder)
{
    enum { BAEXML_FAILURE = -1 };

    BAEXML_DECODER_LOG_ERROR(decoder)
               << "Attempted to create sub context for \""
               << elementName << "\" inside simple type"

               << "\"."
               << BAEXML_DECODER_LOG_END;

    return BAEXML_FAILURE;  // will trigger failure in parser
}

                   // --------------------------------------------
                   // class baexml_Decoder_CustomizedContext<TYPE>
                   // --------------------------------------------

// CREATORS
template <typename TYPE>
inline
baexml_Decoder_CustomizedContext<TYPE>::baexml_Decoder_CustomizedContext(
                                                          TYPE *object,
                                                          int   formattingMode)
: d_object (object)
, d_baseObj()
, d_baseContext(&d_baseObj, formattingMode)
{
}

// CALLBACKS

template <typename TYPE>
int baexml_Decoder_CustomizedContext<TYPE>::startElement(
                                                       baexml_Decoder *decoder)
{
    return d_baseContext.startElement (decoder);
}

template <typename TYPE>
int baexml_Decoder_CustomizedContext<TYPE>::endElement(
                                          baexml_Decoder *decoder)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };
    int rc = d_baseContext.endElement(decoder);
    if (rc == BAEXML_SUCCESS
     &&  0 == bdeat_CustomizedTypeFunctions::convertFromBaseType(d_object,
                                                                 d_baseObj)) {
        return BAEXML_SUCCESS;
    }

    return BAEXML_FAILURE;
}

template <typename TYPE>
int baexml_Decoder_CustomizedContext<TYPE>::addCharacters(const char *chars,
                                          unsigned int length,
                                          baexml_Decoder *decoder)
{
    return d_baseContext.addCharacters(chars, length, decoder);
}

template <typename TYPE>
int baexml_Decoder_CustomizedContext<TYPE>::parseAttribute(
                                                      const char     *name,
                                                      const char     *value,
                                                      bsl::size_t     lenValue,
                                                      baexml_Decoder *decoder)
{
    return d_baseContext.parseAttribute(name, value, lenValue, decoder);
}

template <typename TYPE>
int baexml_Decoder_CustomizedContext<TYPE>::parseSubElement(
                                                   const char     *elementName,
                                                   baexml_Decoder *decoder)
{
    return d_baseContext.parseSubElement(elementName, decoder);
}

                       // --------------------------------
                       // class baexml_Decoder_UTF8Context
                       // --------------------------------

// CREATORS
template <typename TYPE>
inline
baexml_Decoder_UTF8Context<TYPE>::baexml_Decoder_UTF8Context(TYPE *object,
                                                             int   )
: d_object_p(object)
{
}

// CALLBACKS

template <typename TYPE>
inline
int baexml_Decoder_UTF8Context<TYPE>::startElement(baexml_Decoder *)
{
    enum { BAEXML_SUCCESS = 0 };

    d_object_p->clear();

    return BAEXML_SUCCESS;
}

template <typename TYPE>
inline
int baexml_Decoder_UTF8Context<TYPE>::endElement(baexml_Decoder *)
{
    enum { BAEXML_SUCCESS = 0 };

    return BAEXML_SUCCESS;
}

template <typename TYPE>
inline
int baexml_Decoder_UTF8Context<TYPE>::addCharacters(const char *chars,
                                          unsigned int length,
                                          baexml_Decoder *)
{
    enum { BAEXML_SUCCESS = 0 };

    d_object_p->insert(d_object_p->end(), chars, chars + length);

    return BAEXML_SUCCESS;
}

template <typename TYPE>
inline
int baexml_Decoder_UTF8Context<TYPE>::parseAttribute(const char     *,
                                                     const char     *,
                                                     bsl::size_t     ,
                                                     baexml_Decoder *)
{
    enum { BAEXML_ATTRIBUTE_IGNORED = 0 };

    return BAEXML_ATTRIBUTE_IGNORED;
}

template <typename TYPE>
int baexml_Decoder_UTF8Context<TYPE>::parseSubElement(
                                                   const char     *elementName,
                                                   baexml_Decoder *decoder)
{
    enum { BAEXML_FAILURE = -1 };

    BAEXML_DECODER_LOG_ERROR(decoder)
                                    << "Attempted to create sub context for \""
                                    << elementName << "\" inside UTF8 type."
                                    << BAEXML_DECODER_LOG_END;

    return BAEXML_FAILURE;  // will trigger failure in parser
}

                  // -------------------------------------------
                  // class baexml_Decoder_PrepareSequenceContext
                  // -------------------------------------------

// CREATORS
inline
baexml_Decoder_PrepareSequenceContext::baexml_Decoder_PrepareSequenceContext(
                                     bdeut_NullableValue<int> *simpleContentId)
: d_simpleContentId_p(simpleContentId)
{
    d_simpleContentId_p->reset();
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
int baexml_Decoder_PrepareSequenceContext::operator()(const TYPE&      object,
                                                      const INFO_TYPE& info)
{
    enum { BAEXML_SUCCESS = 0 };

    if (info.formattingMode() & bdeat_FormattingMode::BDEAT_SIMPLE_CONTENT) {
        BSLS_ASSERT_SAFE(d_simpleContentId_p->isNull());
        d_simpleContentId_p->makeValue(info.id());
    }

    return BAEXML_SUCCESS;
}

                // -----------------------------------------------
                // class baexml_Decoder_ParseSequenceSimpleContent
                // -----------------------------------------------

// CREATORS
inline
baexml_Decoder_ParseSequenceSimpleContent::
         baexml_Decoder_ParseSequenceSimpleContent(baexml_Decoder     *decoder,
                                                   const char         *chars,
                                                   bsl::size_t         len)
: d_chars_p(chars)
, d_len(len)
, d_decoder(decoder)
{
    BSLS_ASSERT_SAFE(d_chars_p);
    BSLS_ASSERT_SAFE(d_decoder);
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
int baexml_Decoder_ParseSequenceSimpleContent::operator()(
                                                      TYPE             *object,
                                                      const INFO_TYPE&  info)
{
    BSLS_ASSERT_SAFE(info.formattingMode()
                                 & bdeat_FormattingMode::BDEAT_SIMPLE_CONTENT);

    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    const char *begin = d_chars_p;
    const char *end   = begin + d_len;

    bdeu_String::skipLeadingTrailing(&begin, &end);

    if (0 != baexml_TypesParserUtil::parse(object,
                                           begin,
                                           static_cast<int>(end - begin),
                                           info.formattingMode())) {
        BAEXML_DECODER_LOG_ERROR(d_decoder)
               << "Unable to parse \""
               << bsl::string(begin, end)
               << "\" within simple content"

               << "\"."
               << BAEXML_DECODER_LOG_END;

        return BAEXML_FAILURE;
    }

    return BAEXML_SUCCESS;
}

template <typename INFO_TYPE>
inline
int baexml_Decoder_ParseSequenceSimpleContent::operator()(
                                                      bsl::string      *object,
                                                      const INFO_TYPE&  info)
{
    enum { BAEXML_SUCCESS = 0 };

    BSLS_ASSERT_SAFE(info.formattingMode()
                   & bdeat_FormattingMode::BDEAT_SIMPLE_CONTENT);

    (void) info;

    object->assign(d_chars_p, d_len);

    return BAEXML_SUCCESS;
}

                 // --------------------------------------------
                 // class baexml_Decoder_ParseSequenceSubElement
                 // --------------------------------------------

// CREATORS
inline
baexml_Decoder_ParseSequenceSubElement::baexml_Decoder_ParseSequenceSubElement(
                                                 baexml_Decoder *decoder,
                                                 const char     *elementName,
                                                 bsl::size_t     lenName)
: d_decoder(decoder)
, d_elementName_p(elementName)
, d_lenName(lenName)
{
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
inline
int baexml_Decoder_ParseSequenceSubElement::operator()(
                                                      TYPE             *object,
                                                      const INFO_TYPE&  info)
{
    return execute(object, info.id(), info.formattingMode());
}

template <typename TYPE>
int baexml_Decoder_ParseSequenceSubElement::execute(TYPE *object,
                                                    int   ,
                                                    int   formattingMode)
{
    enum { BAEXML_FAILURE = -1 };
    baexml_Decoder_ParseObject parseObject(d_decoder,
                                           d_elementName_p,
                                           d_lenName);

    return parseObject.execute(object, formattingMode);
}

                      // -----------------------------------
                      // class baexml_Decoder_ParseAttribute
                      // -----------------------------------

// PRIVATE MANIPULATORS
template <typename TYPE>
int baexml_Decoder_ParseAttribute::executeImp(TYPE *object, int formattingMode,
                                           bdeat_TypeCategory::NullableValue)
{
    if (bdeat_NullableValueFunctions::isNull(*object)) {
        bdeat_NullableValueFunctions::makeValue(object);
    }

    baexml_Decoder_ParseAttribute_executeProxy proxy = {
        this, formattingMode
    };

    return bdeat_NullableValueFunctions::manipulateValue(object, proxy);
}

template <typename TYPE>
inline
int baexml_Decoder_ParseAttribute::executeImp(TYPE *object, int formattingMode,
                                           bdeat_TypeCategory::DynamicType)
{
    baexml_Decoder_ParseAttribute_executeImpProxy proxy = { this,
                                                         formattingMode };
    return bdeat_TypeCategoryUtil::manipulateByCategory(object, proxy);
}

template <typename TYPE, typename ANY_CATEGORY>
int baexml_Decoder_ParseAttribute::executeImp(TYPE *object, int formattingMode,
                                           ANY_CATEGORY)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = - 1 };

    bool isAttribute = formattingMode
                     & bdeat_FormattingMode::BDEAT_ATTRIBUTE;

    if (!isAttribute) {
        BAEXML_DECODER_LOG_WARNING(d_decoder)
                                          << "Object '" << d_name_p << "' is "
                                          << "being parsed as an attribute, "
                                          << "but it does not have the "
                                          << "'IS_ATTRIBUTE' flag set."
                                          << BAEXML_DECODER_LOG_END;
    }

    if (0 != baexml_TypesParserUtil::parse(object,
                                           d_value_p,
                                           static_cast<int>(d_value_length),
                                           formattingMode)) {
        BAEXML_DECODER_LOG_ERROR(d_decoder)
                   << "Unable to parse \""
                   << bsl::string(d_value_p, d_value_length)
                   << "\" (for '" << d_name_p << "' attribute)"

                   << "\".\n"
                   << BAEXML_DECODER_LOG_END;

        d_failed = true;

        return BAEXML_FAILURE;
    }

    return BAEXML_SUCCESS;
}

// CREATORS
inline
baexml_Decoder_ParseAttribute::baexml_Decoder_ParseAttribute(
                                                      baexml_Decoder *decoder,
                                                      const char     *name,
                                                      const char     *value,
                                                      bsl::size_t     lenValue)
: d_decoder(decoder)
, d_failed(false)
, d_name_p(name)
, d_value_p(value)
, d_value_length (lenValue)
{
    BSLS_ASSERT_SAFE(d_decoder);
    BSLS_ASSERT_SAFE(d_name_p);
    BSLS_ASSERT_SAFE(d_value_p);
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
inline
int baexml_Decoder_ParseAttribute::operator()(TYPE             *object,
                                              const INFO_TYPE&  info)
{
    return execute(object, info.formattingMode());
}

template <typename TYPE>
inline
int baexml_Decoder_ParseAttribute::execute(TYPE *object, int formattingMode)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return executeImp(object, formattingMode, TypeCategory());
}

// ACCESSORS
inline
bool baexml_Decoder_ParseAttribute::failed() const
{
    return d_failed;
}

                       // --------------------------------
                       // class baexml_Decoder_ParseObject
                       // --------------------------------

// PRIVATE MANIPULATORS
template <typename TYPE>
inline
int baexml_Decoder_ParseObject::executeImp(
                                 bsl::vector<TYPE> *object, int formattingMode,
                                 bdeat_TypeCategory::Array)
{
    typedef bdeat_TypeCategory::Select<TYPE> Selector;

    enum {
        CAN_BE_REPETITION_ONLY
            = (  (int)Selector::BDEAT_SELECTION
                           == (int)bdeat_TypeCategory::BDEAT_SEQUENCE_CATEGORY
              || (int)Selector::BDEAT_SELECTION
                           == (int)bdeat_TypeCategory::BDEAT_CHOICE_CATEGORY)
    };

    typedef typename
    bslmf_If<CAN_BE_REPETITION_ONLY, CanBeRepetitionOnly,
                                     CanBeListOrRepetition>::Type Toggle;

    return executeArrayImp(object, formattingMode, Toggle());
}

template <typename TYPE>
inline
int baexml_Decoder_ParseObject::executeImp(TYPE *object, int formattingMode,
                                        bdeat_TypeCategory::Array)
{
    return executeArrayImp(object, formattingMode, CanBeListOrRepetition());
}

template <typename TYPE>
int baexml_Decoder_ParseObject::executeImp(TYPE *object, int formattingMode,
                                           bdeat_TypeCategory::Sequence)
{
    enum { BAEXML_FAILURE = -1 };

    if (formattingMode & bdeat_FormattingMode::BDEAT_UNTAGGED) {
        if (d_decoder->options()->skipUnknownElements()
         && false == bdeat_SequenceFunctions::hasAttribute(
                                                *object,
                                                d_elementName_p,
                                                static_cast<int>(d_lenName))) {
            d_decoder->setNumUnknownElementsSkipped(
                                   d_decoder->numUnknownElementsSkipped() + 1);
            baexml_Decoder_UnknownElementContext unknownElement;
            return unknownElement.beginParse(d_decoder);
        }

        return bdeat_SequenceFunctions::manipulateAttribute(
                                                  object,
                                                  *this,
                                                  d_elementName_p,
                                                  static_cast<int>(d_lenName));
    }

    typedef typename
    baexml_Decoder_InstantiateContext<
                             bdeat_TypeCategory::Sequence, TYPE>::Type Context;

    Context context(object, formattingMode);

    return context.beginParse(d_decoder);
}

template <typename TYPE>
int baexml_Decoder_ParseObject::executeImp(TYPE *object, int formattingMode,
                                        bdeat_TypeCategory::Choice)
{
    enum { BAEXML_FAILURE = -1 };

    bool isUntagged = formattingMode & bdeat_FormattingMode::BDEAT_UNTAGGED;

    if (isUntagged) {
        if (d_decoder->options()->skipUnknownElements()
         && false == bdeat_ChoiceFunctions::hasSelection(
                                                *object,
                                                d_elementName_p,
                                                static_cast<int>(d_lenName))) {
            d_decoder->setNumUnknownElementsSkipped(
                                   d_decoder->numUnknownElementsSkipped() + 1);
            baexml_Decoder_UnknownElementContext unknownElement;
            return unknownElement.beginParse(d_decoder);
        }

        if (0 != bdeat_ChoiceFunctions::makeSelection(
                                                object,
                                                d_elementName_p,
                                                static_cast<int>(d_lenName))) {
            BAEXML_DECODER_LOG_ERROR(d_decoder)
                                              << "Unable to make selection: \""
                                              << d_elementName_p
                                              << "\"."
                                              << BAEXML_DECODER_LOG_END;

            return BAEXML_FAILURE;
        }

        return bdeat_ChoiceFunctions::manipulateSelection(object, *this);
    }

    typedef typename
    baexml_Decoder_InstantiateContext<
                               bdeat_TypeCategory::Choice, TYPE>::Type Context;

    Context context(object, formattingMode);

    return context.beginParse(d_decoder);
}

template <typename TYPE>
int baexml_Decoder_ParseObject::executeImp(TYPE *object, int formattingMode,
                                        bdeat_TypeCategory::NullableValue)
{
    enum { BAEXML_SUCCESS = 0, BAEXML_FAILURE = -1 };

    if (bdeat_NullableValueFunctions::isNull(*object)) {
        bdeat_NullableValueFunctions::makeValue(object);
    }

    bool isNillable = formattingMode & bdeat_FormattingMode::BDEAT_NILLABLE;

    if (isNillable) {
        baexml_Decoder_ParseNillableObject parseAsNillable(d_decoder,
                                                        formattingMode);

        if (0 != bdeat_NullableValueFunctions::manipulateValue(
                                                            object,
                                                            parseAsNillable)) {
            return BAEXML_FAILURE;
        }

        if (parseAsNillable.isNil()) {
            // reset the object to null
            bdeat_ValueTypeFunctions::reset(object);
        }

        return BAEXML_SUCCESS;
    }

    baexml_Decoder_ParseObject_executeProxy proxy = { this, formattingMode };

    return bdeat_NullableValueFunctions::manipulateValue(object, proxy);
}

template <typename TYPE>
int baexml_Decoder_ParseObject::executeImp(TYPE *object, int formattingMode,
                                        bdeat_TypeCategory::CustomizedType)
{
    typedef typename
    baexml_Decoder_InstantiateContext<
                     bdeat_TypeCategory::CustomizedType, TYPE>::Type
                     Context;

    Context context(object, formattingMode);

    return context.beginParse(d_decoder);
}

template <typename TYPE>
inline
int baexml_Decoder_ParseObject::executeImp(TYPE *object, int formattingMode,
                                           bdeat_TypeCategory::DynamicType)
{
    baexml_Decoder_ParseObject_executeImpProxy proxy = {
        this, formattingMode
    };

    return bdeat_TypeCategoryUtil::manipulateByCategory(object, proxy);
}

template <typename TYPE, typename ANY_CATEGORY>
inline
int baexml_Decoder_ParseObject::executeImp(TYPE *object, int formattingMode,
                                           ANY_CATEGORY)
{
    typedef typename
    baexml_Decoder_InstantiateContext<ANY_CATEGORY, TYPE>::Type Context;

    Context context(object, formattingMode);

    return context.beginParse(d_decoder);
}

template <typename TYPE>
int baexml_Decoder_ParseObject::executeArrayImp(TYPE *object,
                                                int   formattingMode,
                                                CanBeListOrRepetition)
{
    if (formattingMode & bdeat_FormattingMode::BDEAT_LIST) {
        typedef baexml_Decoder_PushParserContext<TYPE,
                                              baexml_Decoder_ListParser<TYPE> >
                                                                   ListContext;

        ListContext listContext(object, formattingMode);

        return listContext.beginParse(d_decoder);
    } else {
        return executeArrayRepetitionImp(object, formattingMode);
    }
}

template <typename TYPE>
inline
int baexml_Decoder_ParseObject::executeArrayImp(TYPE *object,
                                                int   formattingMode,
                                                CanBeRepetitionOnly)
{
    return executeArrayRepetitionImp(object, formattingMode);
}

template <typename TYPE>
int baexml_Decoder_ParseObject::executeArrayRepetitionImp(TYPE *object,
                                                          int   formattingMode)
{
    BSLS_ASSERT_SAFE(! (formattingMode & bdeat_FormattingMode::BDEAT_TYPE_MASK
                                   & bdeat_FormattingMode::BDEAT_LIST));

    baexml_Decoder_ParseObject_executeProxy proxy = { this, formattingMode };

    const int i = static_cast<int>(bdeat_ArrayFunctions::size(*object));

    bdeat_ArrayFunctions::resize(object, i + 1);

    return bdeat_ArrayFunctions::manipulateElement(object, proxy, i);
}

// CREATORS
inline
baexml_Decoder_ParseObject::baexml_Decoder_ParseObject(
                                                   baexml_Decoder *decoder,
                                                   const char     *elementName,
                                                   bsl::size_t     lenName)
: d_decoder(decoder)
, d_elementName_p(elementName)
, d_lenName(lenName)
{
    BSLS_ASSERT_SAFE(d_elementName_p);
    BSLS_ASSERT_SAFE(d_decoder);
}

// MANIPULATORS
template <typename TYPE, typename INFO_TYPE>
inline
int baexml_Decoder_ParseObject::operator()(TYPE             *object,
                                           const INFO_TYPE&  info)
{
    return execute(object, info.formattingMode());
}

template <typename TYPE>
inline
int baexml_Decoder_ParseObject::execute(TYPE *object, int formattingMode)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return executeImp(object, formattingMode, TypeCategory());
}

                   // ----------------------------------------
                   // class baexml_Decoder_ParseNillableObject
                   // ----------------------------------------

// IMPLEMENTATION MANIPULATORS
template <typename TYPE>
inline
int baexml_Decoder_ParseNillableObject::executeImp(
                                               TYPE *object,
                                               bdeat_TypeCategory::DynamicType)
{
    baexml_Decoder_ParseNillableObject_executeImpProxy proxy = { this };

    return bdeat_TypeCategoryUtil::manipulateByCategory(object, proxy);
}

template <typename TYPE, typename ANY_CATEGORY>
inline
int baexml_Decoder_ParseNillableObject::executeImp(TYPE *object, ANY_CATEGORY)
{
    typedef typename
    baexml_Decoder_InstantiateContext<ANY_CATEGORY, TYPE>::Type Context;

    Context elementContext(object, d_formattingMode);

    d_nillableContext.setElementContext(&elementContext);

    return d_nillableContext.beginParse(d_decoder);
}

inline
baexml_Decoder_ParseNillableObject::baexml_Decoder_ParseNillableObject(
                                                baexml_Decoder *decoder,
                                                int             formattingMode)
: d_formattingMode(formattingMode)
, d_nillableContext()
, d_decoder(decoder)
{
}

// MANIPULATORS
template <typename TYPE>
inline
int baexml_Decoder_ParseNillableObject::operator()(TYPE *object)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return executeImp(object, TypeCategory());
}

// ACCESSORS
inline
bool baexml_Decoder_ParseNillableObject::isNil() const
{
    return d_nillableContext.isNil();
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2005
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
