// bael_thresholdaggregate.h                                          -*-C++-*-
#ifndef INCLUDED_BAEL_THRESHOLDAGGREGATE
#define INCLUDED_BAEL_THRESHOLDAGGREGATE

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide an aggregate of the four logging threshold levels.
//
//@CLASSES:
//  bael_ThresholdAggregate: aggregate of four logging threshold levels
//
//@SEE_ALSO: bael_severity
//
//@AUTHOR: Gang Chen (gchen20)
//
//@DESCRIPTION: This component implements a class that aggregates four
// threshold levels: record level, pass-through level, trigger level, and
// trigger-all level.  Each of these levels must in the range '[0 .. 255]', and
// represents a threshold which, if exceeded, will invoke a certain action.
//
///Usage
///-----
// The following code fragment illustrates some of the basic operations on
// threshold levels provided by 'bael_ThresholdAggregate'.
//..
//    bael_ThresholdAggregate levels(192, 160, 128, 96);
//    assert(192 == levels.recordLevel());
//    assert(160 == levels.passLevel());
//    assert(128 == levels.triggerLevel());
//    assert( 96 == levels.triggerAllLevel());
//
//    levels.setLevels(160, 128, 96, 64);
//    assert(160 == levels.recordLevel());
//    assert(128 == levels.passLevel());
//    assert( 96 == levels.triggerLevel());
//    assert( 64 == levels.triggerAllLevel());
//..

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BDEX_INSTREAMFUNCTIONS
#include <bdex_instreamfunctions.h>
#endif

#ifndef INCLUDED_BDEX_OUTSTREAMFUNCTIONS
#include <bdex_outstreamfunctions.h>
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include <bsl_iosfwd.h>
#endif

namespace BloombergLP {

                        // =============================
                        // class bael_ThresholdAggregate
                        // =============================

class bael_ThresholdAggregate {
    // This class implements an aggregate of the four logging threshold levels.

    // DATA
    unsigned char d_recordLevel;      // record
    unsigned char d_passLevel;        // pass
    unsigned char d_triggerLevel;     // trigger
    unsigned char d_triggerAllLevel;  // trigger-all

    // FRIENDS
    friend bool operator==(const bael_ThresholdAggregate&,
                           const bael_ThresholdAggregate&);
  public:
    // CLASS METHODS
    static int hash(const bael_ThresholdAggregate& aggregate, int size);
        // Return a hash value calculated from the specified threshold
        // 'aggregate' using the specified 'size' as the number of slots.  The
        // hash value is guaranteed to be in the range '[0, size)'.

    static int maxSupportedBdexVersion();
        // Return the most current 'bdex' streaming version number supported by
        // this class.  (See the package-group-level documentation for more
        // information on 'bdex' streaming of value-semantic types and
        // containers.)

    static bool areValidThresholdLevels(int recordLevel,
                                        int passLevel,
                                        int triggerLevel,
                                        int triggerAllLevel);
        // Return 'true' if each of the specified 'recordLevel', 'passLevel',
        // 'triggerLevel' and 'triggerAllLevel' threshold values is in the
        // range '[0 .. 255]', and 'false' otherwise.

    static int maxLevel(int recordLevel,
                        int passLevel,
                        int triggerLevel,
                        int triggerAllLevel);
        // Return the numerically greatest of the specified 'recordLevel',
        // 'passLevel', 'triggerLevel', and 'triggerAllLevel' values.

    static int maxLevel(const bael_ThresholdAggregate& aggregate);
        // Return the numerically greatest of the four logging threshold levels
        // held by the specified threshold 'aggregate'.

    // CREATORS
    bael_ThresholdAggregate(int recordLevel,
                            int passLevel,
                            int triggerLevel,
                            int triggerAllLevel);
        // Create a threshold aggregate whose threshold levels are the
        // specified 'recordLevel', 'passLevel', 'triggerLevel', and
        // 'triggerAllLevel', respectively.  The behavior is undefined if any
        // threshold level is not in the range '[0 .. 255]'.

    bael_ThresholdAggregate(const bael_ThresholdAggregate& original);
        // Create a threshold aggregate having the same value as that of the
        // specified 'original' threshold aggregate.

    // ~bael_ThresholdAggregate();
        // Destroy this threshold aggregate.  Note that this trivial destructor
        // is generated by the compiler.

    // MANIPULATORS
    bael_ThresholdAggregate& operator=(const bael_ThresholdAggregate& rhs);
        // Assign the value of the specified 'rhs' threshold aggregate to this
        // aggregate, and return a reference to this modifiable aggregate.

    int setLevels(int recordLevel,
                  int passLevel,
                  int triggerLevel,
                  int triggerAllLevel);
        // Set the threshold levels of this threshold aggregate to the
        // specified 'recordLevel', 'passLevel', 'triggerLevel', and
        // 'triggerAllLevel' values, respectively, if each of the specified
        // values is in the range '[0 .. 255]'.  Return 0 on success, and a
        // non-zero value otherwise (with no effect on the threshold levels of
        // this aggregate).

    void setRecordLevel(int recordLevel);
        // Set the record level of this threshold aggregate to the specified
        // 'recordLevel'.

    void setPassLevel(int passLevel);
        // Set the pass level of this threshold aggregate to the specified
        // 'passLevel'.

    void setTriggerLevel(int triggerLevel);
        // Set the trigger level of this threshold aggregate to the specified
        // 'triggerLevel'.

    void setTriggerAllLevel(int triggerAllLevel);
        // Set the trigger-all level of this threshold aggregate to the
        // specified 'triggerAllLevel'.

    template <class STREAM>
    STREAM& bdexStreamIn(STREAM& stream, int version);
        // Assign to this object the value read from the specified input
        // 'stream' using the specified 'version' format and return a
        // reference to the modifiable 'stream'.  If 'stream' is initially
        // invalid, this operation has no effect.  If 'stream' becomes invalid
        // during this operation, this object is valid, but its value is
        // undefined.  If 'version' is not supported, 'stream' is marked
        // invalid and this object is unaltered.  Note that no version is read
        // from 'stream'.

    // ACCESSORS
    int recordLevel() const;
        // Return the record level of this threshold aggregate.

    int passLevel() const;
        // Return the pass level of this threshold aggregate.

    int triggerLevel() const;
        // Return the trigger level of this threshold aggregate.

    int triggerAllLevel() const;
        // Return the trigger-all level of this threshold aggregate.

    bsl::ostream& print(bsl::ostream& stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output 'stream' at the
        // (absolute value of) the optionally specified indentation 'level'
        // and return a reference to 'stream'.  If 'level' is specified,
        // optionally specify 'spacesPerLevel', the number of spaces per
        // indentation level for this and all of its nested objects.  If
        // 'level' is negative, suppress indentation of the first line.  If
        // 'spacesPerLevel' is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // 'level').  If 'stream' is not valid on entry, this operation has no
        // effect.

    template <class STREAM>
    STREAM& bdexStreamOut(STREAM& stream, int version) const;
        // Write this value to the specified output 'stream' using the
        // specified 'version' format and return a reference to the modifiable
        // 'stream'.  If 'version' is not supported, 'stream' is unmodified.
        // Note that 'version' is not written to 'stream'.
};

// FREE OPERATORS
bool operator==(const bael_ThresholdAggregate& lhs,
                const bael_ThresholdAggregate& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' threshold aggregates have
    // the same value, and 'false' otherwise.  Two threshold aggregates have
    // the same value if all four of their respective threshold levels are the
    // same.

bool operator!=(const bael_ThresholdAggregate& lhs,
                const bael_ThresholdAggregate& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' threshold aggregates do
    // not have the same value, and 'false' otherwise.  Two threshold
    // aggregates do not have the same value if any of their four respective
    // threshold levels differ.

bsl::ostream& operator<<(bsl::ostream&                  stream,
                         const bael_ThresholdAggregate& aggregate);
    // Write the value of the specified threshold 'aggregate' to the specified
    // output 'stream' and return a reference to the modifiable 'stream'.

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // -----------------------------
                        // class bael_ThresholdAggregate
                        // -----------------------------

// ACCESSORS INLINED BY OTHER METHODS
inline
int bael_ThresholdAggregate::recordLevel() const
{
    return d_recordLevel;
}

inline
int bael_ThresholdAggregate::passLevel() const
{
    return d_passLevel;
}

inline
int bael_ThresholdAggregate::triggerLevel() const
{
    return d_triggerLevel;
}

inline
int bael_ThresholdAggregate::triggerAllLevel() const
{
    return d_triggerAllLevel;
}

// CLASS METHODS
inline
int bael_ThresholdAggregate::maxSupportedBdexVersion()
{
    return 1;  // Required by BDE policy; versions start at 1.
}

inline
bool bael_ThresholdAggregate::areValidThresholdLevels(int recordLevel,
                                                      int passLevel,
                                                      int triggerLevel,
                                                      int triggerAllLevel)
{
    enum { BAEL_BITS_PER_CHAR = 8 };

    return !((recordLevel | passLevel | triggerLevel | triggerAllLevel)
             >> BAEL_BITS_PER_CHAR);
}

inline
int bael_ThresholdAggregate::maxLevel(const bael_ThresholdAggregate& aggregate)
{
    return maxLevel(aggregate.recordLevel(),  aggregate.passLevel(),
                    aggregate.triggerLevel(), aggregate.triggerAllLevel());
}

// CREATORS
inline
bael_ThresholdAggregate::bael_ThresholdAggregate(int recordLevel,
                                                 int passLevel,
                                                 int triggerLevel,
                                                 int triggerAllLevel)
: d_recordLevel(static_cast<unsigned char>(recordLevel))
, d_passLevel(static_cast<unsigned char>(passLevel))
, d_triggerLevel(static_cast<unsigned char>(triggerLevel))
, d_triggerAllLevel(static_cast<unsigned char>(triggerAllLevel))
{
}

inline
bael_ThresholdAggregate::bael_ThresholdAggregate(
                                       const bael_ThresholdAggregate& original)
: d_recordLevel(original.d_recordLevel)
, d_passLevel(original.d_passLevel)
, d_triggerLevel(original.d_triggerLevel)
, d_triggerAllLevel(original.d_triggerAllLevel)
{
}

// MANIPULATORS
inline
void bael_ThresholdAggregate::setRecordLevel(int recordLevel)
{
    d_recordLevel = static_cast<unsigned char>(recordLevel);
}

inline
void bael_ThresholdAggregate::setPassLevel(int passLevel)
{
    d_passLevel = static_cast<unsigned char>(passLevel);
}

inline
void bael_ThresholdAggregate::setTriggerLevel(int triggerLevel)
{
    d_triggerLevel = static_cast<unsigned char>(triggerLevel);
}

inline
void bael_ThresholdAggregate::setTriggerAllLevel(int triggerAllLevel)
{
    d_triggerAllLevel = static_cast<unsigned char>(triggerAllLevel);
}

template <class STREAM>
STREAM& bael_ThresholdAggregate::bdexStreamIn(STREAM& stream, int version)
{
    if (stream) {
        switch (version) {
          case 1: {
            bdex_InStreamFunctions::streamIn(stream, d_recordLevel, 0);
            if (!stream) {
                return stream;                                        // RETURN
            }
            bdex_InStreamFunctions::streamIn(stream, d_passLevel, 0);
            if (!stream) {
                return stream;                                        // RETURN
            }
            bdex_InStreamFunctions::streamIn(stream, d_triggerLevel, 0);
            if (!stream) {
                return stream;                                        // RETURN
            }
            bdex_InStreamFunctions::streamIn(stream, d_triggerAllLevel, 0);
            if (!stream) {
                return stream;                                        // RETURN
            }
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;
}

// ACCESSORS
template <class STREAM>
inline
STREAM& bael_ThresholdAggregate::bdexStreamOut(STREAM& stream, int) const
{
    bdex_OutStreamFunctions::streamOut(stream, d_recordLevel, 0);
    bdex_OutStreamFunctions::streamOut(stream, d_passLevel, 0);
    bdex_OutStreamFunctions::streamOut(stream, d_triggerLevel, 0);
    bdex_OutStreamFunctions::streamOut(stream, d_triggerAllLevel, 0);

    return stream;
}

// FREE OPERATORS
inline
bool operator==(const bael_ThresholdAggregate& lhs,
                const bael_ThresholdAggregate& rhs)
{
    return lhs.d_recordLevel     == rhs.d_recordLevel
        && lhs.d_passLevel       == rhs.d_passLevel
        && lhs.d_triggerLevel    == rhs.d_triggerLevel
        && lhs.d_triggerAllLevel == rhs.d_triggerAllLevel;
}

inline
bool operator!=(const bael_ThresholdAggregate& lhs,
                const bael_ThresholdAggregate& rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream& operator<<(bsl::ostream&                  output,
                         const bael_ThresholdAggregate& aggregate)
{
    return aggregate.print(output, 0, -1);
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2007
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
