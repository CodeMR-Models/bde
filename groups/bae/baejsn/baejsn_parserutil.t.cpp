// baejsn_parserutil.t.cpp                                            -*-C++-*-
#include <baejsn_parserutil.h>

#include <bsl_sstream.h>
#include <bsl_cfloat.h>
#include <bsl_climits.h>
#include <bsl_limits.h>
#include <bsl_iostream.h>
#include <bdepu_typesparser.h>

#include <bdesb_memoutstreambuf.h>            // for testing only
#include <bdesb_fixedmemoutstreambuf.h>       // for testing only
#include <bdesb_fixedmeminstreambuf.h>        // for testing only

using namespace BloombergLP;
using namespace bsl;
using bsl::cout;
using bsl::cerr;
using bsl::endl;

//=============================================================================
//                      STANDARD BDE ASSERT TEST MACRO
//-----------------------------------------------------------------------------
static int testStatus = 0;

static void aSsErT(int c, const char *s, int i)
{
    if (c) {
        cout << "Error " << __FILE__ << "(" << i << "): " << s
             << "    (failed)" << endl;
        if (0 <= testStatus && testStatus <= 100) ++testStatus;
    }
}

#define ASSERT(X) { aSsErT(!(X), #X, __LINE__); }

#define LOOP0_ASSERT ASSERT

// ============================================================================
//                  STANDARD BDE LOOP-ASSERT TEST MACROS
// ----------------------------------------------------------------------------

#define LOOP_ASSERT(I,X) {                                                    \
    if (!(X)) { cout << #I << ": " << I << "\n"; aSsErT(1, #X, __LINE__);}}

#define LOOP1_ASSERT LOOP_ASSERT

#define LOOP2_ASSERT(I,J,X) {                                                 \
    if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": "                 \
              << J << "\n"; aSsErT(1, #X, __LINE__); } }

#define LOOP3_ASSERT(I,J,K,X) {                                               \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t"     \
              << #K << ": " << K << "\n"; aSsErT(1, #X, __LINE__); } }

#define LOOP4_ASSERT(I,J,K,L,X) {                                             \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" <<  \
       #K << ": " << K << "\t" << #L << ": " << L << "\n";                    \
       aSsErT(1, #X, __LINE__); } }

#define LOOP5_ASSERT(I,J,K,L,M,X) {                                           \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" <<  \
       #K << ": " << K << "\t" << #L << ": " << L << "\t" <<                  \
       #M << ": " << M << "\n";                                               \
       aSsErT(1, #X, __LINE__); } }

// ============================================================================
//                  SEMI-STANDARD TEST OUTPUT MACROS
// ----------------------------------------------------------------------------

#define P(X) cout << #X " = " << (X) << endl; // Print identifier and value.
#define Q(X) cout << "<| " #X " |>" << endl;  // Quote identifier literally.
#define P_(X) cout << #X " = " << (X) << ", " << flush; // 'P(X)' without '\n'
#define T_ cout << "\t" << flush;             // Print tab w/o newline.
#define L_ __LINE__                           // current Line number

// The 'BSLS_BSLTESTUTIL_EXPAND' macro is required to workaround a
// pre-proccessor issue on windows that prevents __VA_ARGS__ to be expanded in
// the definition of 'BSLS_BSLTESTUTIL_NUM_ARGS'
#define EXPAND(X)                                            \
    X

#define NUM_ARGS_IMPL(X5, X4, X3, X2, X1, X0, N, ...)        \
    N

#define NUM_ARGS(...)                                        \
    EXPAND(NUM_ARGS_IMPL( __VA_ARGS__, 5, 4, 3, 2, 1, 0, ""))

#define LOOPN_ASSERT_IMPL(N, ...)                            \
    EXPAND(LOOP ## N ## _ASSERT(__VA_ARGS__))

#define LOOPN_ASSERT(N, ...)                                 \
    LOOPN_ASSERT_IMPL(N, __VA_ARGS__)

#define ASSERTV(...)                                         \
    LOOPN_ASSERT(NUM_ARGS(__VA_ARGS__), __VA_ARGS__)

// ============================================================================
//                  GLOBAL TYPEDEFS/CONSTANTS FOR TESTING
// ----------------------------------------------------------------------------

enum { SUCCESS = 0, FAILURE = -1 };

typedef baejsn_ParserUtil Util;

bool areBuffersEqual(const char *lhs, const char *rhs)
    // Compare the data written to the specified 'lhs' with the data in the
    // specified 'rhs' ignoring whitespace in the specified 'lhs'.  Return
    // 'true' if they are equal, and 'false' otherwise.
{
    while (*lhs) {
        if (' ' == *lhs) {
            ++lhs;
            continue;
        }
        if (*lhs != *rhs) {
           return false;
        }
        ++lhs;
        ++rhs;
    }
    return true;
}

// ============================================================================
//                            MAIN PROGRAM
// ----------------------------------------------------------------------------

typedef bsls_PlatformUtil::Int64  Int64;
typedef bsls_PlatformUtil::Uint64 Uint64;

int main(int argc, char *argv[])
{
    int test = argc > 1 ? atoi(argv[1]) : 0;

    bool verbose = argc > 2;
    bool veryVerbose = argc > 3;
    bool veryVeryVerbose = argc > 4;

    cout << "TEST " << __FILE__ << " CASE " << test << endl;

    switch (test) { case 0:  // Zero is always the leading case.
      case 20: {
        // --------------------------------------------------------------------
        // TESTING 'skipSpaces'
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for 'bdet_DatetimeTz'"
                               << "\n========================================"
                               << bsl::endl;
        {
        }
      } break;
      case 19: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for bdet_DatetimeTz values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for 'bdet_DatetimeTz'"
                               << "\n========================================"
                               << bsl::endl;
        {
            static const struct {
                int         d_line;      // source line number
                const char *d_input_p;   // input
                int         d_year;      // year under test
                int         d_month;     // month under test
                int         d_day;       // day under test
                int         d_hour;      // hour under test
                int         d_minutes;   // minutes under test
                int         d_seconds;   // seconds under test
                int         d_milliSecs; // milli seconds under test
                int         d_tzoffset;  // time zone offset
                bool        d_isValid;   // isValid flag
            } DATA[] = {
  //line    input year month   day   hour    min   sec    ms  offset isValid
  //----    ----- ---- -----   ---   ----    ---   ---    --  ------ -------
    {   L_, "\"0001-01-01T00:00:00.000+00:00\"",
                   1,     1,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0001-01-01T00:00:00.000+00:45\"",
                   1,     1,    1,     0,     0,    0,    0,     45,  true   },
    {   L_, "\"0001-01-01T00:00:00.000-23:59\"",
                   1,     1,    1,     0,     0,    0,    0,  -1439,  true   },

    {   L_, "\"0001-01-01T01:01:01.001+00:00\"",
                   1,     1,    1,     1,     1,    1,    1,      0,  true   },
    {   L_, "\"0001-01-01T01:01:01.001+08:20\"",
                   1,     1,    1,     1,     1,    1,    1,    500,  true   },
    {   L_, "\"0001-01-01T00:00:00.000-23:59\"",
                   1,     1,    1,     0,     0,    0,    0,  -1439,  true   },
    {   L_, "\"0001-01-01T01:23:59.059+00:00\"",
                   1,     1,    1,     1,    23,   59,   59,      0,  true   },
    {   L_, "\"0001-01-01T01:23:59.059+23:59\"",
                   1,     1,    1,     1,    23,   59,   59,   1439,  true   },
    {   L_, "\"0001-01-01T01:23:59.059-23:59\"",
                   1,     1,    1,     1,    23,   59,   59,  -1439,  true   },
    {   L_, "\"0001-01-02T00:00:00.000+00:00\"",
                   1,     1,    2,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0001-01-02T00:00:00.000+23:59\"",
                   1,     1,    2,     0,     0,    0,    0,   1439,  true   },
    {   L_, "\"0001-01-02T00:00:00.000-23:59\"",
                   1,     1,    2,     0,     0,    0,    0,  -1439,  true   },
    {   L_, "\"0001-01-02T01:01:01.001+00:00\"",
                   1,     1,    2,     1,     1,    1,    1,      0,  true   },
    {   L_, "\"0001-01-02T01:01:01.001+08:20\"",
                   1,     1,    2,     1,     1,    1,    1,    500,  true   },

    {   L_, "\"0001-01-02T01:23:59.059+00:00\"",
                   1,     1,    2,     1,    23,   59,   59,      0,  true   },
    {   L_, "\"0001-01-02T01:23:59.059+08:20\"",
                   1,     1,    2,     1,    23,   59,   59,    500,  true   },
    {   L_, "\"0001-01-02T01:23:59.059-08:20\"",
                   1,     1,    2,     1,    23,   59,   59,   -500,  true   },

    {   L_, "\"0001-01-10T00:00:00.000+00:00\"",
                   1,     1,   10,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0001-01-10T01:01:01.001+01:39\"",
                   1,     1,   10,     1,     1,    1,    1,     99,  true   },

    {   L_, "\"0001-01-30T00:00:00.000+00:00\"",
                   1,     1,   30,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0001-01-31T00:00:00.000+23:59\"",
                   1,     1,   31,     0,     0,    0,    0,   1439,  true   },
    {   L_, "\"0001-01-31T00:00:00.000-23:59\"",
                   1,     1,   31,     0,     0,    0,    0,  -1439,  true   },

    {   L_, "\"0001-02-01T00:00:00.000+00:00\"",
                   1,     2,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0001-02-01T23:59:59.000+23:59\"",
                   1,     2,    1,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0001-12-31T00:00:00.000+00:00\"",
                   1,    12,   31,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0001-12-31T23:59:59.000+23:59\"",
                   1,    12,   31,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0002-01-01T00:00:00.000+00:00\"",
                   2,     1,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0002-01-01T23:59:59.000+23:59\"",
                   2,     1,    1,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0004-01-01T00:00:00.000+00:00\"",
                   4,     1,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0004-01-01T23:59:59.000+23:59\"",
                   4,     1,    1,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0004-02-28T00:00:00.000+00:00\"",
                   4,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0004-02-28T23:59:59.000+23:59\"",
                   4,     2,   28,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"0004-02-28T23:59:59.000-23:59\"",
                   4,     2,   28,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"0004-02-29T00:00:00.000+00:00\"",
                   4,     2,   29,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0004-02-29T23:59:59.000+23:59\"",
                   4,     2,   29,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"0004-02-29T23:59:59.000-23:59\"",
                   4,     2,   29,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"0004-03-01T00:00:00.000+00:00\"",
                   4,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0004-03-01T23:59:59.000+23:59\"",
                   4,     3,    1,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"0004-03-01T23:59:59.000-23:59\"",
                   4,     3,    1,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"0008-02-28T00:00:00.000+00:00\"",
                   8,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0008-02-28T23:59:59.000+23:59\"",
                   8,     2,   28,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0008-02-29T00:00:00.000+00:00\"",
                   8,     2,   29,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0008-02-29T23:59:59.000+23:59\"",
                   8,     2,   29,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0008-03-01T00:00:00.000+00:00\"",
                   8,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0008-03-01T23:59:59.000+23:59\"",
                   8,     3,    1,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0100-02-28T00:00:00.000+00:00\"",
                 100,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0100-02-28T23:59:59.000+23:59\"",
                 100,     2,   28,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"0100-02-28T23:59:59.000-23:59\"",
                 100,     2,   28,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"0100-03-01T00:00:00.000+00:00\"",
                 100,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0100-03-01T23:59:59.000+23:59\"",
                 100,     3,    1,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"0100-03-01T23:59:59.000-23:59\"",
                 100,     3,    1,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"0400-02-28T00:00:00.000+00:00\"",
                 400,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0400-02-28T23:59:59.000+23:59\"",
                 400,     2,   28,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"0400-02-28T23:59:59.000-23:59\"",
                 400,     2,   28,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"0400-02-29T00:00:00.000+00:00\"",
                 400,     2,   29,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0400-02-29T23:59:59.000+23:59\"",
                 400,     2,   29,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"0400-02-29T23:59:59.000-23:59\"",
                 400,     2,   29,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"0400-03-01T00:00:00.000+00:00\"",
                 400,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0400-03-01T23:59:59.000+23:59\"",
                 400,     3,    1,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"0400-03-01T23:59:59.000-23:59\"",
                 400,     3,    1,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"0500-02-28T00:00:00.000+00:00\"",
                 500,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0500-02-28T23:59:59.000+23:59\"",
                 500,     2,   28,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0500-03-01T00:00:00.000+00:00\"",
                 500,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0500-03-01T23:59:59.000+23:59\"",
                 500,     3,    1,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0800-02-28T00:00:00.000+00:00\"",
                 800,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0800-02-28T23:59:59.000+23:59\"",
                 800,     2,   28,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0800-02-29T00:00:00.000+00:00\"",
                 800,     2,   29,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0800-02-29T23:59:59.000+23:59\"",
                 800,     2,   29,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0800-03-01T00:00:00.000+00:00\"",
                 800,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"0800-03-01T23:59:59.000+23:59\"",
                 800,     3,    1,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"1000-02-28T00:00:00.000+00:00\"",
                1000,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"1000-02-28T23:59:59.000+23:59\"",
                1000,     2,   28,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"1000-03-01T00:00:00.000+00:00\"",
                1000,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"1000-03-01T23:59:59.000+23:59\"",
                1000,     3,    1,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"2000-02-28T00:00:00.000+00:00\"",
                2000,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2000-02-28T23:59:59.000+23:59\"",
                2000,     2,   28,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"2000-02-29T00:00:00.000+00:00\"",
                2000,     2,   29,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2000-02-29T23:59:59.000+23:59\"",
                2000,     2,   29,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"2000-03-01T00:00:00.000+00:00\"",
                2000,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2000-03-01T23:59:59.000+23:59\"",
                2000,     3,    1,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"2016-12-31T00:00:00.000+00:00\"",
                2016,    12,   31,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2017-12-31T00:00:00.000+00:00\"",
                2017,    12,   31,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2018-12-31T00:00:00.000+00:00\"",
                2018,    12,   31,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2019-12-31T00:00:00.000+00:00\"",
                2019,    12,   31,     0,     0,    0,    0,      0,  true   },

    {   L_, "\"2020-01-01T00:00:00.000+00:00\"",
                2020,     1,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2020-01-01T00:00:00.000+23:59\"",
                2020,     1,    1,     0,     0,    0,    0,   1439,  true   },
    {   L_, "\"2020-01-01T00:00:00.000-23:59\"",
                2020,     1,    1,     0,     0,    0,    0,  -1439,  true   },

    {   L_, "\"2020-01-01T23:59:59.999+00:00\"",
                2020,     1,    1,    23,    59,   59,  999,      0,  true   },
    {   L_, "\"2020-01-01T23:59:59.999+23:59\"",
                2020,     1,    1,    23,    59,   59,  999,   1439,  true   },
    {   L_, "\"2020-01-01T23:59:59.999-23:59\"",
                2020,     1,    1,    23,    59,   59,  999,  -1439,  true   },

    {   L_, "\"2020-01-02T00:00:00.000+00:00\"",
                2020,     1,    2,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2020-01-02T00:00:00.000+23:59\"",
                2020,     1,    2,     0,     0,    0,    0,   1439,  true   },
    {   L_, "\"2020-01-02T00:00:00.000-23:59\"",
                2020,     1,    2,     0,     0,    0,    0,  -1439,  true   },

    {   L_, "\"2020-02-28T00:00:00.000+00:00\"",
                2020,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2020-02-28T23:59:59.000+23:59\"",
                2020,     2,   28,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"2020-02-28T23:59:59.000-23:59\"",
                2020,     2,   28,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"2020-02-29T00:00:00.000+00:00\"",
                2020,     2,   29,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2020-02-29T23:59:59.000+23:59\"",
                2020,     2,   29,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"2020-02-29T23:59:59.000-23:59\"",
                2020,     2,   29,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"2020-03-01T00:00:00.000+00:00\"",
                2020,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2020-03-01T23:59:59.000+23:59\"",
                2020,     3,    1,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"2020-03-01T23:59:59.000-23:59\"",
                2020,     3,    1,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"2021-01-02T00:00:00.000+00:00\"",
                2021,     1,    2,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"2022-01-02T00:00:00.000+00:00\"",
                2022,     1,    2,     0,     0,    0,    0,      0,  true   },

    {   L_, "\"9999-02-28T00:00:00.000+00:00\"",
                9999,     2,   28,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"9999-02-28T23:59:59.000+23:59\"",
                9999,     2,   28,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"9999-02-28T23:59:59.000-23:59\"",
                9999,     2,   28,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"9999-03-01T00:00:00.000+00:00\"",
                9999,     3,    1,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"9999-03-01T23:59:59.000+23:59\"",
                9999,     3,    1,    23,    59,   59,    0,   1439,  true   },
    {   L_, "\"9999-03-01T23:59:59.000-23:59\"",
                9999,     3,    1,    23,    59,   59,    0,  -1439,  true   },

    {   L_, "\"9999-12-30T00:00:00.000+00:00\"",
                9999,    12,   30,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"9999-12-30T23:59:59.000+23:59\"",
                9999,    12,   30,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"9999-12-31T00:00:00.000+00:00\"",
                9999,    12,   31,     0,     0,    0,    0,      0,  true   },
    {   L_, "\"9999-12-31T23:59:59.000+23:59\"",
                9999,    12,   31,    23,    59,   59,    0,   1439,  true   },

    {   L_, "\"0000-01-01T00:00:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-00-01T00:00:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-00T00:00:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0000-00-00T00:00:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-13-00T00:00:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-32T00:00:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-01T25:00:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-01T00:61:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-01T00:00:61.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-01T00:00:00.000+24:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-01T00:00:00.000+00:61\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-01T00:00:00.000-24:00\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-01T00:00:00.000-00:61\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },

    {   L_, "\"GARBAGE\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\".9999\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"T23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"01T23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"01-01T23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },
    {   L_, "\"0001-01-01T00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },

    {   L_, "\"01-01-01T23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,      0,  false  },

        };
            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int i = 0; i < NUM_DATA; ++i) {
                const int         LINE        = DATA[i].d_line;
                const string      INPUT       = DATA[i].d_input_p;
                const int         YEAR        = DATA[i].d_year;
                const int         MONTH       = DATA[i].d_month;
                const int         DAY         = DATA[i].d_day;
                const int         HOUR        = DATA[i].d_hour;
                const int         MINUTE      = DATA[i].d_minutes;
                const int         SECOND      = DATA[i].d_seconds;
                const int         MILLISECOND = DATA[i].d_milliSecs;
                const int         OFFSET      = DATA[i].d_tzoffset;
                const bool        IS_VALID    = DATA[i].d_isValid;

                bdet_Datetime dt(YEAR, MONTH, DAY,
                                 HOUR, MINUTE, SECOND, MILLISECOND);
                const bdet_Datetime& DT = dt;
                bdet_DatetimeTz exp(DT, OFFSET);
                const bdet_DatetimeTz& EXP = exp;

                bdet_DatetimeTz value;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value,   EXP == value);
            }
        }
      } break;
      case 18: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for bdet_Datetime values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for 'bdet_Datetime'"
                               << "\n======================================"
                               << bsl::endl;
        {
            static const struct {
                int         d_line;      // source line number
                const char *d_input_p;   // input
                int         d_year;      // year under test
                int         d_month;     // month under test
                int         d_day;       // day under test
                int         d_hour;      // hour under test
                int         d_minutes;   // minutes under test
                int         d_seconds;   // seconds under test
                int         d_milliSecs; // milli seconds under test
                bool        d_isValid;   // isValid flag
            } DATA[] = {
  //line    input year month   day   hour    min   sec    ms  isValid
  //----    ----- ---- -----   ---   ----    ---   ---    --  -------
    {   L_, "\"0001-01-01T00:00:00.000\"",
                   1,     1,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-01T00:00:00.000\"",
                   1,     1,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-01T00:00:00.000\"",
                   1,     1,    1,     0,     0,    0,    0,    true   },

    {   L_, "\"0001-01-01T01:01:01.001\"",
                   1,     1,    1,     1,     1,    1,    1,    true   },
    {   L_, "\"0001-01-01T01:01:01.001\"",
                   1,     1,    1,     1,     1,    1,    1,    true   },
    {   L_, "\"0001-01-01T00:00:00.000\"",
                   1,     1,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-01T01:23:59.059\"",
                   1,     1,    1,     1,    23,   59,   59,    true   },
    {   L_, "\"0001-01-01T01:23:59.059\"",
                   1,     1,    1,     1,    23,   59,   59,    true   },
    {   L_, "\"0001-01-01T01:23:59.059\"",
                   1,     1,    1,     1,    23,   59,   59,    true   },
    {   L_, "\"0001-01-02T00:00:00.000\"",
                   1,     1,    2,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-02T00:00:00.000\"",
                   1,     1,    2,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-02T00:00:00.000\"",
                   1,     1,    2,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-02T01:01:01.001\"",
                   1,     1,    2,     1,     1,    1,    1,    true   },
    {   L_, "\"0001-01-02T01:01:01.001\"",
                   1,     1,    2,     1,     1,    1,    1,    true   },

    {   L_, "\"0001-01-02T01:23:59.059\"",
                   1,     1,    2,     1,    23,   59,   59,    true   },
    {   L_, "\"0001-01-02T01:23:59.059\"",
                   1,     1,    2,     1,    23,   59,   59,    true   },
    {   L_, "\"0001-01-02T01:23:59.059\"",
                   1,     1,    2,     1,    23,   59,   59,    true   },

    {   L_, "\"0001-01-10T00:00:00.000\"",
                   1,     1,   10,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-10T01:01:01.001\"",
                   1,     1,   10,     1,     1,    1,    1,    true   },

    {   L_, "\"0001-01-30T00:00:00.000\"",
                   1,     1,   30,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-31T00:00:00.000\"",
                   1,     1,   31,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-01-31T00:00:00.000\"",
                   1,     1,   31,     0,     0,    0,    0,    true   },

    {   L_, "\"0001-02-01T00:00:00.000\"",
                   1,     2,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-02-01T23:59:59.000\"",
                   1,     2,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"0001-12-31T00:00:00.000\"",
                   1,    12,   31,     0,     0,    0,    0,    true   },
    {   L_, "\"0001-12-31T23:59:59.000\"",
                   1,    12,   31,    23,    59,   59,    0,    true   },

    {   L_, "\"0002-01-01T00:00:00.000\"",
                   2,     1,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0002-01-01T23:59:59.000\"",
                   2,     1,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"0004-01-01T00:00:00.000\"",
                   4,     1,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0004-01-01T23:59:59.000\"",
                   4,     1,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"0004-02-28T00:00:00.000\"",
                   4,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"0004-02-28T23:59:59.000\"",
                   4,     2,   28,    23,    59,   59,    0,    true   },
    {   L_, "\"0004-02-28T23:59:59.000\"",
                   4,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"0004-02-29T00:00:00.000\"",
                   4,     2,   29,     0,     0,    0,    0,    true   },
    {   L_, "\"0004-02-29T23:59:59.000\"",
                   4,     2,   29,    23,    59,   59,    0,    true   },
    {   L_, "\"0004-02-29T23:59:59.000\"",
                   4,     2,   29,    23,    59,   59,    0,    true   },

    {   L_, "\"0004-03-01T00:00:00.000\"",
                   4,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0004-03-01T23:59:59.000\"",
                   4,     3,    1,    23,    59,   59,    0,    true   },
    {   L_, "\"0004-03-01T23:59:59.000\"",
                   4,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"0008-02-28T00:00:00.000\"",
                   8,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"0008-02-28T23:59:59.000\"",
                   8,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"0008-02-29T00:00:00.000\"",
                   8,     2,   29,     0,     0,    0,    0,    true   },
    {   L_, "\"0008-02-29T23:59:59.000\"",
                   8,     2,   29,    23,    59,   59,    0,    true   },

    {   L_, "\"0008-03-01T00:00:00.000\"",
                   8,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0008-03-01T23:59:59.000\"",
                   8,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"0100-02-28T00:00:00.000\"",
                 100,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"0100-02-28T23:59:59.000\"",
                 100,     2,   28,    23,    59,   59,    0,    true   },
    {   L_, "\"0100-02-28T23:59:59.000\"",
                 100,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"0100-03-01T00:00:00.000\"",
                 100,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0100-03-01T23:59:59.000\"",
                 100,     3,    1,    23,    59,   59,    0,    true   },
    {   L_, "\"0100-03-01T23:59:59.000\"",
                 100,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"0400-02-28T00:00:00.000\"",
                 400,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"0400-02-28T23:59:59.000\"",
                 400,     2,   28,    23,    59,   59,    0,    true   },
    {   L_, "\"0400-02-28T23:59:59.000\"",
                 400,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"0400-02-29T00:00:00.000\"",
                 400,     2,   29,     0,     0,    0,    0,    true   },
    {   L_, "\"0400-02-29T23:59:59.000\"",
                 400,     2,   29,    23,    59,   59,    0,    true   },
    {   L_, "\"0400-02-29T23:59:59.000\"",
                 400,     2,   29,    23,    59,   59,    0,    true   },

    {   L_, "\"0400-03-01T00:00:00.000\"",
                 400,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0400-03-01T23:59:59.000\"",
                 400,     3,    1,    23,    59,   59,    0,    true   },
    {   L_, "\"0400-03-01T23:59:59.000\"",
                 400,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"0500-02-28T00:00:00.000\"",
                 500,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"0500-02-28T23:59:59.000\"",
                 500,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"0500-03-01T00:00:00.000\"",
                 500,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0500-03-01T23:59:59.000\"",
                 500,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"0800-02-28T00:00:00.000\"",
                 800,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"0800-02-28T23:59:59.000\"",
                 800,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"0800-02-29T00:00:00.000\"",
                 800,     2,   29,     0,     0,    0,    0,    true   },
    {   L_, "\"0800-02-29T23:59:59.000\"",
                 800,     2,   29,    23,    59,   59,    0,    true   },

    {   L_, "\"0800-03-01T00:00:00.000\"",
                 800,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"0800-03-01T23:59:59.000\"",
                 800,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"1000-02-28T00:00:00.000\"",
                1000,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"1000-02-28T23:59:59.000\"",
                1000,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"1000-03-01T00:00:00.000\"",
                1000,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"1000-03-01T23:59:59.000\"",
                1000,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"2000-02-28T00:00:00.000\"",
                2000,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"2000-02-28T23:59:59.000\"",
                2000,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"2000-02-29T00:00:00.000\"",
                2000,     2,   29,     0,     0,    0,    0,    true   },
    {   L_, "\"2000-02-29T23:59:59.000\"",
                2000,     2,   29,    23,    59,   59,    0,    true   },

    {   L_, "\"2000-03-01T00:00:00.000\"",
                2000,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"2000-03-01T23:59:59.000\"",
                2000,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"2016-12-31T00:00:00.000\"",
                2016,    12,   31,     0,     0,    0,    0,    true   },
    {   L_, "\"2017-12-31T00:00:00.000\"",
                2017,    12,   31,     0,     0,    0,    0,    true   },
    {   L_, "\"2018-12-31T00:00:00.000\"",
                2018,    12,   31,     0,     0,    0,    0,    true   },
    {   L_, "\"2019-12-31T00:00:00.000\"",
                2019,    12,   31,     0,     0,    0,    0,    true   },

    {   L_, "\"2020-01-01T00:00:00.000\"",
                2020,     1,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"2020-01-01T00:00:00.000\"",
                2020,     1,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"2020-01-01T00:00:00.000\"",
                2020,     1,    1,     0,     0,    0,    0,    true   },

    {   L_, "\"2020-01-01T23:59:59.999\"",
                2020,     1,    1,    23,    59,   59,  999,    true   },
    {   L_, "\"2020-01-01T23:59:59.999\"",
                2020,     1,    1,    23,    59,   59,  999,    true   },
    {   L_, "\"2020-01-01T23:59:59.999\"",
                2020,     1,    1,    23,    59,   59,  999,    true   },

    {   L_, "\"2020-01-02T00:00:00.000\"",
                2020,     1,    2,     0,     0,    0,    0,    true   },
    {   L_, "\"2020-01-02T00:00:00.000\"",
                2020,     1,    2,     0,     0,    0,    0,    true   },
    {   L_, "\"2020-01-02T00:00:00.000\"",
                2020,     1,    2,     0,     0,    0,    0,    true   },

    {   L_, "\"2020-02-28T00:00:00.000\"",
                2020,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"2020-02-28T23:59:59.000\"",
                2020,     2,   28,    23,    59,   59,    0,    true   },
    {   L_, "\"2020-02-28T23:59:59.000\"",
                2020,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"2020-02-29T00:00:00.000\"",
                2020,     2,   29,     0,     0,    0,    0,    true   },
    {   L_, "\"2020-02-29T23:59:59.000\"",
                2020,     2,   29,    23,    59,   59,    0,    true   },
    {   L_, "\"2020-02-29T23:59:59.000\"",
                2020,     2,   29,    23,    59,   59,    0,    true   },

    {   L_, "\"2020-03-01T00:00:00.000\"",
                2020,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"2020-03-01T23:59:59.000\"",
                2020,     3,    1,    23,    59,   59,    0,    true   },
    {   L_, "\"2020-03-01T23:59:59.000\"",
                2020,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"2021-01-02T00:00:00.000\"",
                2021,     1,    2,     0,     0,    0,    0,    true   },
    {   L_, "\"2022-01-02T00:00:00.000\"",
                2022,     1,    2,     0,     0,    0,    0,    true   },

    {   L_, "\"9999-02-28T00:00:00.000\"",
                9999,     2,   28,     0,     0,    0,    0,    true   },
    {   L_, "\"9999-02-28T23:59:59.000\"",
                9999,     2,   28,    23,    59,   59,    0,    true   },
    {   L_, "\"9999-02-28T23:59:59.000\"",
                9999,     2,   28,    23,    59,   59,    0,    true   },

    {   L_, "\"9999-03-01T00:00:00.000\"",
                9999,     3,    1,     0,     0,    0,    0,    true   },
    {   L_, "\"9999-03-01T23:59:59.000\"",
                9999,     3,    1,    23,    59,   59,    0,    true   },
    {   L_, "\"9999-03-01T23:59:59.000\"",
                9999,     3,    1,    23,    59,   59,    0,    true   },

    {   L_, "\"9999-12-30T00:00:00.000\"",
                9999,    12,   30,     0,     0,    0,    0,    true   },
    {   L_, "\"9999-12-30T23:59:59.000\"",
                9999,    12,   30,    23,    59,   59,    0,    true   },

    {   L_, "\"9999-12-31T00:00:00.000\"",
                9999,    12,   31,     0,     0,    0,    0,    true   },
    {   L_, "\"9999-12-31T23:59:59.000\"",
                9999,    12,   31,    23,    59,   59,    0,    true   },

    {   L_, "\"GARBAGE\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\".9999\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"T23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"01T23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"01-01T23:59:59.9999\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0001-01-01T00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },

    {   L_, "\"0000-01-01T00:00:00.000+00:00\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0000-01-01T00:00:00.000Z\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0000-01-01T00:00:00.000z\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0000-01-01T00:00:00.000-00:00\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },

    {   L_, "\"0000-01-01T00:00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0001-00-01T00:00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0001-01-00T00:00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0000-00-00T00:00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0001-13-00T00:00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0001-01-32T00:00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0001-01-01T25:00:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0001-01-01T00:61:00.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },
    {   L_, "\"0001-01-01T00:00:61.000\"",
                   1,     1,    1,    24,     0,    0,    0,    false  },

        };
            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int i = 0; i < NUM_DATA; ++i) {
                const int         LINE        = DATA[i].d_line;
                const string      INPUT       = DATA[i].d_input_p;
                const int         YEAR        = DATA[i].d_year;
                const int         MONTH       = DATA[i].d_month;
                const int         DAY         = DATA[i].d_day;
                const int         HOUR        = DATA[i].d_hour;
                const int         MINUTE      = DATA[i].d_minutes;
                const int         SECOND      = DATA[i].d_seconds;
                const int         MILLISECOND = DATA[i].d_milliSecs;
                const bool        IS_VALID    = DATA[i].d_isValid;

                bdet_Datetime exp(YEAR, MONTH, DAY,
                                  HOUR, MINUTE, SECOND, MILLISECOND);
                const bdet_Datetime& EXP = exp;

                bdet_Datetime value;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value,   EXP == value);
            }
        }
      } break;
      case 17: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for bdet_DateTz values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for 'bdet_DateTz'"
                               << "\n===================================="
                               << bsl::endl;
        {
            static const struct {
                int         d_line;      // source line number
                const char *d_input_p;   // input
                int         d_year;      // year under test
                int         d_month;     // month under test
                int         d_day;       // day under test
                int         d_tzoffset;  // time zone offset
                bool        d_isValid;   // isValid flag
            } DATA[] = {
    //line  input                      year month   day   offset isValid
    //----  -----                      ---- -----   ---   ------ -------
    {   L_, "\"0001-01-01+00:00\"",     1,     1,    1,       0,  true   },
    {   L_, "\"0001-01-01+00:45\"",     1,     1,    1,      45,  true   },
    {   L_, "\"0001-01-01-23:59\"",     1,     1,    1,   -1439,  true   },

    {   L_, "\"0001-01-01+00:00\"",     1,     1,    1,       0,  true   },
    {   L_, "\"0001-01-01+08:20\"",     1,     1,    1,     500,  true   },
    {   L_, "\"0001-01-01-23:59\"",     1,     1,    1,   -1439,  true   },
    {   L_, "\"0001-01-01+00:00\"",     1,     1,    1,       0,  true   },
    {   L_, "\"0001-01-01+23:59\"",     1,     1,    1,    1439,  true   },
    {   L_, "\"0001-01-01-23:59\"",     1,     1,    1,   -1439,  true   },

    {   L_, "\"0001-01-02+00:00\"",     1,     1,    2,       0,  true   },
    {   L_, "\"0001-01-02+23:59\"",     1,     1,    2,    1439,  true   },
    {   L_, "\"0001-01-02-23:59\"",     1,     1,    2,   -1439,  true   },
    {   L_, "\"0001-01-02+00:00\"",     1,     1,    2,       0,  true   },
    {   L_, "\"0001-01-02+08:20\"",     1,     1,    2,     500,  true   },

    {   L_, "\"0001-01-02+00:00\"",     1,     1,    2,       0,  true   },
    {   L_, "\"0001-01-02+08:20\"",     1,     1,    2,     500,  true   },
    {   L_, "\"0001-01-02-08:20\"",     1,     1,    2,    -500,  true   },

    {   L_, "\"0001-01-10+00:00\"",     1,     1,   10,       0,  true   },
    {   L_, "\"0001-01-10+01:39\"",     1,     1,   10,      99,  true   },

    {   L_, "\"0001-01-30+00:00\"",     1,     1,   30,       0,  true   },
    {   L_, "\"0001-01-31+23:59\"",     1,     1,   31,    1439,  true   },
    {   L_, "\"0001-01-31-23:59\"",     1,     1,   31,   -1439,  true   },

    {   L_, "\"0001-02-01+00:00\"",     1,     2,    1,       0,  true   },
    {   L_, "\"0001-02-01+23:59\"",     1,     2,    1,    1439,  true   },

    {   L_, "\"0001-12-31+00:00\"",     1,    12,   31,       0,  true   },
    {   L_, "\"0001-12-31+23:59\"",     1,    12,   31,    1439,  true   },

    {   L_, "\"0002-01-01+00:00\"",     2,     1,    1,       0,  true   },
    {   L_, "\"0002-01-01+23:59\"",     2,     1,    1,    1439,  true   },

    {   L_, "\"0004-01-01+00:00\"",     4,     1,    1,       0,  true   },
    {   L_, "\"0004-01-01+23:59\"",     4,     1,    1,    1439,  true   },

    {   L_, "\"0004-02-28+00:00\"",     4,     2,   28,       0,  true   },
    {   L_, "\"0004-02-28+23:59\"",     4,     2,   28,    1439,  true   },
    {   L_, "\"0004-02-28-23:59\"",     4,     2,   28,   -1439,  true   },

    {   L_, "\"0004-02-29+00:00\"",     4,     2,   29,       0,  true   },
    {   L_, "\"0004-02-29+23:59\"",     4,     2,   29,    1439,  true   },
    {   L_, "\"0004-02-29-23:59\"",     4,     2,   29,   -1439,  true   },

    {   L_, "\"0004-03-01+00:00\"",     4,     3,    1,       0,  true   },
    {   L_, "\"0004-03-01+23:59\"",     4,     3,    1,    1439,  true   },
    {   L_, "\"0004-03-01-23:59\"",     4,     3,    1,   -1439,  true   },

    {   L_, "\"0008-02-28+00:00\"",     8,     2,   28,       0,  true   },
    {   L_, "\"0008-02-28+23:59\"",     8,     2,   28,    1439,  true   },

    {   L_, "\"0008-02-29+00:00\"",     8,     2,   29,       0,  true   },
    {   L_, "\"0008-02-29+23:59\"",     8,     2,   29,    1439,  true   },

    {   L_, "\"0008-03-01+00:00\"",     8,     3,    1,       0,  true   },
    {   L_, "\"0008-03-01+23:59\"",     8,     3,    1,    1439,  true   },

    {   L_, "\"0100-02-28+00:00\"",   100,     2,   28,       0,  true   },
    {   L_, "\"0100-02-28+23:59\"",   100,     2,   28,    1439,  true   },
    {   L_, "\"0100-02-28-23:59\"",   100,     2,   28,   -1439,  true   },

    {   L_, "\"0100-03-01+00:00\"",   100,     3,    1,       0,  true   },
    {   L_, "\"0100-03-01+23:59\"",   100,     3,    1,    1439,  true   },
    {   L_, "\"0100-03-01-23:59\"",   100,     3,    1,   -1439,  true   },

    {   L_, "\"0400-02-28+00:00\"",   400,     2,   28,       0,  true   },
    {   L_, "\"0400-02-28+23:59\"",   400,     2,   28,    1439,  true   },
    {   L_, "\"0400-02-28-23:59\"",   400,     2,   28,   -1439,  true   },

    {   L_, "\"0400-02-29+00:00\"",   400,     2,   29,       0,  true   },
    {   L_, "\"0400-02-29+23:59\"",   400,     2,   29,    1439,  true   },
    {   L_, "\"0400-02-29-23:59\"",   400,     2,   29,   -1439,  true   },

    {   L_, "\"0400-03-01+00:00\"",   400,     3,    1,       0,  true   },
    {   L_, "\"0400-03-01+23:59\"",   400,     3,    1,    1439,  true   },
    {   L_, "\"0400-03-01-23:59\"",   400,     3,    1,   -1439,  true   },

    {   L_, "\"0500-02-28+00:00\"",   500,     2,   28,       0,  true   },
    {   L_, "\"0500-02-28+23:59\"",   500,     2,   28,    1439,  true   },

    {   L_, "\"0500-03-01+00:00\"",   500,     3,    1,       0,  true   },
    {   L_, "\"0500-03-01+23:59\"",   500,     3,    1,    1439,  true   },

    {   L_, "\"0800-02-28+00:00\"",   800,     2,   28,       0,  true   },
    {   L_, "\"0800-02-28+23:59\"",   800,     2,   28,    1439,  true   },

    {   L_, "\"0800-02-29+00:00\"",   800,     2,   29,       0,  true   },
    {   L_, "\"0800-02-29+23:59\"",   800,     2,   29,    1439,  true   },

    {   L_, "\"0800-03-01+00:00\"",   800,     3,    1,       0,  true   },
    {   L_, "\"0800-03-01+23:59\"",   800,     3,    1,    1439,  true   },

    {   L_, "\"1000-02-28+00:00\"",  1000,     2,   28,       0,  true   },
    {   L_, "\"1000-02-28+23:59\"",  1000,     2,   28,    1439,  true   },

    {   L_, "\"1000-03-01+00:00\"",  1000,     3,    1,       0,  true   },
    {   L_, "\"1000-03-01+23:59\"",  1000,     3,    1,    1439,  true   },

    {   L_, "\"2000-02-28+00:00\"",  2000,     2,   28,       0,  true   },
    {   L_, "\"2000-02-28+23:59\"",  2000,     2,   28,    1439,  true   },

    {   L_, "\"2000-02-29+00:00\"",  2000,     2,   29,       0,  true   },
    {   L_, "\"2000-02-29+23:59\"",  2000,     2,   29,    1439,  true   },

    {   L_, "\"2000-03-01+00:00\"",  2000,     3,    1,       0,  true   },
    {   L_, "\"2000-03-01+23:59\"",  2000,     3,    1,    1439,  true   },

    {   L_, "\"2016-12-31+00:00\"",  2016,    12,   31,       0,  true   },
    {   L_, "\"2017-12-31+00:00\"",  2017,    12,   31,       0,  true   },
    {   L_, "\"2018-12-31+00:00\"",  2018,    12,   31,       0,  true   },
    {   L_, "\"2019-12-31+00:00\"",  2019,    12,   31,       0,  true   },

    {   L_, "\"2020-01-01+00:00\"",  2020,     1,    1,       0,  true   },
    {   L_, "\"2020-01-01+23:59\"",  2020,     1,    1,    1439,  true   },
    {   L_, "\"2020-01-01-23:59\"",  2020,     1,    1,   -1439,  true   },

    {   L_, "\"2020-01-01+00:00\"",  2020,     1,    1,       0,  true   },
    {   L_, "\"2020-01-01+23:59\"",  2020,     1,    1,    1439,  true   },
    {   L_, "\"2020-01-01-23:59\"",  2020,     1,    1,   -1439,  true   },

    {   L_, "\"2020-01-02+00:00\"",  2020,     1,    2,       0,  true   },
    {   L_, "\"2020-01-02+23:59\"",  2020,     1,    2,    1439,  true   },
    {   L_, "\"2020-01-02-23:59\"",  2020,     1,    2,   -1439,  true   },

    {   L_, "\"2020-02-28+00:00\"",  2020,     2,   28,       0,  true   },
    {   L_, "\"2020-02-28+23:59\"",  2020,     2,   28,    1439,  true   },
    {   L_, "\"2020-02-28-23:59\"",  2020,     2,   28,   -1439,  true   },

    {   L_, "\"2020-02-29+00:00\"",  2020,     2,   29,       0,  true   },
    {   L_, "\"2020-02-29+23:59\"",  2020,     2,   29,    1439,  true   },
    {   L_, "\"2020-02-29-23:59\"",  2020,     2,   29,   -1439,  true   },

    {   L_, "\"2020-03-01+00:00\"",  2020,     3,    1,       0,  true   },
    {   L_, "\"2020-03-01+23:59\"",  2020,     3,    1,    1439,  true   },
    {   L_, "\"2020-03-01-23:59\"",  2020,     3,    1,   -1439,  true   },

    {   L_, "\"2021-01-02+00:00\"",  2021,     1,    2,       0,  true   },
    {   L_, "\"2022-01-02+00:00\"",  2022,     1,    2,       0,  true   },

    {   L_, "\"9999-02-28+00:00\"",  9999,     2,   28,       0,  true   },
    {   L_, "\"9999-02-28+23:59\"",  9999,     2,   28,    1439,  true   },
    {   L_, "\"9999-02-28-23:59\"",  9999,     2,   28,   -1439,  true   },

    {   L_, "\"9999-03-01+00:00\"",  9999,     3,    1,       0,  true   },
    {   L_, "\"9999-03-01+23:59\"",  9999,     3,    1,    1439,  true   },
    {   L_, "\"9999-03-01-23:59\"",  9999,     3,    1,   -1439,  true   },

    {   L_, "\"9999-12-30+00:00\"",  9999,    12,   30,       0,  true   },
    {   L_, "\"9999-12-30+23:59\"",  9999,    12,   30,    1439,  true   },

    {   L_, "\"9999-12-31+00:00\"",  9999,    12,   31,       0,  true   },
    {   L_, "\"9999-12-31+23:59\"",  9999,    12,   31,    1439,  true   },

    {   L_, "\"GARBAGE\"",              1,     1,    1,       0,  false  },
    {   L_, "\"0000-01-01Z\"",          1,     1,    1,       0,  false  },
    {   L_, "\"0000-01-01z\"",          1,     1,    1,       0,  false  },
    {   L_, "\"0000-01-01+00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0000-01-01-00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"9999-00-01+00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"9999-00-01-00:00\"",     1,     1,    1,       0,  false  },

    {   L_, "\"0000-01-01+00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0001-00-01+00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0001-01-00+00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0000-00-00+00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0001-13-00+00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0001-01-32+00:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0001-01-01+24:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0001-01-01+00:61\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0001-01-01-24:00\"",     1,     1,    1,       0,  false  },
    {   L_, "\"0001-01-01-00:61\"",     1,     1,    1,       0,  false  },

    {   L_, "\"0001-01-01T00:00:00.000+00:00\"",
                                        1,     1,    1,       0,  false  },
        };
            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int i = 0; i < NUM_DATA; ++i) {
                const int         LINE        = DATA[i].d_line;
                const string      INPUT       = DATA[i].d_input_p;
                const int         YEAR        = DATA[i].d_year;
                const int         MONTH       = DATA[i].d_month;
                const int         DAY         = DATA[i].d_day;
                const int         OFFSET      = DATA[i].d_tzoffset;
                const bool        IS_VALID    = DATA[i].d_isValid;

                bdet_Date d(YEAR, MONTH, DAY);  const bdet_Date& D = d;
                bdet_DateTz exp(D, OFFSET);  const bdet_DateTz& EXP = exp;

                bdet_DateTz value;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value,   EXP == value);
            }
        }
      } break;
      case 16: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for bdet_Date values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for 'bdet_Date' types"
                               << "\n========================================"
                               << bsl::endl;
        {
            static const struct {
                int         d_line;      // source line number
                const char *d_input_p;   // input
                int         d_year;      // year under test
                int         d_month;     // month under test
                int         d_day;       // day under test
                bool        d_isValid;   // isValid flag
            } DATA[] = {
  //line  input                       year  month  day  isValid
  //----  -----                       ----  -----  ---  -------
  {  L_, "\"0001-01-01\"",             1,     1,    1,   true   },
  {  L_, "\"0001-01-02\"",             1,     1,    2,   true   },
  {  L_, "\"0001-01-10\"",             1,     1,   10,   true   },
  {  L_, "\"0001-01-30\"",             1,     1,   30,   true   },
  {  L_, "\"0001-01-31\"",             1,     1,   31,   true   },

  {  L_, "\"0001-02-01\"",             1,     2,    1,   true   },
  {  L_, "\"0001-12-31\"",             1,    12,   31,   true   },
  {  L_, "\"0002-01-01\"",             2,     1,    1,   true   },
  {  L_, "\"0004-01-01\"",             4,     1,    1,   true   },
  {  L_, "\"0004-02-28\"",             4,     2,   28,   true   },
  {  L_, "\"0004-02-29\"",             4,     2,   29,   true   },
  {  L_, "\"0004-03-01\"",             4,     3,    1,   true   },

  {  L_, "\"0008-02-28\"",             8,     2,   28,   true   },
  {  L_, "\"0008-02-29\"",             8,     2,   29,   true   },
  {  L_, "\"0008-03-01\"",             8,     3,    1,   true   },
  {  L_, "\"0100-02-28\"",           100,     2,   28,   true   },
  {  L_, "\"0100-03-01\"",           100,     3,    1,   true   },
  {  L_, "\"0400-02-28\"",           400,     2,   28,   true   },
  {  L_, "\"0400-02-29\"",           400,     2,   29,   true   },
  {  L_, "\"0400-03-01\"",           400,     3,    1,   true   },
  {  L_, "\"0500-02-28\"",           500,     2,   28,   true   },
  {  L_, "\"0500-03-01\"",           500,     3,    1,   true   },

  {  L_, "\"0800-02-28\"",           800,     2,   28,   true   },
  {  L_, "\"0800-02-29\"",           800,     2,   29,   true   },
  {  L_, "\"0800-03-01\"",           800,     3,    1,   true   },
  {  L_, "\"1000-02-28\"",          1000,     2,   28,   true   },
  {  L_, "\"1000-03-01\"",          1000,     3,    1,   true   },
  {  L_, "\"2000-02-28\"",          2000,     2,   28,   true   },
  {  L_, "\"2000-02-29\"",          2000,     2,   29,   true   },
  {  L_, "\"2000-03-01\"",          2000,     3,    1,   true   },
  {  L_, "\"2016-12-31\"",          2016,    12,   31,   true   },
  {  L_, "\"2017-12-31\"",          2017,    12,   31,   true   },
  {  L_, "\"2018-12-31\"",          2018,    12,   31,   true   },
  {  L_, "\"2019-12-31\"",          2019,    12,   31,   true   },

  {  L_, "\"2020-01-01\"",          2020,     1,    1,   true   },
  {  L_, "\"2020-01-02\"",          2020,     1,    2,   true   },
  {  L_, "\"2020-02-28\"",          2020,     2,   28,   true   },
  {  L_, "\"2020-02-29\"",          2020,     2,   29,   true   },
  {  L_, "\"2020-03-01\"",          2020,     3,    1,   true   },
  {  L_, "\"2022-01-02\"",          2022,     1,    2,   true   },

  {  L_, "\"9999-02-28\"",          9999,     2,   28,   true   },
  {  L_, "\"9999-03-01\"",          9999,     3,    1,   true   },
  {  L_, "\"9999-12-30\"",          9999,    12,   30,   true   },
  {  L_, "\"9999-12-31\"",          9999,    12,   31,   true   },

  {  L_, "\"GARBAGE\"",                1,     1,    1,   false  },
  {  L_, "\"0001-01-01Z\"",            1,     1,    1,   false  },
  {  L_, "\"0001-01-01z\"",            1,     1,    1,   false  },
  {  L_, "\"0001-01-01+00:00\"",       1,     1,    1,   false  },
  {  L_, "\"0001-01-01-00:00\"",       1,     1,    1,   false  },
  {  L_, "\"9999-01-01+00:00\"",       1,     1,    1,   false  },
  {  L_, "\"9999-01-01-00:00\"",       1,     1,    1,   false  },

  {  L_, "\"0000-01-01\"",             1,     1,    1,   false  },
  {  L_, "\"0001-00-01\"",             1,     1,    1,   false  },
  {  L_, "\"0001-01-00\"",             1,     1,    1,   false  },
  {  L_, "\"0000-00-00\"",             1,     1,    1,   false  },
  {  L_, "\"0001-13-00\"",             1,     1,    1,   false  },
  {  L_, "\"0001-01-32\"",             1,     1,    1,   false  },

  {  L_, "\"0001-01-01T00:00:00.000+00:00\"",
                                       1,     1,    1,   false  },
        };
            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int i = 0; i < NUM_DATA; ++i) {
                const int         LINE        = DATA[i].d_line;
                const string      INPUT       = DATA[i].d_input_p;
                const int         YEAR        = DATA[i].d_year;
                const int         MONTH       = DATA[i].d_month;
                const int         DAY         = DATA[i].d_day;
                const bool        IS_VALID    = DATA[i].d_isValid;

                bdet_Date exp(YEAR, MONTH, DAY);  const bdet_Date& EXP = exp;

                bdet_Date value;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value,   EXP == value);
            }
        }
      } break;
      case 15: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for bdet_TimeTz values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for 'bdet_TimeTz'"
                               << "\n===================================="
                               << bsl::endl;
        {
            static const struct {
                int         d_line;      // source line number
                const char *d_input_p;   // input
                int         d_hour;      // hour under test
                int         d_minutes;   // minutes under test
                int         d_seconds;   // seconds under test
                int         d_milliSecs; // milli seconds under test
                int         d_tzoffset;  // time zone offset
                bool        d_isValid;   // isValid flag
            } DATA[] = {
  //line    input                    hour    min   sec    ms  offset isValid
  //----    -----                    ----    ---   ---    --  ------ -------
  {  L_, "\"00:00:00.000+00:00\"",     0,     0,    0,    0,      0,  true   },
  {  L_, "\"00:00:00.000Z\"",          0,     0,    0,    0,      0,  true   },
  {  L_, "\"00:00:00.000z\"",          0,     0,    0,    0,      0,  true   },
  {  L_, "\"00:00:00.000+00:45\"",     0,     0,    0,    0,     45,  true   },
  {  L_, "\"00:00:00.000+23:59\"",     0,     0,    0,    0,   1439,  true   },
  {  L_, "\"00:00:00.000-23:59\"",     0,     0,    0,    0,  -1439,  true   },

  {  L_, "\"00:00:00.999+00:00\"",     0,     0,    0,  999,      0,  true   },
  {  L_, "\"00:00:00.999+23:59\"",     0,     0,    0,  999,   1439,  true   },
  {  L_, "\"00:00:00.999-23:59\"",     0,     0,    0,  999,  -1439,  true   },

  {  L_, "\"00:00:01.000+00:00\"",     0,     0,    1,    0,      0,  true   },
  {  L_, "\"00:00:01.000z\"",          0,     0,    1,    0,      0,  true   },
  {  L_, "\"00:00:01.000+23:59\"",     0,     0,    1,    0,   1439,  true   },
  {  L_, "\"00:00:01.000-23:59\"",     0,     0,    1,    0,  -1439,  true   },

  {  L_, "\"00:00:59.000+00:00\"",     0,     0,   59,    0,      0,  true   },
  {  L_, "\"00:00:59.000Z\"",          0,     0,   59,    0,      0,  true   },
  {  L_, "\"00:00:59.000+23:59\"",     0,     0,   59,    0,   1439,  true   },
  {  L_, "\"00:00:59.000-23:59\"",     0,     0,   59,    0,  -1439,  true   },

  {  L_, "\"01:01:01.001+00:00\"",     1,     1,    1,    1,      0,  true   },
  {  L_, "\"01:01:01.001+08:20\"",     1,     1,    1,    1,    500,  true   },

  {  L_, "\"01:23:59.059+00:00\"",     1,    23,   59,   59,      0,  true   },
  {  L_, "\"01:23:59.059z\"",          1,    23,   59,   59,      0,  true   },
  {  L_, "\"01:23:59.059+23:59\"",     1,    23,   59,   59,   1439,  true   },
  {  L_, "\"01:23:59.059-23:59\"",     1,    23,   59,   59,  -1439,  true   },

  {  L_, "\"23:59:59.000+23:59\"",    23,    59,   59,    0,   1439,  true   },
  {  L_, "\"23:59:59.000-23:59\"",    23,    59,   59,    0,  -1439,  true   },

  {  L_, "\"23:59:59.999+00:00\"",    23,    59,   59,  999,      0,  true   },
  {  L_, "\"23:59:59.999Z\"",         23,    59,   59,  999,      0,  true   },
  {  L_, "\"23:59:59.999+23:59\"",    23,    59,   59,  999,   1439,  true   },
  {  L_, "\"23:59:59.999-23:59\"",    23,    59,   59,  999,  -1439,  true   },

  {  L_, "\"24:00:00.000+00:00\"",    24,     0,    0,    0,      0,  true   },
  {  L_, "\"24:00:00.000Z\"",         24,     0,    0,    0,      0,  true   },
  {  L_, "\"24:00:00.000z\"",         24,     0,    0,    0,      0,  true   },

  {  L_, "\"GARBAGE\"",               24,     0,    0,    0,      0,  false  },
  {  L_, "\".9999\"",                 24,     0,    0,    0,      0,  false  },
         // ^
  {  L_, "\"23.9999\"",               24,     0,    0,    0,      0,  false  },
           // ^
  {  L_, "\"23:59.9999\"",            24,     0,    0,    0,      0,  false  },
              // ^
// TBD: No TZ should fail
//   {  L_, "\"23:59.59.9999\"",      24,     0,    0,    0,      0,  false  },
                         // ^

  {  L_, "\"25:00:00.000+00:00\"",    24,     0,    0,    0,      0,  false  },
  {  L_, "\"00:61:00.000+00:00\"",    24,     0,    0,    0,      0,  false  },
  {  L_, "\"00:00:61.000+00:00\"",    24,     0,    0,    0,      0,  false  },
  {  L_, "\"00:00:00.000+24:00\"",    24,     0,    0,    0,      0,  false  },
  {  L_, "\"00:00:00.000+00:61\"",    24,     0,    0,    0,      0,  false  },
  {  L_, "\"00:00:00.000-24:00\"",    24,     0,    0,    0,      0,  false  },
  {  L_, "\"00:00:00.000-00:61\"",    24,     0,    0,    0,      0,  false  },

  {  L_, "\"0001-01-01T00:00:00.000+00:00\"",
                                      24,     0,    0,    0,      0,  false  },
        };
            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int i = 0; i < NUM_DATA; ++i) {
                const int         LINE        = DATA[i].d_line;
                const string      INPUT       = DATA[i].d_input_p;
                const int         HOUR        = DATA[i].d_hour;
                const int         MINUTE      = DATA[i].d_minutes;
                const int         SECOND      = DATA[i].d_seconds;
                const int         MILLISECOND = DATA[i].d_milliSecs;
                const int         OFFSET      = DATA[i].d_tzoffset;
                const bool        IS_VALID    = DATA[i].d_isValid;

                bdet_Time t(HOUR, MINUTE, SECOND, MILLISECOND);
                const bdet_Time& T = t;
                bdet_TimeTz exp(T, OFFSET); const bdet_TimeTz& EXP = exp;

                bdet_TimeTz value;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value,   EXP == value);
            }
        }
      } break;
      case 14: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for bdet_Time values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for 'bdet_Time'"
                               << "\n=================================="
                               << bsl::endl;
        {
            static const struct {
                int         d_line;      // source line number
                const char *d_input_p;   // input
                int         d_hour;      // hour under test
                int         d_minutes;   // minutes under test
                int         d_seconds;   // seconds under test
                int         d_milliSecs; // milli seconds under test
                bool        d_isValid;   // isValid flag
            } DATA[] = {
  //line    input                 hour    min   sec    ms  isValid
  //----    -----                 ----    ---   ---    --  -------
  {  L_, "\"00:00:00\"",            0,     0,    0,    0,  true   },
  {  L_, "\"00:00:00.000\"",        0,     0,    0,    0,  true   },
  {  L_, "\"00:00:00.999\"",        0,     0,    0,  999,  true   },

  {  L_, "\"00:00:01\"",            0,     0,    1,    0,  true   },
  {  L_, "\"00:00:01.000\"",        0,     0,    1,    0,  true   },
  {  L_, "\"00:00:59.000\"",        0,     0,   59,    0,  true   },
  {  L_, "\"01:01:01.001\"",        1,     1,    1,    1,  true   },

  {  L_, "\"01:23:59\"",            1,    23,   59,    0,  true   },
  {  L_, "\"01:23:59.059\"",        1,    23,   59,   59,  true   },
  {  L_, "\"23:59:59.000\"",       23,    59,   59,    0,  true   },
  {  L_, "\"23:59:59.999\"",       23,    59,   59,  999,  true   },

  {  L_, "\"24:00:00\"",           24,     0,    0,    0,  true   },
  {  L_, "\"24:00:00.000\"",       24,     0,    0,    0,  true   },

  {  L_, "\"GARBAGE\"",            24,     0,    0,    0,  false  },
  {  L_, "\".9999\"",              24,     0,    0,    0,  false  },
         // ^
  {  L_, "\"23.9999\"",            24,     0,    0,    0,  false  },
           // ^
  {  L_, "\"23:59.9999\"",         24,     0,    0,    0,  false  },
              // ^
  {  L_, "\"23:59:59.9999\"",      24,     0,    0,    0,  false  },
                     // ^

  {  L_, "\"25:00:00.000\"",       24,     0,    0,    0,  false  },
  {  L_, "\"00:61:00.000\"",       24,     0,    0,    0,  false  },
  {  L_, "\"00:00:61.000\"",       24,     0,    0,    0,  false  },

  {  L_, "\"01:01:01.001+00:00\"", 24,     0,    0,    0,  false  },
  {  L_, "\"01:01:01.001Z\"",      24,     0,    0,    0,  false  },
  {  L_, "\"01:01:01.001z\"",      24,     0,    0,    0,  false  },
  {  L_, "\"23:59:59.999-00:00\"", 24,     0,    0,    0,  false  },
  {  L_, "\"23:59:59.999Z\"",      24,     0,    0,    0,  false  },
  {  L_, "\"23:59:59.999z\"",      24,     0,    0,    0,  false  },

  {  L_, "\"0001-01-01+00:00\"",   24,     0,    0,    0,  false  },
  {  L_, "\"0001-01-01-00:00\"",   24,     0,    0,    0,  false  },

  {  L_, "\"0001-01-01T00:00:00.000+00:00\"",
                                   24,     0,    0,    0,  false  },
        };
            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int i = 0; i < NUM_DATA; ++i) {
                const int         LINE        = DATA[i].d_line;
                const string      INPUT       = DATA[i].d_input_p;
                const int         HOUR        = DATA[i].d_hour;
                const int         MINUTE      = DATA[i].d_minutes;
                const int         SECOND      = DATA[i].d_seconds;
                const int         MILLISECOND = DATA[i].d_milliSecs;
                const bool        IS_VALID    = DATA[i].d_isValid;

                bdet_Time exp(HOUR, MINUTE, SECOND, MILLISECOND);
                const bdet_Time& EXP = exp;

                bdet_Time value;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value,   EXP == value);
            }
        }
      } break;
      case 13: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for string values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for string"
                               << "\n============================="
                               << bsl::endl;
        {
            typedef bsl::string Type;

            const Type ERROR_VALUE = "DEADBEEF";

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input           exp          isValid
                // ----   -----           ---          -------
                {  L_,    "\"\"",         "",           true },
                {  L_,    "\"ABC\"",      "ABC",        true },

// TBD:
//                 {  L_,    "Non-utf string", ERROR_VALUE,      false    },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 12: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for double values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for double"
                               << "\n============================="
                               << bsl::endl;
        {
            typedef double Type;

            Type posInf = bsl::numeric_limits<Type>::infinity();
            Type qNaN   = bsl::numeric_limits<Type>::quiet_NaN();
            Type sNaN   = bsl::numeric_limits<Type>::signaling_NaN();

            const Type ERROR_VALUE = 99.99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input                         exp    isValid
                // ----   -----                         ---    -------
                {  L_,      "0",                      0.0,     true    },
                {  L_,      "1",                      1.0,     true    },
                {  L_,     "-1",                     -1.0,     true    },
                {  L_,     "0.1",                     0.1,     true    },
                {  L_,     "-0.1",                   -0.1,     true    },
                {  L_,     "0.12345",             0.12345,     true    },
                {  L_,     "-1.234567e-35",  -1.234567e-35,     true    },
                {  L_,     "1234567.0",         1234567.0,     true    },
                {  L_,     "1234567e+35",       1234567e35,     true    },

                {  L_,     "95",                      95,       true    },
                {  L_,    "127",                     127,       true    },
                {  L_,    "128",                     128,       true    },
                {  L_,    "200",                     200,       true    },
                {  L_,    "255",                     255,       true    },
                {  L_,  "32767",                   32767,       true    },
                {  L_,  "32768",                   32768,       true    },
                {  L_,  "65534",                   65534,       true    },
                {  L_,  "65535",                   65535,       true    },

                {  L_,   "8388607",              8388607,       true    },
                {  L_,   "8388608",              8388608,       true    },

                {  L_,   "2147483646",        2147483646,       true    },
                {  L_,   "2147483647",        2147483647,       true    },

                {  L_,   "4294967294",      4294967294LL,       true    },
                {  L_,   "4294967295",      4294967295LL,       true    },

                {  L_,    "1.1",                     1.1,       true    },
                {  L_,    "1.5",                     1.5,       true    },
//                 {  L_,    "1.9",                     1.9,       true    },

//                 {  L_,   "100.123",              100.123,      true    },
                {  L_,   "99.5",                    99.5,      true    },
//                 {  L_,    "0.86",                   0.86,      true    },

                {  L_,    "1e0",                       1,       true    },
                {  L_,    "1E0",                       1,       true    },
                {  L_,    "1e+0",                      1,       true    },
                {  L_,    "1E+0",                      1,       true    },
                {  L_,    "1e-0",                      1,       true    },
                {  L_,    "1E-0",                      1,       true    },

                {  L_,    "1.234e+1",             12.34,       true    },
                {  L_,    "1.987E+1",             19.87,       true    },

                {  L_,    "12.34e-1",              1.234,      true    },
                {  L_,    "29.87E-1",              2.987,      true    },

//                 {  L_,    "-123.34e-1",          -12.334,      true    },
                {  L_,    "-298.7E-1",            -29.87,      true    },

                {  L_,    "1e1",                      10,       true    },
                {  L_,    "1E1",                      10,       true    },
                {  L_,    "1e+1",                     10,       true    },
                {  L_,    "1E+1",                     10,       true    },
                {  L_,    "1e-1",                    0.1,       true    },
                {  L_,    "1E-1",                    0.1,       true    },

// TBD:
//                 {  L_,    "4294967296", ERROR_VALUE,      false    },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 11: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for float values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for float"
                               << "\n============================"
                               << bsl::endl;
        {
            typedef float Type;

            Type posInf = bsl::numeric_limits<Type>::infinity();
            Type qNaN   = bsl::numeric_limits<Type>::quiet_NaN();
            Type sNaN   = bsl::numeric_limits<Type>::signaling_NaN();

            const Type ERROR_VALUE = 99.99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input                         exp    isValid
                // ----   -----                         ---    -------
                {  L_,      "0",                      0.0f,     true    },
                {  L_,      "1",                      1.0f,     true    },
                {  L_,     "-1",                     -1.0f,     true    },
                {  L_,     "0.1",                     0.1f,     true    },
                {  L_,     "-0.1",                   -0.1f,     true    },
                {  L_,     "0.12345",             0.12345f,     true    },
                {  L_,     "-1.234567e-35",  -1.234567e-35,     true    },
                {  L_,     "1234567.0",         1234567.0f,     true    },
                {  L_,     "1234567e+35",       1234567e35,     true    },

                {  L_,     "95",                      95,       true    },
                {  L_,    "127",                     127,       true    },
                {  L_,    "128",                     128,       true    },
                {  L_,    "200",                     200,       true    },
                {  L_,    "255",                     255,       true    },
                {  L_,  "32767",                   32767,       true    },
                {  L_,  "32768",                   32768,       true    },
                {  L_,  "65534",                   65534,       true    },
                {  L_,  "65535",                   65535,       true    },

                {  L_,   "8388607",              8388607,       true    },
                {  L_,   "8388608",              8388608,       true    },

                {  L_,   "2147483646",        2147483646,       true    },
                {  L_,   "2147483647",        2147483647,       true    },

                {  L_,   "4294967294",      4294967294LL,       true    },
                {  L_,   "4294967295",      4294967295LL,       true    },

                {  L_,    "1.1",                    1.1f,       true    },
                {  L_,    "1.5",                    1.5f,       true    },
                {  L_,    "1.9",                    1.9f,       true    },

                {  L_,   "100.123",              100.123,       true    },
                {  L_,   "99.5",                    99.5,       true    },
                {  L_,    "0.86",                   0.86,       true    },

                {  L_,    "1e0",                       1,       true    },
                {  L_,    "1E0",                       1,       true    },
                {  L_,    "1e+0",                      1,       true    },
                {  L_,    "1E+0",                      1,       true    },
                {  L_,    "1e-0",                      1,       true    },
                {  L_,    "1E-0",                      1,       true    },

                {  L_,    "1.234e+1",             12.34f,       true    },
                {  L_,    "1.987E+1",             19.87f,       true    },

                {  L_,    "12.34e-1",             1.234f,       true    },
                {  L_,    "29.87E-1",             2.987f,       true    },

                {  L_,    "-123.34e-1",         -12.334f,       true    },
                {  L_,    "-298.7E-1",           -29.87f,       true    },

                {  L_,    "1e1",                      10,       true    },
                {  L_,    "1E1",                      10,       true    },
                {  L_,    "1e+1",                     10,       true    },
                {  L_,    "1E+1",                     10,       true    },
                {  L_,    "1e-1",                    0.1,       true    },
                {  L_,    "1E-1",                    0.1,       true    },

// TBD:
//                 {  L_,    "4294967296", ERROR_VALUE,      false    },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 10: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for Uint64 values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for Uint64"
                               << "\n============================="
                               << bsl::endl;

        {
            typedef Uint64 Type;

            const Type ERROR_VALUE = 99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input                       exp     isValid
                // ----   -----                       ---     -------
                {  L_,      "0",                       0,      true    },
                {  L_,      "1",                       1,      true    },
                {  L_,     "95",                      95,      true    },
                {  L_,    "127",                     127,      true    },
                {  L_,    "128",                     128,      true    },
                {  L_,    "200",                     200,      true    },
                {  L_,    "255",                     255,      true    },
                {  L_,  "32767",                   32767,      true    },
                {  L_,  "32768",                   32768,      true    },
                {  L_,  "65534",                   65534,      true    },
                {  L_,  "65535",                   65535,      true    },

                {  L_,   "8388607",              8388607,      true    },
                {  L_,   "8388608",              8388608,      true    },

                {  L_,   "2147483646",        2147483646,      true    },
                {  L_,   "2147483647",        2147483647,      true    },

                {  L_,   "4294967294",      4294967294LL,      true    },
                {  L_,   "4294967295",      4294967295LL,      true    },

                {  L_,   "9223372036854775806",  9223372036854775806LL, true },
                {  L_,   "9223372036854775807",  9223372036854775807LL, true },

                {  L_,    "1.1",                       1,      true    },
                {  L_,    "1.5",                       1,      true    },
                {  L_,    "1.9",                       1,      true    },

                {  L_,   "100.123",                  100,      true    },
                {  L_,   "99.5",                      99,      true    },
                {  L_,    "0.86",                      0,      true    },

                {  L_,    "1e0",                       1,      true    },
                {  L_,    "1E0",                       1,      true    },
                {  L_,    "1e+0",                      1,      true    },
                {  L_,    "1E+0",                      1,      true    },
                {  L_,    "1e-0",                      1,      true    },
                {  L_,    "1E-0",                      1,      true    },

                {  L_,    "1.234e+1",                 12,      true    },
                {  L_,    "1.987E+1",                 19,      true    },

                {  L_,    "12.34e-1",                  1,      true    },
                {  L_,    "29.87E-1",                  2,      true    },

                {  L_,    "1e1",                      10,      true    },
                {  L_,    "1E1",                      10,      true    },
                {  L_,    "1e+1",                     10,      true    },
                {  L_,    "1E+1",                     10,      true    },
                {  L_,    "1e-1",                      0,      true    },
                {  L_,    "1E-1",                      0,      true    },

// TBD:
//                 {  L_,    "4294967296", ERROR_VALUE,      false    },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 9: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for Int64 values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for Int64"
                               << "\n============================"
                               << bsl::endl;

        {
            typedef Int64 Type;

            const Type ERROR_VALUE = 99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input                       exp     isValid
                // ----   -----                       ---     -------
                {  L_,      "0",                       0,      true    },
                {  L_,      "1",                       1,      true    },
                {  L_,     "95",                      95,      true    },
                {  L_,    "127",                     127,      true    },
                {  L_,    "128",                     128,      true    },
                {  L_,   "-127",                    -127,      true    },
                {  L_,   "-128",                    -128,      true    },
                {  L_,   "-129",                    -129,      true    },
                {  L_,    "200",                     200,      true    },
                {  L_,    "255",                     255,      true    },
                {  L_,  "32767",                   32767,      true    },
                {  L_,  "32768",                   32768,      true    },
                {  L_,  "-32767",                 -32767,      true    },
                {  L_,  "-32768",                 -32768,      true    },
                {  L_,  "-32769",                 -32769,      true    },
                {  L_,  "65534",                   65534,      true    },
                {  L_,  "65535",                   65535,      true    },
                {  L_,  "-65534",                 -65534,      true    },
                {  L_,  "-65535",                 -65535,      true    },
                {  L_,  "-65536",                 -65536,      true    },

                {  L_,   "8388607",              8388607,      true    },
                {  L_,   "8388608",              8388608,      true    },
                {  L_,  "-8388608",             -8388608,      true    },
                {  L_,  "-8388609",             -8388609,      true    },

                {  L_,   "2147483646",        2147483646,      true    },
                {  L_,   "2147483647",        2147483647,      true    },
                {  L_,  "-2147483647",       -2147483647,      true    },
                {  L_,  "-2147483648",     -2147483648LL,      true    },

                {  L_,   "4294967294",      4294967294LL,      true    },
                {  L_,   "4294967295",      4294967295LL,      true    },
                {  L_,  "-4294967295",     -4294967295LL,      true    },
                {  L_,  "-4294967296",     -4294967296LL,      true    },

                {  L_,   "4294967294",      4294967294LL,      true    },
                {  L_,   "4294967295",      4294967295LL,      true    },
                {  L_,  "-4294967295",     -4294967295LL,      true    },
                {  L_,  "-4294967296",     -4294967296LL,      true    },

                {  L_,   "9223372036854775806",  9223372036854775806LL, true },
                {  L_,   "9223372036854775807",  9223372036854775807LL, true },
                {  L_,  "-9223372036854775807", -9223372036854775807LL, true },
                {  L_,  "-9223372036854775808", -9223372036854775808LL, true },

                {  L_,    "1.1",                       1,      true    },
                {  L_,    "1.5",                       1,      true    },
                {  L_,    "1.9",                       1,      true    },

                {  L_,   "100.123",                  100,      true    },
                {  L_,   "99.5",                      99,      true    },
                {  L_,    "0.86",                      0,      true    },

                {  L_,    "1e0",                       1,      true    },
                {  L_,    "1E0",                       1,      true    },
                {  L_,    "1e+0",                      1,      true    },
                {  L_,    "1E+0",                      1,      true    },
                {  L_,    "1e-0",                      1,      true    },
                {  L_,    "1E-0",                      1,      true    },

                {  L_,    "1.234e+1",                 12,      true    },
                {  L_,    "1.987E+1",                 19,      true    },

                {  L_,    "12.34e-1",                  1,      true    },
                {  L_,    "29.87E-1",                  2,      true    },

                {  L_,    "-123.34e-1",              -12,      true    },
                {  L_,    "-298.7E-1",               -29,      true    },

                {  L_,    "1e1",                      10,      true    },
                {  L_,    "1E1",                      10,      true    },
                {  L_,    "1e+1",                     10,      true    },
                {  L_,    "1E+1",                     10,      true    },
                {  L_,    "1e-1",                      0,      true    },
                {  L_,    "1E-1",                      0,      true    },

// TBD:
//                 {  L_,    "4294967296", ERROR_VALUE,      false    },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 8: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for unsigned int values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for unsigned int"
                               << "\n==================================="
                               << bsl::endl;

        {
            typedef unsigned int Type;

            const Type ERROR_VALUE = 99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input                       exp     isValid
                // ----   -----                       ---     -------
                {  L_,      "0",                       0,      true    },
                {  L_,      "1",                       1,      true    },
                {  L_,     "95",                      95,      true    },
                {  L_,    "127",                     127,      true    },
                {  L_,    "128",                     128,      true    },
                {  L_,    "200",                     200,      true    },
                {  L_,    "255",                     255,      true    },
                {  L_,  "32767",                   32767,      true    },
                {  L_,  "32768",                   32768,      true    },
                {  L_,  "65534",                   65534,      true    },
                {  L_,  "65535",                   65535,      true    },

                {  L_,   "8388607",              8388607,      true    },
                {  L_,   "8388608",              8388608,      true    },

                {  L_,   "2147483646",        2147483646,      true    },
                {  L_,   "2147483647",        2147483647,      true    },

                {  L_,   "4294967294",        4294967294,      true    },
                {  L_,   "4294967295",        4294967295,      true    },

                {  L_, "4294967294.01",       4294967294,      true    },
                {  L_, "4294967294.99",       4294967294,      true    },

                {  L_, "4294967295.01",       4294967295,      true    },

// TBD:
//                 {  L_, "4294967295.99",       4294967295,      true    },

                {  L_,    "1.1",                       1,      true    },
                {  L_,    "1.5",                       1,      true    },
                {  L_,    "1.9",                       1,      true    },

                {  L_,   "100.123",                  100,      true    },
                {  L_,   "99.5",                      99,      true    },
                {  L_,    "0.86",                      0,      true    },

                {  L_,    "1e0",                       1,      true    },
                {  L_,    "1E0",                       1,      true    },
                {  L_,    "1e+0",                      1,      true    },
                {  L_,    "1E+0",                      1,      true    },
                {  L_,    "1e-0",                      1,      true    },
                {  L_,    "1E-0",                      1,      true    },

                {  L_,    "1.234e+1",                 12,      true    },
                {  L_,    "1.987E+1",                 19,      true    },

                {  L_,    "12.34e-1",                  1,      true    },
                {  L_,    "29.87E-1",                  2,      true    },

// TBD:
//                 {  L_,    "-123.34e-1",              -12,      true    },
//                 {  L_,    "-298.7E-1",               -29,      true    },

                {  L_,    "1e1",                      10,      true    },
                {  L_,    "1E1",                      10,      true    },
                {  L_,    "1e+1",                     10,      true    },
                {  L_,    "1E+1",                     10,      true    },
                {  L_,    "1e-1",                      0,      true    },
                {  L_,    "1E-1",                      0,      true    },

                {  L_,    "4294967296",      ERROR_VALUE,      false   },
                {  L_,    "4294967296.01",   ERROR_VALUE,      false   },
                {  L_,    "4294967296.99",   ERROR_VALUE,      false   },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 7: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for int values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for int"
                               << "\n=========================="
                               << bsl::endl;
        {
            typedef int Type;

            const Type ERROR_VALUE = 99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line      input                exp     isValid
                // ----      -----                ---     -------
                {  L_,         "0",                0,      true    },
                {  L_,         "1",                1,      true    },
                {  L_,        "95",               95,      true    },
                {  L_,       "127",              127,      true    },
                {  L_,       "128",              128,      true    },
                {  L_,       "-127",            -127,      true    },
                {  L_,       "-128",            -128,      true    },
                {  L_,       "-129",            -129,      true    },
                {  L_,       "200",              200,      true    },
                {  L_,       "255",              255,      true    },
                {  L_,     "32767",            32767,      true    },
                {  L_,     "32768",            32768,      true    },
                {  L_,    "-32767",           -32767,      true    },
                {  L_,    "-32768",           -32768,      true    },
                {  L_,    "-32769",           -32769,      true    },
                {  L_,     "65534",            65534,      true    },
                {  L_,     "65535",            65535,      true    },
                {  L_,    "-65534",           -65534,      true    },
                {  L_,    "-65535",           -65535,      true    },
                {  L_,    "-65536",           -65536,      true    },
                {  L_,   "8388607",          8388607,      true    },
                {  L_,   "8388608",          8388608,      true    },
                {  L_,  "-8388608",         -8388608,      true    },
                {  L_,  "-8388609",         -8388609,      true    },

                {  L_,   "2147483646",    2147483646,      true    },
                {  L_,   "2147483647",    2147483647,      true    },
                {  L_,  "-2147483647",   -2147483647,      true    },
                {  L_,  "-2147483648",   -2147483648,      true    },

                {  L_, "2147483647.01",   2147483647,      true    },
                {  L_, "2147483647.99",   2147483647,      true    },
                {  L_, "-2147483648.01", -2147483648,      true    },

// TBD:
//                 {  L_, "-2147483648.99", -2147483648,      true    },

                {  L_,    "1.1",                   1,      true    },
                {  L_,    "1.5",                   1,      true    },
                {  L_,    "1.9",                   1,      true    },

                {  L_,   "100.123",             100,      true    },
                {  L_,   "99.5",                 99,      true    },
                {  L_,    "0.86",                 0,      true    },

                {  L_,    "1e0",                  1,      true    },
                {  L_,    "1E0",                  1,      true    },
                {  L_,    "1e+0",                 1,      true    },
                {  L_,    "1E+0",                 1,      true    },
                {  L_,    "1e-0",                 1,      true    },
                {  L_,    "1E-0",                 1,      true    },

                {  L_,    "1.234e+1",            12,      true    },
                {  L_,    "1.987E+1",            19,      true    },

                {  L_,    "12.34e-1",             1,      true    },
                {  L_,    "29.87E-1",             2,      true    },

                {  L_,    "-123.34e-1",         -12,      true    },
                {  L_,    "-298.7E-1",          -29,      true    },

                {  L_,    "1e1",                 10,      true    },
                {  L_,    "1E1",                 10,      true    },
                {  L_,    "1e+1",                10,      true    },
                {  L_,    "1E+1",                10,      true    },
                {  L_,    "1e-1",                 0,      true    },
                {  L_,    "1E-1",                 0,      true    },

                {  L_, "2147483648",     ERROR_VALUE,     false   },
                {  L_, "2147483648.01",  ERROR_VALUE,     false   },
                {  L_, "2147483648.99",  ERROR_VALUE,     false   },

                {  L_, "2147483649",     ERROR_VALUE,     false   },

                {  L_, "-2147483649",    ERROR_VALUE,     false   },
                {  L_, "-2147483649.01", ERROR_VALUE,     false   },
                {  L_, "-2147483649.99", ERROR_VALUE,     false   },

            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 6: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for unsigned short values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for unsigned short"
                               << "\n====================================="
                               << bsl::endl;

        {
            typedef unsigned short Type;

            const Type ERROR_VALUE = 99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input               exp     isValid
                // ----   -----               ---     -------
                {  L_,      "0",               0,      true    },
                {  L_,      "1",               1,      true    },
                {  L_,     "95",              95,      true    },
                {  L_,    "127",             127,      true    },
                {  L_,    "128",             128,      true    },
                {  L_,    "200",             200,      true    },
                {  L_,    "255",             255,      true    },
                {  L_,  "32767",           32767,      true    },
                {  L_,  "32768",           32768,      true    },
                {  L_,  "65534",           65534,      true    },
                {  L_,  "65535",           65535,      true    },

                {  L_,  "65535.01",        65535,      true    },
                {  L_,  "65535.99",        65535,      true    },

                {  L_,    "1.1",               1,      true    },
                {  L_,    "1.5",               1,      true    },
                {  L_,    "1.9",               1,      true    },

                {  L_,   "100.123",          100,      true    },
                {  L_,   "99.5",              99,      true    },
                {  L_,    "0.86",              0,      true    },

                {  L_,    "1e0",               1,      true    },
                {  L_,    "1E0",               1,      true    },
                {  L_,    "1e+0",              1,      true    },
                {  L_,    "1E+0",              1,      true    },
                {  L_,    "1e-0",              1,      true    },
                {  L_,    "1E-0",              1,      true    },

                {  L_,    "1.234e+1",         12,      true    },
                {  L_,    "1.987E+1",         19,      true    },

                {  L_,    "12.34e-1",          1,      true    },
                {  L_,    "29.87E-1",          2,      true    },

                {  L_,    "1e1",              10,      true    },
                {  L_,    "1E1",              10,      true    },
                {  L_,    "1e+1",             10,      true    },
                {  L_,    "1E+1",             10,      true    },
                {  L_,    "1e-1",              0,      true    },
                {  L_,    "1E-1",              0,      true    },

                {  L_,   "65536",    ERROR_VALUE,      false   },
                {  L_,   "65536.01", ERROR_VALUE,      false   },
                {  L_,   "65536.99", ERROR_VALUE,      false   },

                {  L_,   "65537",    ERROR_VALUE,      false   },
                {  L_,   "65537.01", ERROR_VALUE,      false   },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 5: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for short values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for short"
                               << "\n============================"
                               << bsl::endl;

        {
            typedef short Type;

            const Type ERROR_VALUE = 99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input             exp     isValid
                // ----   -----             ---     -------
                {  L_,      "0",             0,      true    },
                {  L_,      "1",             1,      true    },
                {  L_,     "95",            95,      true    },
                {  L_,    "127",           127,      true    },
                {  L_,    "128",           128,      true    },
                {  L_,   "-127",          -127,      true    },
                {  L_,   "-128",          -128,      true    },
                {  L_,   "-129",          -129,      true    },
                {  L_,    "200",           200,      true    },
                {  L_,    "255",           255,      true    },
                {  L_,  "32766",         32766,      true    },
                {  L_,  "32767",         32767,      true    },
                {  L_, "-32767",        -32767,      true    },
                {  L_, "-32768",        -32768,      true    },

                {  L_,    "1.1",             1,      true    },
                {  L_,    "1.5",             1,      true    },
                {  L_,    "1.9",             1,      true    },

                {  L_,   "100.123",        100,      true    },
                {  L_,   "99.5",            99,      true    },
                {  L_,    "0.86",            0,      true    },

                {  L_,  "32767.01",      32767,      true    },
                {  L_,  "32767.99",      32767,      true    },
                {  L_, "-32768.01",     -32768,      true    },
                {  L_, "-32768.99",     -32768,      true    },

                {  L_,    "1e0",             1,      true    },
                {  L_,    "1E0",             1,      true    },
                {  L_,    "1e+0",            1,      true    },
                {  L_,    "1E+0",            1,      true    },
                {  L_,    "1e-0",            1,      true    },
                {  L_,    "1E-0",            1,      true    },

                {  L_,    "1.234e+1",       12,      true    },
                {  L_,    "1.987E+1",       19,      true    },

                {  L_,    "12.34e-1",        1,      true    },
                {  L_,    "29.87E-1",        2,      true    },

                {  L_,    "-123.34e-1",    -12,      true    },
                {  L_,    "-298.7E-1",     -29,      true    },

                {  L_,    "1e1",            10,      true    },
                {  L_,    "1E1",            10,      true    },
                {  L_,    "1e+1",           10,      true    },
                {  L_,    "1E+1",           10,      true    },
                {  L_,    "1e-1",            0,      true    },
                {  L_,    "1E-1",            0,      true    },

                {  L_,   "32768",     ERROR_VALUE,   false   },
                {  L_,   "32768.01",  ERROR_VALUE,   false   },
                {  L_,   "65535",     ERROR_VALUE,   false   },
                {  L_,   "65535.01",  ERROR_VALUE,   false   },

                {  L_,  "-32769",     ERROR_VALUE,   false   },
                {  L_,  "-32769.01",  ERROR_VALUE,   false   },
                {  L_,  "-32769.99",  ERROR_VALUE,   false   },
                {  L_,  "-65535",     ERROR_VALUE,   false   },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 4: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for unsigned char values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for unsigned char"
                               << "\n===================================="
                               << bsl::endl;
        {
            typedef unsigned char Type;

            const Type ERROR_VALUE = 99;

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                Type        d_exp;     // exp unsigned value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line   input             exp     isValid
                // ----   -----             ---     -------
                {  L_,      "0",             0,      true    },
                {  L_,      "1",             1,      true    },
                {  L_,     "95",            95,      true    },
                {  L_,    "127",           127,      true    },
                {  L_,    "128",           128,      true    },
                {  L_,    "200",           200,      true    },
                {  L_,    "255",           255,      true    },

                {  L_,    "1.1",             1,      true    },
                {  L_,    "1.5",             1,      true    },
                {  L_,    "1.9",             1,      true    },

                {  L_,    "100.123",       100,      true    },
                {  L_,    "99.5",           99,      true    },
                {  L_,    "0.86",            0,      true    },

                {  L_,  "255.01",          255,      true    },
                {  L_,  "255.99",          255,      true    },

                {  L_,    "1e0",             1,      true    },
                {  L_,    "1E0",             1,      true    },
                {  L_,    "1e+0",            1,      true    },
                {  L_,    "1E+0",            1,      true    },
                {  L_,    "1e-0",            1,      true    },
                {  L_,    "1E-0",            1,      true    },

                {  L_,    "1e1",            10,      true    },
                {  L_,    "1E1",            10,      true    },
                {  L_,    "1e+1",           10,      true    },
                {  L_,    "1E+1",           10,      true    },

                {  L_,    "1.234e+1",       12,      true    },
                {  L_,    "1.987E+1",       19,      true    },

                {  L_,    "12.34e-1",        1,      true    },
                {  L_,    "29.87E-1",        2,      true    },

                {  L_,    "1e-1",            0,      true    },
                {  L_,    "1E-1",            0,      true    },

                {  L_,    "256",      ERROR_VALUE,      false    },
                {  L_,    "256.01",   ERROR_VALUE,      false    },
                {  L_,    "32766",    ERROR_VALUE,      false    },
                {  L_,    "32766.01", ERROR_VALUE,      false    },

            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int    LINE     = DATA[i].d_line;
                const string INPUT    = DATA[i].d_input_p;
                const Type   EXP      = DATA[i].d_exp;
                const bool   IS_VALID = DATA[i].d_isValid;
                      Type   value    = ERROR_VALUE;

                bdesb_FixedMemInStreamBuf isb(INPUT.data(), INPUT.length());
                const int rc = Util::getValue(&isb, &value);
                if (IS_VALID) {
                    LOOP2_ASSERT(LINE, rc,           0 == rc);
                    LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                }
                else {
                    LOOP2_ASSERT(LINE, rc, rc);
                }
                LOOP3_ASSERT(LINE, EXP, value, EXP == value);
            }
        }
      } break;
      case 3: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for signed char values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for signed char"
                               << "\n=================================="
                               << bsl::endl;

        {
            const char ERROR_CHAR = 'X';

            static const struct {
                int         d_line;    // line number
                const char *d_input_p; // input on the stream
                char        d_exp;     // exp char value
                bool        d_isValid; // isValid flag
            } DATA[] = {
                // line    input        exp            isValid  
                // ----    -----        ---            -------
                {  L_,     "\"0\"",     '0',            true  },
                {  L_,     "\"1\"",     '1',            true  },
                {  L_,     "\"A\"",     'A',            true  },
                {  L_,     "\"z\"",     'z',            true  },

                {  L_,     "\"\\\"\"",  '\"',           true  },
                {  L_,     "\"\\\\\"",  '\\',           true  },
                {  L_,     "\"\\b\"",   '\b',           true  },
                {  L_,     "\"\\f\"",   '\f',           true  },
                {  L_,     "\"\\n\"",   '\n',           true  },
                {  L_,     "\"\\r\"",   '\r',           true  },
                {  L_,     "\"\\t\"",   '\t',           true  },

                {  L_,     "\"AB\"",    ERROR_CHAR,     false },

                // TBD: 
//                 {  L_,     "\"\\u000a \"",   'a',     true  },
            };
            const int NUM_DATA = sizeof(DATA) / sizeof(*DATA);

            for (int i = 0; i < NUM_DATA; ++i) {
                const int            LINE     = DATA[i].d_line;
                const string         INPUT    = DATA[i].d_input_p;
                const char           C        = DATA[i].d_exp;
                const signed char    SC       = (signed char) DATA[i].d_exp;
                const bool           IS_VALID = DATA[i].d_isValid;
                      char           c        = ERROR_CHAR;
                      signed char    sc       = ERROR_CHAR;

                if (veryVerbose) { P(INPUT) P(C) } 

                // char values
                {
                    bdesb_FixedMemInStreamBuf isb(INPUT.data(),
                                                  INPUT.length());
                    const int rc = Util::getValue(&isb, &c);
                    if (IS_VALID) {
                        LOOP2_ASSERT(LINE, rc,           0 == rc);
                        LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                    }
                    else {
                        LOOP2_ASSERT(LINE, rc, rc);
                    }
                    LOOP3_ASSERT(LINE, C, c, C == c);
                }

                // signed char values
                {
                    bdesb_FixedMemInStreamBuf isb(INPUT.data(),
                                                  INPUT.length());
                    const int rc = Util::getValue(&isb, &sc);
                    if (IS_VALID) {
                        LOOP2_ASSERT(LINE, rc,           0 == rc);
                        LOOP2_ASSERT(LINE, isb.length(), 0 == isb.length());
                    }
                    else {
                        LOOP2_ASSERT(LINE, rc, rc);
                    }
                    LOOP3_ASSERT(LINE, SC, sc, SC == sc);
                }
            }
        }
      } break;
      case 2: {
        // --------------------------------------------------------------------
        // TESTING 'getValue' for bool values
        //
        // Concerns:
        //
        // Plan:
        //
        // Testing:
        // --------------------------------------------------------------------

        if (verbose) bsl::cout << "\nTESTING 'getValue' for bool"
                               << "\n===========================" << bsl::endl;

        {
            typedef bool Type;

            const Type XA1 = true;  Type XA2; const string EA = "true";
            const Type XB1 = false; Type XB2; const string EB = "false";
                  Type XC1 = true;  Type XC2 = false;
            const string EC = "error";

            {
                bdesb_FixedMemInStreamBuf isb(EA.data(), EA.length());
                ASSERT(SUCCESS == Util::getValue(&isb, &XA2));
                ASSERT(0       == isb.length());
                ASSERT(XA1     == XA2);
            }

            {
                bdesb_FixedMemInStreamBuf isb(EB.data(), EB.length());
                ASSERT(SUCCESS == Util::getValue(&isb, &XB2));
                ASSERT(0       == isb.length());
                ASSERT(XB1     == XB2);
            }

            {
                bdesb_FixedMemInStreamBuf isb(EC.data(), EC.length());
                ASSERT(FAILURE == Util::getValue(&isb, &XC1));
                ASSERT(true == XC1);
            }

            {
                bdesb_FixedMemInStreamBuf isb(EC.data(), EC.length());
                ASSERT(FAILURE == Util::getValue(&isb, &XC2));
                ASSERT(false == XC2);
            }
        }
      } break;
      case 1: {
        // --------------------------------------------------------------------
        // BREATHING TEST
        //   This case exercises (but does not fully test) basic functionality.
        //
        // Concerns:
        //: 1 The class is sufficiently functional to enable comprehensive
        //:   testing in subsequent test cases.
        //
        // Plan:
        //
        // Testing:
        //   BREATHING TEST
        // --------------------------------------------------------------------

        if (verbose) cout << endl
                          << "BREATHING TEST" << endl
                          << "==============" << endl;

        const struct {
            int         d_line;
            const char* d_string;
            bool        d_validFlag;
            double      d_result;
        } DATA[] = {
            //LINE        STRING    FLAG      RESULTS
            //----        ------    ----      -------

            { L_,   "-1.625e308",   true,  -1.625e308 },
            { L_,    "-3.125e38",   true,   -3.125e38 },

            { L_,         "-1.0",   true,        -1.0 },

            { L_,         "-0.0",   true,        -0.0 },
            { L_,            "0",   true,         0.0 },
            { L_,          "0.0",   true,         0.0 },
            { L_,          "1.0",   true,         1.0 },
            { L_,     "3.125e38",   true,    3.125e38 },
            { L_,    "1.625e308",   true,   1.625e308 },

            { L_,          "0e0",   true,         0.0 },

            { L_,          "1e0",   true,         1.0 },

            { L_,         "-1.5",   true,        -1.5 },
            { L_,     "-1.25e-3",   true,    -1.25e-3 },
            { L_,     "9.25e+10",   true,     9.25e10 },
            { L_,           ".1",  false,         0.0 },
            { L_,           "1.",  false,         0.0 },
            { L_,           "+1",  false,         0.0 },
            { L_,          "--1",  false,         0.0 },
            { L_,        "1e+-1",  false,         0.0 }
        };
        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        for (int ti = 0; ti < NUM_DATA; ++ ti) {
            const int         LINE   = DATA[ti].d_line;
            const char *const STRING = DATA[ti].d_string;
            const bool        FLAG   = DATA[ti].d_validFlag;
            const double      EXP    = DATA[ti].d_result;

            bsl::istringstream iss(STRING);

            double result;
            ASSERTV(LINE, FLAG == (0 == Util::getNumber(iss.rdbuf(),
                                                        &result)));

            if (FLAG) {
                ASSERTV(LINE, result, EXP, result == EXP);
            }
        }
      } break;
      default: {
        cerr << "WARNING: CASE `" << test << "' NOT FOUND." << endl;
        testStatus = -1;
      }
    }

    if (testStatus > 0) {
        cerr << "Error, non-zero test status = " << testStatus << "." << endl;
    }

    return testStatus;
}
