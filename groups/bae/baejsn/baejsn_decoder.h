// baejsn_decoder.h                                                   -*-C++-*-
#ifndef INCLUDED_BAEJSN_DECODER
#define INCLUDED_BAEJSN_DECODER

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide a JSON decoder for 'bdeat' compatible types.
//
//@CLASSES:
//  baejsn_Decoder: JSON decoder for 'bdeat'-compliant types
//
//@SEE_ALSO: baejsn_encoder, baejsn_parserutil, baejsn_parser
//
//@AUTHOR: Raymond Chiu (schiu49), Rohan Bhindwale (rbhindwa)
//
//@DESCRIPTION: This component provides a class, 'baejsn_Decoder', for decoding
// value-semantic objects in the JSON format.  In particular, the 'class'
// contains a parameterized 'decode' function that decodes an object from a
// specified stream.  There are two overloaded versions of this function:
//..
//: o one that reads from a 'bsl::streambuf'
//: o one that reads from a 'bsl::istream'
//..
// This component can be used with types that support the 'bdeat' framework
// (see the 'bdeat' package for details), which is a compile-time interface for
// manipulating struct-like and union-like objects.  In particular, types
// generated by the 'bas_codegen.pl' tool, and dynamic types such as
// 'bcem_Aggregate' can be decoded using this 'class'.  The 'decode' function
// can be invoked on any object that satisfies the requirements of a sequence,
// choice, or array object as defined in the 'bdeat_sequencefunctions',
// 'bdeat_choicefunctions', and 'bdeat_arrayfunctions' components.
//
// Although the JSON format is easy to read and write and is very useful for
// debugging, it is relatively expensive to encode and decode and relatively
// bulky to transmit.  It is more efficient to use a binary encoding (such as
// BER) if the encoding format is under your control (see 'bdem_berdecoder').
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Decoding into a 'bas_codegen.pl'-generated from data in JSON
///-----------------------------------------------------------------------
// Consider that we want to exchange an employee's information between two
// processes.  To allow this information exchange we will define the XML schema
// representation for that class, use 'bas_codegen.pl' to create the 'Employee'
// 'class' for storing that information, and decode into that object using the
// baejsn decoder.
//
// First, we will define the XML schema inside a file called 'employee.xsd':
//..
//  <?xml version='1.0' encoding='UTF-8'?>
//  <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
//             xmlns:test='http://bloomberg.com/schemas/test'
//             targetNamespace='http://bloomberg.com/schemas/test'
//             elementFormDefault='unqualified'>
//
//      <xs:complexType name='Address'>
//          <xs:sequence>
//              <xs:element name='street' type='xs:string'/>
//              <xs:element name='city'   type='xs:string'/>
//              <xs:element name='state'  type='xs:string'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:complexType name='Employee'>
//          <xs:sequence>
//              <xs:element name='name'        type='xs:string'/>
//              <xs:element name='homeAddress' type='test:Address'/>
//              <xs:element name='age'         type='xs:int'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:element name='Employee' type='test:Employee'/>
//
//  </xs:schema>
//..
// Then, we will use the 'bas_codegen.pl' tool, to generate the C++ classes for
// this schema.  The following command will generate the header and
// implementation files for the all the classes in the 'test_messages'
// components in the current directory:
//..
//  $ bas_codegen.pl -m msg -p test xsdfile.xsd
//..
// Next, we will create a 'test::Employee' object:
//..
//  test::Employee employee;
//..
// Then, we will create a 'baejsn_Decoder' object:
//..
//  baejsn_Decoder decoder;
//..
// Next, we will specify the input data provided to the decoder:
//..
//  const char INPUT[] = "{\"name\":\"Bob\",\"homeAddress\":{\"street\":"
//                       "\"Lexington Ave\",\"city\":\"New York City\","
//                       "\"state\":\"New York\"},\"age\":21}";
//
//  bsl::istringstream is(INPUT);
//..
// Now, we will decode this object using the 'decode' function of the baejsn
// decoder by providing it a 'baejsn_DecoderOptions' object.  The decoder
// options allow us to specify that unknown elements should *not* be skipped.
// Setting this option to 'false' will result in the decoder returning an error
// on encountering an unknown element:
//..
//  baejsn_DecoderOptions options;
//  options.setSkipUnknownElements(false);
//
//  const int rc = decoder.decode(is, &employee, options);
//  assert(!rc);
//  assert(is);
//..
// Finally, we will verify that the decoded object is as expected:
//..
//  assert("Bob"           == employee.name());
//  assert("Lexington Ave" == employee.homeAddress().street());
//  assert("New York City" == employee.homeAddress().city());
//  assert("New York"      == employee.homeAddress().state());
//  assert(21              == employee.age());
//..
//
///Example 2: Decoding into a 'bcem_Aggregate' Object from JSON data
///-----------------------------------------------------------------
// Now consider that we want to exchange an employee's information between two
// processes using a 'bcem_Aggregate'.  To allow this information exchange we
// will define the 'bdem_Schema' to represent the meta-data, construct the
// 'bcem_Aggregate' object with that schema, and decode that object using the
// baejsn decoder.
//
// First, we create a 'bdem_Schema' object:
//..
//  bcema_SharedPtr<bdem_Schema> schema(new bdem_Schema);
//
//  bdem_RecordDef *addressRecord = schema->createRecord("Address");
//  addressRecord->appendField(bdem_ElemType::BDEM_STRING, "street");
//  addressRecord->appendField(bdem_ElemType::BDEM_STRING, "city");
//  addressRecord->appendField(bdem_ElemType::BDEM_STRING, "state");
//
//  bdem_RecordDef *employeeRecord = schema->createRecord("Employee");
//  employeeRecord->appendField(bdem_ElemType::BDEM_STRING, "name");
//  employeeRecord->appendField(bdem_ElemType::BDEM_LIST,
//                              addressRecord,
//                              "homeAddress");
//  employeeRecord->appendField(bdem_ElemType::BDEM_INT, "age");
//..
// Then, we create a 'bcem_Aggregate' object using the schema::
//..
//  bcem_Aggregate employee(schema, "Employee");
//..
// Next, we will create a 'baejsn_Decoder' object:
//..
//  baejsn_Decoder decoder;
//..
// Then, we will specify the input data provided to the decoder.  Notice that
// the element named 'id' in the underlying JSON is an unknown element as it
// is not specified in the schema but the decoder will skip that element:
//..
//  const char INPUT[] = "    {\n"
//                       "        \"name\" : \"Bob\",\n"
//                       "        \"homeAddress\" : {\n"
//                       "            \"street\" : \"Lexington Ave\",\n"
//                       "            \"city\" : \"New York City\",\n"
//                       "            \"state\" : \"New York\"\n"
//                       "        },\n"
//                       "        \"age\" : 21,\n"
//                       "        \"id\" : 12345\n"
//                       "    }";
//
//  bsl::istringstream is(INPUT);
//..
// Now, we will decode this object using the 'decode' function of the baejsn
// decoder by providing it a default 'baejsn_DecoderOptions' object.  Doing so
// specifies to the decoder that unknown elements should be skipped and should
// not result in a decoding error:
//..
//  baejsn_DecoderOptions options;
//  const int rc = decoder.decode(is, &employee, options);
//  assert(!rc);
//  assert(is);
//..
// Finally, we will verify that the decoded object is as expected:
//..
//  assert("Bob"           == employee["name"].asString());
//  assert("Lexington Ave" == employee["homeAddress"]["street"].asString());
//  assert("New York City" == employee["homeAddress"]["city"].asString());
//  assert("New York"      == employee["homeAddress"]["state"].asString());
//  assert(21              == employee["age"].asInt());
//..

#ifndef INCLUDED_BAESCM_VERSION
#include <baescm_version.h>
#endif

#ifndef INCLUDED_BAEJSN_DECODEROPTIONS
#include <baejsn_decoderoptions.h>
#endif

#ifndef INCLUDED_BAEJSN_PARSERUTIL
#include <baejsn_parserutil.h>
#endif

#ifndef INCLUDED_BAEJSN_PARSER
#include <baejsn_parser.h>
#endif

#ifndef INCLUDED_BDEAT_ATTRIBUTEINFO
#include <bdeat_attributeinfo.h>
#endif

#ifndef INCLUDED_BDEAT_CHOICEFUNCTIONS
#include <bdeat_choicefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CUSTOMIZEDTYPEFUNCTIONS
#include <bdeat_customizedtypefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_ENUMFUNCTIONS
#include <bdeat_enumfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_FORMATTINGMODE
#include <bdeat_formattingmode.h>
#endif

#ifndef INCLUDED_BDEAT_SELECTIONINFO
#include <bdeat_selectioninfo.h>
#endif

#ifndef INCLUDED_BDEAT_SEQUENCEFUNCTIONS
#include <bdeat_sequencefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_TYPECATEGORY
#include <bdeat_typecategory.h>
#endif

#ifndef INCLUDED_BDEAT_VALUETYPEFUNCTIONS
#include <bdeat_valuetypefunctions.h>
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include <bslmf_assert.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

#ifndef INCLUDED_BSLS_TYPES
#include <bsls_types.h>
#endif

#ifndef INCLUDED_BSL_SSTREAM
#include <bsl_sstream.h>
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include <bsl_streambuf.h>
#endif

#ifndef INCLUDED_BSL_STRING
#include <bsl_string.h>
#endif

namespace BloombergLP {

                        // ====================
                        // class baejsn_Decoder
                        // ====================

class baejsn_Decoder {
    // This class provides a mechanism for decoding JSON data into
    // value-semantic objects.  The 'decode' methods are function templates
    // that will decode any object that meets the requirements of a sequence,
    // choice, or array object as defined in the 'bdeat_sequencefunctions',
    // 'bdeat_choicefunctions', and 'bdeat_choicefunctions' components
    // respectively.  These generic frameworks provide a common compile-time
    // interface for manipulating struct-like and union-like objects.  In
    // particular, 'bcem_aggregate' and the types generated by 'bas_codegen.pl'
    // provide the necessary interface and can be decoded using this component.

    // DATA
    bsl::ostringstream  d_logStream;            // stream to record errors
    baejsn_Parser       d_parser;               // JSON parser
    bsl::string         d_elementName;          // current element name
    int                 d_currentDepth;         // current decoding depth
    int                 d_maxDepth;             // max decoding depth
    bool                d_skipUnknownElements;  // skip unknown elements flag

    // FRIENDS
    friend struct baejsn_Decoder_DecodeImpProxy;
    friend struct baejsn_Decoder_ElementVisitor;

    // PRIVATE MANIPULATORS
    int decodeBinaryArray(bsl::vector<char> *value);
        // Decode into the specified 'value' vector the JSON data currently
        // referred to by the parser owned by this object.  Return 0 on success
        // and a non-zero value otherwise.

    template <typename TYPE>
    int decodeImp(TYPE *value, int mode, bdeat_TypeCategory::DynamicType);
    template <typename TYPE>
    int decodeImp(TYPE *value, int mode, bdeat_TypeCategory::Sequence);
    template <typename TYPE>
    int decodeImp(TYPE *value, int mode, bdeat_TypeCategory::Choice);
    template <typename TYPE>
    int decodeImp(TYPE *value, int mode, bdeat_TypeCategory::Enumeration);
    template <typename TYPE>
    int decodeImp(TYPE *value, int mode, bdeat_TypeCategory::CustomizedType);
    template <typename TYPE>
    int decodeImp(TYPE *value, int mode, bdeat_TypeCategory::Simple);
    template <typename TYPE>
    int decodeImp(TYPE *value, int mode, bdeat_TypeCategory::Array);
    template <typename TYPE>
    int decodeImp(TYPE *value, int mode, bdeat_TypeCategory::NullableValue);
    int decodeImp(bsl::vector<char> *value,
                  int                mode,
                  bdeat_TypeCategory::Array);
    template <typename TYPE, typename ANY_CATEGORY>
    int decodeImp(TYPE *object, ANY_CATEGORY category);
        // Decode into the specified 'value' of the corresponding 'bdeat' type
        // and using the specified formatting 'mode' the JSON data currently
        // referred to by the parser owned by this object.  Return 0 on success
        // and a non-zero value otherwise.

    int skipUnknownElement(const bslstl::StringRef& elementName);
        // Skip the unknown element specified by 'elementName' by discarding
        // all the data associated with it and advancing the parser to the next
        // element.  Return 0 on success and a non-zero value otherwise.

  public:
    // CREATORS
    explicit baejsn_Decoder(bslma_Allocator *basicAllocator = 0);
        // Construct a decoder object using the optionally specified
        // 'basicAllocator'.  If 'basicAllocator' is 0, the default allocator
        // is used.

    // MANIPULATORS
    template <typename TYPE>
    int decode(bsl::streambuf               *streamBuf,
               TYPE                         *value,
               const baejsn_DecoderOptions&  options);
        // Decode an object of (template parameter) 'TYPE' from the specified
        // 'streamBuf' and using the specified 'options'.  Load the result into
        // the specified modifiable 'value'.  Return 0 on success, and a
        // non-zero value otherwise.

    template <typename TYPE>
    int decode(bsl::istream&                 stream,
               TYPE                         *value,
               const baejsn_DecoderOptions&  options);
        // Decode an object of (template parameter) 'TYPE' from the specified
        // 'stream' and using the specified 'options'.  Load the result into
        // the specified modifiable 'value'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that 'stream' will be invalidated if
        // the decoding fails.

    template <typename TYPE>
    int decode(bsl::streambuf *streamBuf, TYPE *value);
        // Decode an object of (template parameter) 'TYPE' from the specified
        // 'streamBuf' and load the result into the specified modifiable
        // 'value'.  Return 0 on success, and a non-zero value otherwise.
        //
        // DEPRECATED: Use the 'decode' function passed a reference to a
        // non-modifiable 'baejsn_DecoderOptions' object instead.

    template <typename TYPE>
    int decode(bsl::istream& stream, TYPE *value);
        // Decode an object of (template parameter) 'TYPE' from the specified
        // 'stream' and load the result into the specified modifiable
        // 'value'.  Return 0 on success, and a non-zero value otherwise.
        // Note that 'stream' will be invalidated if the decoding fails.
        //
        // DEPRECATED: Use the 'decode' function passed a reference to a
        // non-modifiable 'baejsn_DecoderOptions' object instead.

    // ACCESSORS
    bsl::string loggedMessages() const;
        // Return a string containing any error, warning, or trace messages
        // that were logged during the last call to the 'decode' method.  The
        // log is reset each time 'decode' is called.
};

                 // ====================================
                 // struct baejsn_Decoder_ElementVisitor
                 // ====================================

struct baejsn_Decoder_ElementVisitor {
    // This 'class' implements a visitor for decoding elements within a
    // sequence, choice, or array type.  This is a component-private class and
    // should not be used outside of this component.  Note that this 'class'
    // provides the following operators:
    //..
    //  template <typename TYPE> int operator()(TYPE *value);
    //  template <typename TYPE, typename INFO>
    //  int operator()(TYPE *value, const INFO& info);
    //..

    // DATA
    baejsn_Decoder *d_decoder_p;  // decoder (held, not owned)
    int             d_mode;       // formatting mode

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // MANIPULATORS
    template <typename TYPE>
    int operator()(TYPE *value);
        // Decode into the specified 'value' the data in the JSON format.
        // Return 0 on success and a non-zero value otherwise.

    template <typename TYPE, typename INFO>
    int operator()(TYPE *value, const INFO& info);
        // Decode into the specified 'value' using the specified 'info' the
        // data in the JSON format.  Return 0 on success and a non-zero value
        // otherwise.
};

                 // ====================================
                 // struct baejsn_Decoder_DecodeImpProxy
                 // ====================================

struct baejsn_Decoder_DecodeImpProxy {
    // This class provides a functor that dispatches the appropriate
    // 'decodeImp' method for a 'bdeat' Dynamic type.  This is a
    // component-private class and should not be used outside of this
    // component.  Note that this 'class'
    // provides the following operator:
    //..
    //  template <typename TYPE, typename ANY_CATEGORY>
    //  int operator()(TYPE *value, ANY_CATEGORY category);
    //..

    // DATA
    baejsn_Decoder *d_decoder_p;  // decoder (held, not owned)
    int             d_mode;       // formatting mode

    // CREATORS
    // Creators have been omitted to allow simple static initialization of
    // this struct.

    // MANIPULATORS
    template <typename TYPE>
    int operator()(TYPE *, bslmf_Nil);
    template <typename TYPE, typename ANY_CATEGORY>
    int operator()(TYPE *object, ANY_CATEGORY category);
        // Dencode into the specified 'value' of the specified 'bdeat'
        // 'category' from the data in the JSON format.  Return 0 on success
        // and a non-zero value otherwise.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // --------------------
                        // class baejsn_Decoder
                        // --------------------

// PRIVATE MANIPULATORS
template <typename TYPE>
inline
int baejsn_Decoder::decodeImp(TYPE *value,
                              int   mode,
                              bdeat_TypeCategory::DynamicType)
{
    baejsn_Decoder_DecodeImpProxy proxy = { this, mode };
    return bdeat_TypeCategoryUtil::manipulateByCategory(value, proxy);
}

template <typename TYPE>
int baejsn_Decoder::decodeImp(TYPE *value,
                              int   mode,
                              bdeat_TypeCategory::Sequence)
{
    if (bdeat_FormattingMode::BDEAT_UNTAGGED & mode) {
        if (bdeat_SequenceFunctions::hasAttribute(
                                   *value,
                                   d_elementName.data(),
                                   static_cast<int>(d_elementName.length()))) {
            baejsn_Decoder_ElementVisitor visitor = { this, mode };

            if (0 != bdeat_SequenceFunctions::manipulateAttribute(
                                   value,
                                   visitor,
                                   d_elementName.data(),
                                   static_cast<int>(d_elementName.length()))) {
                d_logStream << "Could not decode sequence, error decoding "
                            << "element or bad element name '"
                            << d_elementName << "' \n";
                return -1;                                            // RETURN
            }
        }
        else {
            if (d_skipUnknownElements) {
                const int rc = skipUnknownElement(d_elementName);
                if (rc) {
                    d_logStream << "Error reading unknown element '"
                                << d_elementName << "' or after it\n";
                    return -1;                                        // RETURN
                }
            }
            else {
                d_logStream << "Unknown element '" << d_elementName
                            << "' found\n";
                return -1;                                            // RETURN
            }
        }
    }
    else {
        if (++d_currentDepth > d_maxDepth) {
            d_logStream << "Maximum allowed decoding depth reached: "
                        << d_currentDepth << "\n";
            return -1;                                                // RETURN
        }

        if (baejsn_Parser::BAEJSN_START_OBJECT != d_parser.tokenType()) {
            d_logStream << "Could not decode sequence, missing starting '{'\n";
            return -1;                                                // RETURN
        }

        int rc = d_parser.advanceToNextToken();
        if (rc) {
            d_logStream << "Could not decode sequence, "
                        << "error reading token after '{'\n";
            return -1;                                                // RETURN
        }

        while (baejsn_Parser::BAEJSN_ELEMENT_NAME == d_parser.tokenType()) {
            bslstl::StringRef elementName;
            rc = d_parser.value(&elementName);
            if (rc) {
                d_logStream << "Error reading attribute name after '{'\n";
                return -1;                                            // RETURN
            }

            if (bdeat_SequenceFunctions::hasAttribute(
                                     *value,
                                     elementName.data(),
                                     static_cast<int>(elementName.length()))) {
                d_elementName = elementName;

                rc = d_parser.advanceToNextToken();
                if (rc) {
                    d_logStream << "Error reading value for attribute '"
                                << d_elementName << "' \n";
                    return -1;                                        // RETURN
                }

                baejsn_Decoder_ElementVisitor visitor = { this, mode };

                if (0 != bdeat_SequenceFunctions::manipulateAttribute(
                                   value,
                                   visitor,
                                   d_elementName.data(),
                                   static_cast<int>(d_elementName.length()))) {
                    d_logStream << "Could not decode sequence, error decoding "
                                << "element or bad element name '"
                                << d_elementName << "' \n";
                    return -1;                                        // RETURN
                }
            }
            else {
                if (d_skipUnknownElements) {
                    rc = skipUnknownElement(elementName);
                    if (rc) {
                        d_logStream << "Error reading unknown element '"
                                    << elementName << "' or after it\n";
                        return -1;                                    // RETURN
                    }
                }
                else {
                    d_logStream << "Unknown element '"
                                << elementName << "' found\n";
                    return -1;                                        // RETURN
                }
            }

            rc = d_parser.advanceToNextToken();
            if (rc) {
                d_logStream << "Could not decode sequence, error reading token"
                            << " after value for attribute '"
                            << d_elementName << "' \n";
                return -1;                                            // RETURN
            }
        }

        if (baejsn_Parser::BAEJSN_END_OBJECT != d_parser.tokenType()) {
            d_logStream << "Could not decode sequence, "
                        << "missing terminator '}' or seperator ','\n";
            return -1;                                                // RETURN
        }

        --d_currentDepth;
    }
    return 0;
}

template <typename TYPE>
int baejsn_Decoder::decodeImp(TYPE *value,
                              int   mode,
                              bdeat_TypeCategory::Choice)
{
    if (bdeat_FormattingMode::BDEAT_UNTAGGED & mode) {
        bslstl::StringRef selectionName;
        selectionName.assign(d_elementName.begin(), d_elementName.end());

        if (bdeat_ChoiceFunctions::hasSelection(
                                   *value,
                                   selectionName.data(),
                                   static_cast<int>(selectionName.length()))) {
            if (0 != bdeat_ChoiceFunctions::makeSelection(
                                   value,
                                   selectionName.data(),
                                   static_cast<int>(selectionName.length()))) {
                d_logStream << "Could not decode choice, bad selection name '"
                            << selectionName << "' \n";
                return -1;                                            // RETURN
            }

            baejsn_Decoder_ElementVisitor visitor = { this, mode };

            if (0 != bdeat_ChoiceFunctions::manipulateSelection(value,
                                                                visitor)) {
                d_logStream << "Could not decode choice, selection "
                            << "was not decoded\n";
                return -1;                                            // RETURN
            }
        }
        else {
            if (d_skipUnknownElements) {
                const int rc = skipUnknownElement(selectionName);
                if (rc) {
                     d_logStream << "Error reading unknown element '"
                                << selectionName << "' or after that "
                                << "element\n";
                    return -1;                                        // RETURN
                }
            }
            else {
                d_logStream << "Unknown element '"
                            << selectionName << "' found\n";
                return -1;                                            // RETURN
            }
        }
    }
    else {
        if (++d_currentDepth > d_maxDepth) {
            d_logStream << "Maximum allowed decoding depth reached: "
                        << d_currentDepth << "\n";
            return -1;                                                // RETURN
        }

        if (baejsn_Parser::BAEJSN_START_OBJECT != d_parser.tokenType()) {
            d_logStream << "Could not decode choice, missing starting {\n";
            return -1;                                                // RETURN
        }

        int rc = d_parser.advanceToNextToken();
        if (rc) {
            d_logStream << "Could not decode choice, "
                        << "error reading token after {\n";
            return -1;                                                // RETURN
        }

        if (baejsn_Parser::BAEJSN_ELEMENT_NAME == d_parser.tokenType()) {
            bslstl::StringRef selectionName;
            rc = d_parser.value(&selectionName);
            if (rc) {
                d_logStream << "Error reading selection name after '{'\n";
                return -1;                                            // RETURN
            }

            if (bdeat_ChoiceFunctions::hasSelection(
                                   *value,
                                   selectionName.data(),
                                   static_cast<int>(selectionName.length()))) {
                if (0 != bdeat_ChoiceFunctions::makeSelection(
                                   value,
                                   selectionName.data(),
                                   static_cast<int>(selectionName.length()))) {
                    d_logStream << "Could not decode choice, bad selection "
                                << "name '" << selectionName << "' \n";
                    return -1;                                        // RETURN
                }

                rc = d_parser.advanceToNextToken();
                if (rc) {
                    d_logStream << "Could not decode choice, "
                                << "error reading value \n";
                    return -1;                                        // RETURN
                }

                baejsn_Decoder_ElementVisitor visitor = { this, mode };

                if (0 != bdeat_ChoiceFunctions::manipulateSelection(value,
                                                                    visitor)) {
                    d_logStream << "Could not decode choice, selection "
                                << "was not decoded\n";
                    return -1;                                        // RETURN
                }
            }
            else {
                if (d_skipUnknownElements) {
                    rc = skipUnknownElement(selectionName);
                    if (rc) {
                        d_logStream << "Error reading unknown element '"
                                    << selectionName << "' or after that "
                                    << "element\n";
                        return -1;                                    // RETURN
                    }
                }
                else {
                    d_logStream << "Unknown element '"
                                << selectionName << "' found\n";
                    return -1;                                        // RETURN
                }
            }

            rc = d_parser.advanceToNextToken();
            if (rc) {
                d_logStream << "Could not decode choice, error reading "
                            << "token after value for selection \n";
                return -1;                                            // RETURN
            }
        }

        if (baejsn_Parser::BAEJSN_END_OBJECT != d_parser.tokenType()) {
            d_logStream << "Could not decode choice, "
                        << "missing terminator '}'\n";
            return -1;                                                // RETURN
        }

        --d_currentDepth;
    }
    return 0;
}

template <typename TYPE>
int baejsn_Decoder::decodeImp(TYPE *value,
                              int,
                              bdeat_TypeCategory::Enumeration)
{
    enum { BAEJSN_MIN_ENUM_STRING_LENGTH = 2 };

    if (baejsn_Parser::BAEJSN_ELEMENT_VALUE != d_parser.tokenType()) {
        d_logStream << "Enumeration element value was not found\n";
        return -1;                                                    // RETURN
    }

    bslstl::StringRef dataValue;
    int rc = d_parser.value(&dataValue);
    if (rc
     || dataValue.length() <= BAEJSN_MIN_ENUM_STRING_LENGTH
     || '"'                != dataValue[0]
     || '"'                != dataValue[dataValue.length() - 1]) {
        d_logStream << "Error reading enumeration value\n";
        return -1;                                                    // RETURN
    }

    dataValue.assign(dataValue.begin() + 1, dataValue.end() - 1);
    rc = bdeat_EnumFunctions::fromString(value,
                                         dataValue.data(),
                                         static_cast<int>(dataValue.length()));

    if (rc) {
        d_logStream << "Could not decode Enum String, value not allowed \""
                    << dataValue << "\"\n";
    }
    return rc;
}

template <typename TYPE>
int baejsn_Decoder::decodeImp(TYPE *value,
                              int,
                              bdeat_TypeCategory::CustomizedType)
{
    if (baejsn_Parser::BAEJSN_ELEMENT_VALUE != d_parser.tokenType()) {
        d_logStream << "Customized element value was not found\n";
        return -1;                                                    // RETURN
    }

    bslstl::StringRef dataValue;
    int rc = d_parser.value(&dataValue);
    if (rc) {
        d_logStream << "Error reading customized type value\n";
        return -1;                                                    // RETURN
    }

    typename bdeat_CustomizedTypeFunctions::BaseType<TYPE>::Type valueBaseType;

    rc = baejsn_ParserUtil::getValue(&valueBaseType, dataValue);
    if (rc) {
        d_logStream << "Could not decode Enum Customized, "
                    << "value not allowed \"" << valueBaseType << "\"\n";
        return -1;                                                    // RETURN
    }

    rc = bdeat_CustomizedTypeFunctions::convertFromBaseType(value,
                                                            valueBaseType);
    if (rc) {
        d_logStream << "Could not convert base type to customized type, "
                    << "base value disallowed: \"" << valueBaseType << "\"\n";
    }
    return rc;
}

template <typename TYPE>
int baejsn_Decoder::decodeImp(TYPE *value,
                              int,
                              bdeat_TypeCategory::Simple)
{
    if (baejsn_Parser::BAEJSN_ELEMENT_VALUE != d_parser.tokenType()) {
        d_logStream << "Simple element value was not found\n";
        return -1;                                                    // RETURN
    }

    bslstl::StringRef dataValue;
    int rc = d_parser.value(&dataValue);
    if (rc) {
        d_logStream << "Error reading simple value\n";
        return -1;                                                    // RETURN
    }

    return baejsn_ParserUtil::getValue(value, dataValue);
}

inline
int baejsn_Decoder::decodeImp(bsl::vector<char> *value,
                              int,
                              bdeat_TypeCategory::Array)
{
    return decodeBinaryArray(value);
}

template <typename TYPE>
int baejsn_Decoder::decodeImp(TYPE *value,
                              int   mode,
                              bdeat_TypeCategory::Array)
{
    if (baejsn_Parser::BAEJSN_START_ARRAY != d_parser.tokenType()) {
        d_logStream << "Could not decode vector, missing start token: '['\n";
        return -1;                                                    // RETURN
    }

    const int rc = d_parser.advanceToNextToken();
    if (rc) {
        return rc;                                                    // RETURN
    }

    int i = 0;
    while (baejsn_Parser::BAEJSN_END_ARRAY != d_parser.tokenType()) {
        if (baejsn_Parser::BAEJSN_ELEMENT_VALUE == d_parser.tokenType()
         || baejsn_Parser::BAEJSN_START_OBJECT  == d_parser.tokenType()) {

            ++i;
            bdeat_ArrayFunctions::resize(value, i);

            baejsn_Decoder_ElementVisitor visitor = { this, mode };

            if (0 != bdeat_ArrayFunctions::manipulateElement(value,
                                                             visitor,
                                                             i - 1)) {
                d_logStream << "Error adding element '" << i - 1 << "'\n";
                return -1;                                            // RETURN
            }

            const int rc = d_parser.advanceToNextToken();
            if (rc) {
                d_logStream << "Error reading token after value of element '"
                            << i - 1 << "'\n";
                return rc;                                            // RETURN
            }
        }
        else {
            d_logStream << "Erroneous token found instead of array element\n";
            return -1;                                                // RETURN
        }
    }

    if (baejsn_Parser::BAEJSN_END_ARRAY != d_parser.tokenType()) {
        d_logStream << "Could not decode vector, missing end token: ']'\n";
        return -1;                                                    // RETURN
    }

    return 0;
}

template <typename TYPE>
int baejsn_Decoder::decodeImp(TYPE *value,
                              int   mode,
                              bdeat_TypeCategory::NullableValue)
{
    enum { BAEJSN_NULL_VALUE_LENGTH = 4 };

    if (baejsn_Parser::BAEJSN_ELEMENT_VALUE == d_parser.tokenType()) {
        bslstl::StringRef dataValue;
        const int rc = d_parser.value(&dataValue);
        if (rc) {
            return rc;                                                // RETURN
        }

        if (BAEJSN_NULL_VALUE_LENGTH == dataValue.length()
         && 'n'                      == dataValue[0]
         && 'u'                      == dataValue[1]
         && 'l'                      == dataValue[2]
         && 'l'                      == dataValue[3]) {
            return 0;                                                 // RETURN
        }
    }

    bdeat_NullableValueFunctions::makeValue(value);

    baejsn_Decoder_ElementVisitor visitor = { this, mode };
    return bdeat_NullableValueFunctions::manipulateValue(value, visitor);
}

template <typename TYPE, typename ANY_CATEGORY>
inline
int baejsn_Decoder::decodeImp(TYPE *, ANY_CATEGORY)
{
    BSLS_ASSERT_OPT(!"Unreachable");

    return -1;
}

// CREATORS
inline
baejsn_Decoder::baejsn_Decoder(bslma_Allocator *basicAllocator)
: d_logStream(basicAllocator)
, d_parser(basicAllocator)
, d_elementName(basicAllocator)
, d_currentDepth(0)
, d_maxDepth(0)
, d_skipUnknownElements(false)
{
}

// MANIPULATORS
template <typename TYPE>
int baejsn_Decoder::decode(bsl::streambuf               *streamBuf,
                           TYPE                         *value,
                           const baejsn_DecoderOptions&  options)
{
    BSLS_ASSERT(streamBuf);
    BSLS_ASSERT(value);

    bdeat_TypeCategory::Value category =
                                bdeat_TypeCategoryFunctions::select(*value);

    if (bdeat_TypeCategory::BDEAT_SEQUENCE_CATEGORY != category
     && bdeat_TypeCategory::BDEAT_CHOICE_CATEGORY   != category
     && bdeat_TypeCategory::BDEAT_ARRAY_CATEGORY    != category) {
        d_logStream << "The object being decoded must be a Sequence, "
                    << "Choice, or Array type\n";
        return -1;                                                    // RETURN
    }

    d_parser.reset(streamBuf);

    typedef typename bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    const int rc = d_parser.advanceToNextToken();
    if (rc) {
        d_logStream << "Error advancing to the first token. "
                    << "Expecting a '{' or '[' as the first character\n";
        return rc;                                                    // RETURN
    }

    bdeat_ValueTypeFunctions::reset(value);

    d_logStream.clear();
    d_logStream.str("");

    d_maxDepth            = options.maxDepth();
    d_skipUnknownElements = options.skipUnknownElements();

    return decodeImp(value, 0, TypeCategory());
}

template <typename TYPE>
int baejsn_Decoder::decode(bsl::istream&                 stream,
                           TYPE                         *value,
                           const baejsn_DecoderOptions&  options)
{
    if (!stream.good()) {
        return -1;                                                    // RETURN
    }

    if (0 != decode(stream.rdbuf(), value, options)) {
        stream.setstate(bsl::ios_base::failbit);
        return -1;                                                    // RETURN
    }

    return 0;
}

template <typename TYPE>
int baejsn_Decoder::decode(bsl::streambuf *streamBuf, TYPE *value)
{
    const baejsn_DecoderOptions options;
    return decode(streamBuf, value, options);
}

template <typename TYPE>
int baejsn_Decoder::decode(bsl::istream& stream, TYPE *value)
{
    const baejsn_DecoderOptions options;
    return decode(stream, value, options);
}

// ACCESSORS
inline
bsl::string baejsn_Decoder::loggedMessages() const
{
    return d_logStream.str();
}

                    // ------------------------------------
                    // struct baejsn_Decoder_ElementVisitor
                    // ------------------------------------

template <typename TYPE>
inline
int baejsn_Decoder_ElementVisitor::operator()(TYPE *value)
{
    typedef typename bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;
    return d_decoder_p->decodeImp(value, d_mode, TypeCategory());
}

template <typename TYPE, typename INFO>
inline
int baejsn_Decoder_ElementVisitor::operator()(TYPE *value, const INFO& info)
{
    typedef typename bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;
    return d_decoder_p->decodeImp(value,
                                  info.formattingMode(),
                                  TypeCategory());
}

                    // ------------------------------------
                    // struct baejsn_Decoder_DecodeImpProxy
                    // ------------------------------------

// MANIPULATORS
template <typename TYPE>
inline
int baejsn_Decoder_DecodeImpProxy::operator()(TYPE *, bslmf_Nil)
{
    BSLS_ASSERT_OPT(!"Unreachable");

    return -1;
}

template <typename TYPE, typename ANY_CATEGORY>
inline
int baejsn_Decoder_DecodeImpProxy::operator()(TYPE         *object,
                                              ANY_CATEGORY  category)
{
    return d_decoder_p->decodeImp(object, d_mode, category);
}

}  // close namespace BloombergLP

#endif

// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2012
//      All Rights Reserved.
//      Property of Bloomberg L.P.  (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ----------------------------------
