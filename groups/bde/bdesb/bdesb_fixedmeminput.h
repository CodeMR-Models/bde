// bdesb_fixedmeminput.h                                              -*-C++-*-
#ifndef INCLUDED_BDESB_FIXEDMEMINPUT
#define INCLUDED_BDESB_FIXEDMEMINPUT

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide a basic input stream buffer using a client buffer.
//
//@CLASSES:
//   bdesb_FixedMemInput: basic input stream buffer using client memory
//
//@AUTHOR: Herve Bronnimann (hbronnimann)
//
//@SEE_ALSO: bdesb_fixedmeminstreambuf
//
//@DESCRIPTION: This component implements the input portion of the
// 'bsl::basic_streambuf' protocol using a client-supplied memory buffer.
// Method names necessarily correspond to the protocol-specified method names.
// Clients supply the character buffer at stream buffer construction, and can
// later reinitialize the stream buffer with a different character buffer by
// calling the 'pubsetbuf' method.  The only difference between this component
// and 'bdesb_fixedmeminstreambuf' is that the class 'bdesb_FixedMemInput' does
// *not* derive from a 'bsl::streambuf', and is generally more efficient (at
// initialization and due to the lack of virtual functions).
//
///Usage
///-----
// See the 'bdesb_fixedmeminstreambuf' component for an identical usage
// example, where every occurrence of 'bdesb_FixedMemInStreamBuf' can be
// substituted for 'bdesb_FixedMemInput'.

#ifndef INCLUDED_BDESCM_VERSION
#include <bdescm_version.h>
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include <bsls_performancehint.h>
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include <bsls_platform.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include <bsl_algorithm.h>
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include <bsl_cstdlib.h>
#endif

#ifndef INCLUDED_BSL_CSTRING
#include <bsl_cstring.h>
#endif

#ifndef INCLUDED_BSL_IOS
#include <bsl_ios.h>
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include <bsl_iosfwd.h>
#endif


namespace BloombergLP {

                        // =========================
                        // class bdesb_FixedMemInput
                        // =========================

class bdesb_FixedMemInput {
    // This class, like 'bdesb_FixedMemInStreamBuf', implements the input
    // functionality of the 'basic_streambuf' interface, using client-supplied
    // 'char *' memory.  It has an interface identical to
    // 'bdesb_FixedMemInStreamBuf' but does *not* inherit from
    // 'bsl::streambuf'.  Thus, it is suitable for use as template parameter to
    // 'bdex_GenericByteInStream' (but not to 'bdex_ByteInStreamFormatter').
    // This usage is advantageous for performance reasons, as the overhead of
    // the initialization and virtual function calls of a 'bsl::streambuf' can
    // be undesirable.  It is especially designed for streaming a very small
    // amount of information from a fixed-length buffer using a
    // 'bdex_GenericByteInStream' when the number of characters read from the
    // input is guaranteed not to exceed the length of the buffer.  Note that
    // this class is not designed to be derived from.

  public:
    // TYPES
    typedef char                             char_type;
    typedef bsl::char_traits<char>::int_type int_type;
    typedef bsl::char_traits<char>::pos_type pos_type;
    typedef bsl::char_traits<char>::off_type off_type;
    typedef bsl::char_traits<char>           traits_type;

  private:
    // PRIVATE DATA MEMBERS
    const char      *d_buffer_p;      // buffer (held, not owned)
    bsl::streamsize  d_bufferLength;  // buffer length (not length of stream)
    pos_type         d_pos;           // current read position

  private:
    // NOT IMPLEMENTED
    bdesb_FixedMemInput(const bdesb_FixedMemInput&);
    bdesb_FixedMemInput& operator=(const bdesb_FixedMemInput&);

  public:
    // CREATORS
    bdesb_FixedMemInput(const char *buffer, bsl::streamsize length);
        // Create a 'bdesb_FixedMemInput' using the specified 'buffer' of the
        // specified 'length'.  The behavior is undefined unless 0 < 'length'.

    //! ~bdesb_FixedMemInput();
        // Destroy this stream buffer.  Note that this trivial destructor is
        // generated by the compiler.

    // MANIPULATORS

                             // *** 27.5.2.2.2 buffer and positioning: ***

    bdesb_FixedMemInput *pubsetbuf(char            *buffer,
                                   bsl::streamsize  length);
    bdesb_FixedMemInput *pubsetbuf(const char      *buffer,
                                   bsl::streamsize  length);
        // Reinitialize this stream buffer to use the specified character
        // 'buffer' having the specified 'length'.  Return the address of this
        // modifiable stream buffer.  Upon reinitialization for use of the new
        // buffer, neither the content nor the next input location is
        // preserved.  Note that 'buffer' is held but not owned.

    pos_type pubseekoff(off_type                offset,
                        bsl::ios_base::seekdir  fixedPosition,
                        bsl::ios_base::openmode which = bsl::ios_base::in
                                                      | bsl::ios_base::out);
        // Move the current write cursor position by the specified 'offset'.

    pos_type pubseekpos(pos_type                position,
                        bsl::ios_base::openmode which = bsl::ios_base::in
                                                      | bsl::ios_base::out);
        // Move the current write cursor position to the specified 'position'.

                             // *** 27.5.2.2.3 Get area: ***

    bsl::streamsize in_avail();
        // Return the number of characters available from the current read
        // position in this stream buffer.

    int_type sbumpc();
        // Return the character at the current read position from this buffer,
        // or 'traits_type::eof()' if the end of the buffer is reached.

    int_type sgetc();
        // Return the character at the current read position from this buffer,
        // or 'traits_type::eof()' if the end of the buffer is reached.

    int_type snextc();
        // Advance the current read position and return the character at the
        // resulting position from this buffer, or 'traits_type::eof()' if the
        // end of the buffer is reached.

    bsl::streamsize sgetn(char_type *destination, bsl::streamsize length);
        // Write up to the specified 'n' characters from the current position
        // of this buffer, to the specified address 's', as if by calling the
        // 'sbumpc' method repeatedly 'n' times.  Return the number of
        // characters read from this buffer, which is either equal to the
        // 'length' parameter or equal to the distance from the current read
        // position to the end of the input buffer, whichever is smaller, and
        // move the read cursor position by this amount.

                             // *** 27.5.2.2.4 Putback: ***

    int_type sputbackc(char c);
        // Move the current read position back one character if the current
        // read position is not at the beginning of the buffer and the previous
        // position contains the character 'c', and return that character.
        // Otherwise, return 'traits_type::eof()' and do not move the current
        // read position.

    int_type sungetc();
        // Move the current read position back one character if the current
        // read position is not at the beginning of the buffer, and return the
        // character at the resulting current read position from this buffer.
        // Return 'traits_type::eof()' otherwise.

    // ACCESSORS
    bsl::streamsize capacity() const;
        // Return the size for the buffer held by this buffer, in bytes,
        // supplied at construction.

    const char *data() const;
        // Return the address of the non-modifiable character buffer held by
        // this stream buffer.

    bsl::streamsize length() const;
        // Return the number of characters that can be successfully read from
        // this stream buffer before reading 'traits_type::eof()' -- i.e., the
        // number of characters between the current read position and the end
        // of this buffer.
};

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

                        // -------------------------
                        // class bdesb_FixedMemInput
                        // -------------------------

// CREATORS
inline
bdesb_FixedMemInput::bdesb_FixedMemInput(const char      *buffer,
                                         bsl::streamsize  length)
: d_buffer_p(const_cast<char *>(buffer))
, d_bufferLength(length)
, d_pos(0)
{
}

// MANIPULATORS
inline
bdesb_FixedMemInput *bdesb_FixedMemInput::pubsetbuf(char            *buffer,
                                                    bsl::streamsize  length)
{
    d_buffer_p     = const_cast<const char *>(buffer);
    d_bufferLength = length;
    d_pos          = 0;
    return this;
}

inline
bdesb_FixedMemInput *bdesb_FixedMemInput::pubsetbuf(const char      *buffer,
                                                    bsl::streamsize  length)

{
    d_buffer_p     = buffer;
    d_bufferLength = length;
    d_pos          = 0;
    return this;
}

inline
bsl::streamsize bdesb_FixedMemInput::in_avail()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                   bsl::streamsize(d_pos) == d_bufferLength)) {
        return bsl::streamsize(-1);
    }
    return d_bufferLength - d_pos;
}

inline
bdesb_FixedMemInput::int_type bdesb_FixedMemInput::sbumpc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos >= d_bufferLength)) {
        return traits_type::eof();
    }
    const int_type i = traits_type::to_int_type(d_buffer_p[d_pos]);
    d_pos += 1;
    return i;
}

inline
bdesb_FixedMemInput::int_type bdesb_FixedMemInput::sgetc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos >= d_bufferLength)) {
        return traits_type::eof();
    }
    return traits_type::to_int_type(d_buffer_p[d_pos]);
}

inline
bdesb_FixedMemInput::int_type bdesb_FixedMemInput::snextc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(sbumpc() == traits_type::eof())){
        return traits_type::eof();
    }
    return traits_type::to_int_type(d_buffer_p[d_pos]);
}

inline
bsl::streamsize
bdesb_FixedMemInput::sgetn(char *destination, bsl::streamsize length)
{
    const pos_type current = d_pos;
    d_pos += length;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos > d_bufferLength)) {
        d_pos  = d_bufferLength;
        length = d_bufferLength - current;
    }
    bsl::memcpy(destination, d_buffer_p + current, length);
    return length;
}

inline
bdesb_FixedMemInput::int_type bdesb_FixedMemInput::sputbackc(char c)
{
    d_pos -= 1;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(-1 == d_pos)
     || BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(c != d_buffer_p[d_pos])) {
        d_pos += 1;
        return traits_type::eof();
    }
    return traits_type::to_int_type(c);
}

inline
bdesb_FixedMemInput::int_type bdesb_FixedMemInput::sungetc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(0 == d_pos)) {
        return traits_type::eof();
    }
    d_pos -= 1;
    return traits_type::to_int_type(d_buffer_p[d_pos]);
}

// ACCESSORS
inline
bsl::streamsize bdesb_FixedMemInput::capacity() const
{
    return d_bufferLength;
}

inline
const char *bdesb_FixedMemInput::data() const
{
    return d_buffer_p;
}

inline
bsl::streamsize bdesb_FixedMemInput::length() const
{
    return d_bufferLength - d_pos;
}

}  // end namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2007
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
