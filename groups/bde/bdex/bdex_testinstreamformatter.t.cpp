// bdex_testinstreamformatter.t.cpp              -*-C++-*-

#include <bdex_testinstreamformatter.h>
#include <bdex_testinstream.h>
#include <bdex_fieldcode.h>
#include <bdex_instreamfunctions.h>
#include <bdex_outstreamfunctions.h>
#include <bdex_testinstreamexception.h>
#include <bdex_testoutstreamformatter.h>                 // for testing only

#include <bdesb_fixedmeminstreambuf.h>
#include <bdesb_memoutstreambuf.h>

#include <bsls_types.h>

#include <bsl_cstdlib.h>     // atoi()
#include <bsl_cstdio.h>      // sprintf()
#include <bsl_cstring.h>     // memcpy(), memcmp(), strlen()
#include <bsl_iostream.h>
#include <bsl_strstream.h>

using namespace BloombergLP;
using namespace bsl;  // automatically added by script

//=============================================================================
//                                 TEST PLAN
//-----------------------------------------------------------------------------
//                                 Overview
//                                 --------
// We are testing a "test" implementation of the 'bdex_InStream' protocol.
// This implementation is designed to consume extra "informational data" in a
// data stream generated by a corresponding "test" implementation of
// 'bdex_OutStream' protocol.  The "informational data" allows an object to
// identify the type (and size, for arrays) of the actual data.
//
// For each input method, we must verify the placement of the next-input-byte-
// position cursor and the alignment of byte values, as in the "normal"
// implementation.  In addition, we must verify that "informational data" is
// read and used to detect invalid data.  We accomplish these goals by
// configuring data streams containing either valid or invalid data, and verify
// the "unexternalized" values as well as the validity of the stream objects.
//
// We must also verify that when a stream is configured with a non-negative
// input limit, each input method correctly modifies the input limit and throws
// an exception when the input limit transitions from 0 to -1.  We achieve this
// goal by configuring test input stream objects with varying input limit
// values and invoke each input method repeatedly to ensure that exceptions are
// thrown when expected.
//-----------------------------------------------------------------------------
// [ 3] bdex_TestInStreamFormatter();
// [ 3] bdex_TestInStreamFormatter(const char *buffer, int numBytes);
// [ 3] ~bdex_TestInStreamFormatter();
// [ 3] setQuiet(int flag);
// [ 3] setSuppressVersionCheck(int flag);
// [27] setInputLimit(int limit);
// [26] seek(int offset);
// [26] reset();
// [29] reload(const char *buffer, int numBytes);
// [30] getLength(int& variable);
// [30] getVersion(int& variable);
// [13] getInt64(bsls::Types::Int64& variable);
// [13] getUint64(bsls::Types::Uint64& variable);
// [12] getInt56(bsls::Types::Int64& variable);
// [12] getUint56(bsls::Types::Uint64& variable);
// [11] getInt48(bsls::Types::Int64& variable);
// [11] getUint48(bsls::Types::Uint64& variable);
// [10] getInt40(bsls::Types::Int64& variable);
// [10] getUint40(bsls::Types::Uint64& variable);
// [ 9] getInt32(int& variable);
// [ 9] getUint32(unsigned int& variable);
// [ 8] getInt24(int& variable);
// [ 8] getUint24(unsigned int& variable);
// [ 7] getInt16(short& variable);
// [ 7] getUint16(unsigned short& variable);
// [ 3] getInt8(char& variable);
// [ 6] getInt8(signed char& variable);
// [ 6] getUint8(char& variable);
// [ 6] getUint8(unsigned char& variable);
// [15] getFloat64(double& variable);
// [14] getFloat32(float& variable);
// [23] getArrayInt64(bsls::Types::Int64 *array, int numValues);
// [23] getArrayUint64(bsls::Types::Uint64 *array, int numValues);
// [22] getArrayInt56(bsls::Types::Int64 *array, int numValues);
// [22] getArrayUint56(bsls::Types::Uint64 *array, int numValues);
// [21] getArrayInt48(bsls::Types::Int64 *array, int numValues);
// [21] getArrayUint48(bsls::Types::Uint64 *array, int numValues);
// [20] getArrayInt40(bsls::Types::Int64 *array, int numValues);
// [20] getArrayUint40(bsls::Types::Uint64 *array, int numValues);
// [19] getArrayInt32(int *array, int numValues);
// [19] getArrayUint32(unsigned int *array, int numValues);
// [18] getArrayInt24(int *array, int numValues);
// [18] getArrayUint24(unsigned int *array, int numValues);
// [17] getArrayInt16(short *array, int numValues);
// [17] getArrayUint16(unsigned short *array,int numValues);
// [16] getArrayInt8(char *array, int numValues);
// [16] getArrayInt8(signed char *array, int numValues);
// [16] getArrayUint8(char *array, int numValues);
// [16] getArrayUint8(unsigned char *array, int numValues);
// [25] getArrayFloat64(double *array, int numValues);
// [24] getArrayFloat32(float *array, int numValues);
// [ 3] void invalidate();
// [ 4] operator const void *() const;
// [ 4] int length() const;
// [ 4] int cursor() const;
// [ 3] bool isQuiet() const;
// [ 3] bool isSuppressVersionCheck() const;
// [19] int inputLimit() const;
//-----------------------------------------------------------------------------
// [31] USAGE TEST
// [ 1] BREATHING TEST
// [ 2] int g(Out* o, const char* spec);
// [28] Ensure every input method correctly modifies the input limit and throws
//      an exception when the input limit is exceeded.
//=============================================================================
//                      STANDARD BDE ASSERT TEST MACRO
//-----------------------------------------------------------------------------
static int testStatus = 0;
static void aSsErT(int c, const char *s, int i)
{
    if (c) {
        cout << "Error " << __FILE__ << "(" << i << "): " << s
             << "    (failed)" << endl;
        if (testStatus >= 0 && testStatus <= 100) ++testStatus;
    }
}
#define ASSERT(X) { aSsErT(!(X), #X, __LINE__); }

//=============================================================================
//                    STANDARD BDE LOOP-ASSERT TEST MACROS
//-----------------------------------------------------------------------------

#define LOOP_ASSERT(I,X) { \
    if (!(X)) { cout << #I << ": " << I << "\n"; aSsErT(1, #X, __LINE__);}}

#define LOOP2_ASSERT(I,J,X) { \
    if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " \
        << J << "\n"; aSsErT(1, #X, __LINE__); } }

#define LOOP3_ASSERT(I,J,K,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" \
              << #K << ": " << K << "\n"; aSsErT(1, #X, __LINE__); } }

#define LOOP4_ASSERT(I,J,K,L,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" << \
       #K << ": " << K << "\t" << #L << ": " << L << "\n"; \
       aSsErT(1, #X, __LINE__); } }

//=============================================================================
//                      SEMI-STANDARD TEST OUTPUT MACROS
//-----------------------------------------------------------------------------

#define P(X) cout << #X " = " << (X) << endl; // Print identifier and value.
#define Q(X) cout << "<| " #X " |>" << endl;  // Quote identifier literally.
#define P_(X) cout << #X " = " << (X) << ", " << flush; // P(X) without '\n'
#define L_ __LINE__                           // current Line number

//=============================================================================
//                   GLOBAL TYPEDEFS/CONSTANTS FOR TESTING
//-----------------------------------------------------------------------------

#define INT8_FL   "\xe0"
#define INT8_BITS "11100000"

typedef bdex_FieldCode FC;

const int SIZEOF_INT64   = 8;
const int SIZEOF_INT56   = 7;
const int SIZEOF_INT48   = 6;
const int SIZEOF_INT40   = 5;
const int SIZEOF_INT32   = 4;
const int SIZEOF_INT24   = 3;
const int SIZEOF_INT16   = 2;
const int SIZEOF_INT8    = 1;
const int SIZEOF_FLOAT64 = 8;
const int SIZEOF_FLOAT32 = 4;
const int SIZEOF_VERSION = 1;
const int VERSION        = 1;
const int SIZEOF_CODE    = 1;
const int VERSION_LEN    = SIZEOF_CODE + SIZEOF_VERSION;

const char           VA[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const signed char    VB[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const char           VC[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const unsigned char  VD[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const short          VE[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const unsigned short VF[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const int            VG[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const unsigned int   VH[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const bsls::Types::Int64
                     VI[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const bsls::Types::Uint64
                     VJ[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const float          VK[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const double         VL[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// The following constants are added for to match the optimized methods for
// integer types, such as 'putInt24', 'putInt56', etc.
const int            VM[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const unsigned int   VN[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const bsls::Types::Int64
                     VO[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const bsls::Types::Uint64
                     VP[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const bsls::Types::Int64
                     VQ[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const bsls::Types::Uint64
                     VR[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const bsls::Types::Int64
                     VS[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
const bsls::Types::Uint64
                     VT[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Data structure that contains testing data to test array input methods using
// the function 'testGetArray' (defined below).
struct ArrayTestTable {
    int         d_line;          // line number
    const char *d_spec;          // spec to create test stream
    int         d_suppressVer;   // suppress version mode
    int         d_isValid;       // expected final validity of
                                 //     bdex_TestInStreamFormatter
    int         d_numArr;        // # arrays to read from stream
    int         d_arrLen[10];    // lengths of the arrays to read
    int         d_expArrLen[10]; // expected lengths of the arrays read
};

// Data structure that contains testing data to test scalar input methods using
// the function 'testGetScalar' (defined below).
template <class ElemType>
struct ScalarTestTable {
    int         d_line;          // line number
    const char *d_spec;          // spec to create test stream
    int         d_suppressVer;   // suppress version mode
    int         d_numVals;       // # of values to read from stream
    ElemType    d_exp[10];       // array of expected values read
};

struct InputLimitTestTable {
    int d_line;            // line number
    int d_inputLimit;      // input limit of stream
    int d_numInput;        // # of times an input method is invoked
    int d_willThrow;       // nonzero if exception is expected to be thrown
    int d_numSuccessInput; // # of times an input method is expected to succeed
};

// static int globalVerbose;
static int globalVeryVerbose;
// static int globalVeryVeryVerbose;

//=============================================================================
//                    GENERATOR FUNCTION 'g' FOR TESTING
//-----------------------------------------------------------------------------
// The following function interprets the given 'spec' in order from left to
// right to configure a 'bdex_TestOutStreamFormatter' object according to a
// custom language.  The language consists of letters in the ranges [A-T] and
// [a-t], and digits in the range [0-9].  A letter must be followed by one or
// more digits.  Each letter is associated with an unique output method to be
// invoked by the object.  The association is as follows:
//
// LETTER      OUTPUT METHOD      LETTER      OUTPUT METHOD
// ----------  ---------------    ----------  ------------------
//    A          putInt8             a          putArrayInt8
//    B          putInt8             b          putArrayInt8  (signed char)
//    C          putUint8            c          putArrayUint8
//    D          putUint8            d          putArrayUint8 (unsigned char)
//    E          putInt16            e          putArrayInt16
//    F          putUint16           f          putArrayUint16
//    G          putInt32            g          putArrayInt32
//    H          putUint32           h          putArrayUint32
//    I          putInt64            i          putArrayInt64
//    J          putUint64           j          putArrayUint64
//    K          putFloat32          k          putArrayFloat32
//    L          putFloat64          l          putArrayFloat64
//
//    M          putInt24            m          putArrayInt24
//    N          putUint24           n          putArrayUint24
//    O          putInt40            o          putArrayInt40
//    P          putUint40           p          putArrayUint40
//    Q          putInt48            q          putArrayInt48
//    R          putUint48           r          putArrayUint48
//    S          putInt56            s          putArrayInt56
//    T          putUint56           t          putArrayUint56
//
// Each letter is also case-insensitively associated with a predefined data
// array (see above definitions) having a name of the form VX, where X is in
// the range [A-T].
//
// For each uppercase letter (corresponding to a scalar
// bdex_TestOutStreamFormatter::put* method), each digit N serves as an index
// into VX.  Thus, the spec 'G2' invokes 'putInt32' with the value VG[2].
//
// For each lowercase letter (corresponding to an array
// bdex_TestOutStreamFormatter::put* method), each digit N indicates the first
// N elements of VX.  Thus, the spec 'l3' invokes 'putArrayFloat64' with the
// array VL, and length 3.
//
//
// LANGUAGE SPECIFICATION:
// -----------------------
//
// <SPEC>       ::= <EMPTY>
//                | <ITEM_LIST>
//
// <ITEM_LIST>  ::= <ITEM>
//                | <ITEM><ITEM_LIST>
//
// <ITEM>       ::= <ALPHA><DIGIT_LIST>
//
// <DIGIT_LIST> ::= <DIGIT>
//                | <DIGIT><DIGIT_LIST>
//
// <DIGIT>      ::= [0-9]
// <ALPHA>      ::= [A-Ta-t]
//
// <EMPTY>      ::=
//
// *Note - spaces may be inserted in any part of the language.
//
// Sample Spec  Description
// -----------  ---------------------------------------------------------------
// ""           Has no effect; leaves the bdex_TestInStreamFormatter empty.
// "A0"         Externalize 'VA[0]' by calling 'putInt8(VA[0])'.
// "A123"       Externalize 'VA[1]', 'VA[2]', and 'VA[3]' by calling 'putInt8'
//              with 'VA[1]', 'VA[2]', and 'VA[3]' as arguments, respectively.
// "a2"         Externalize the first two elements of 'VA' by calling
//              'putArrayInt8(VA, 2)'.
// "a25"        Externalize the first two elements of 'VA' by calling
//              'putArrayInt8(VA, 2)', then the first five elements of 'VA' by
//              calling 'putArrayInt8(VA, 5)'.
// "A01 B234 E5 f6 g23 H1"
//              Externalize 'VA[0]' and 'VA[1]' with 'putInt8'; 'VB[2]',
//              'VB[3]', and 'VB[4]' with 'putUint8'; 'VE[5]' with 'putInt16';
//              the first six elements of 'VF' with 'putArrayUint16(VF, 6)';
//              the first two elements of 'VG' with 'putArrayInt32(VG, 2)'; the
//              first three elements of 'VG' with 'putArrayInt32(VG, 3)', and
//              'VH[1]' with 'putUint32'
//
//-----------------------------------------------------------------------------

int g(bdex_TestOutStreamFormatter* o, const char* spec) {
    // int verbose = globalVerbose;
    int veryVerbose = globalVeryVerbose;

    // read spec from left to right
    for (int i = 0; spec[i]; ++i) {
        if (spec[i] == ' ' || spec[i] == '\t') continue; // Skip spaces

        if (('A' <= spec[i] && spec[i] <= 'T') ||
           ('a' <= spec[i] && spec[i] <= 't' ) ) {
            // found a letter

            bool haveDigit = false; // set to 'true' if digits found following
                                    // letter

            for (int j = i + 1; spec[j]; ++j) {
                if ('0' <= spec[j] && spec[j] <= '9') {
                    // found a digit

                    haveDigit = true;
                    int n = spec[j] - '0';

                    switch(spec[i]) {
                      case 'A':    o->putInt8(VA[n]);            break;
                      case 'B':    o->putInt8(VB[n]);            break;
                      case 'C':    o->putUint8(VC[n]);           break;
                      case 'D':    o->putUint8(VD[n]);           break;
                      case 'E':    o->putInt16(VE[n]);           break;
                      case 'F':    o->putUint16(VF[n]);          break;
                      case 'G':    o->putInt32(VG[n]);           break;
                      case 'H':    o->putUint32(VH[n]);          break;
                      case 'I':    o->putInt64(VI[n]);           break;
                      case 'J':    o->putUint64(VJ[n]);          break;
                      case 'K':    o->putFloat32(VK[n]);         break;
                      case 'L':    o->putFloat64(VL[n]);         break;
                      case 'M':    o->putInt24(VM[n]);           break;
                      case 'N':    o->putUint24(VM[n]);          break;
                      case 'O':    o->putInt40(VO[n]);           break;
                      case 'P':    o->putUint40(VP[n]);          break;
                      case 'Q':    o->putInt48(VQ[n]);           break;
                      case 'R':    o->putUint48(VR[n]);          break;
                      case 'S':    o->putInt56(VS[n]);           break;
                      case 'T':    o->putUint56(VT[n]);          break;
                      case 'a':    o->putArrayInt8(VA, n);       break;
                      case 'b':    o->putArrayInt8(VB, n);       break;
                      case 'c':    o->putArrayUint8(VC, n);      break;
                      case 'd':    o->putArrayUint8(VD, n);      break;
                      case 'e':    o->putArrayInt16(VE, n);      break;
                      case 'f':    o->putArrayUint16(VF, n);     break;
                      case 'g':    o->putArrayInt32(VG, n);      break;
                      case 'h':    o->putArrayUint32(VH, n);     break;
                      case 'i':    o->putArrayInt64(VI, n);      break;
                      case 'j':    o->putArrayUint64(VJ, n);     break;
                      case 'k':    o->putArrayFloat32(VK, n);    break;
                      case 'l':    o->putArrayFloat64(VL, n);    break;
                      case 'm':    o->putArrayInt24(VM, n);      break;
                      case 'n':    o->putArrayUint24(VN, n);     break;
                      case 'o':    o->putArrayInt40(VO, n);      break;
                      case 'p':    o->putArrayUint40(VP, n);     break;
                      case 'q':    o->putArrayInt48(VQ, n);      break;
                      case 'r':    o->putArrayUint48(VR, n);     break;
                      case 's':    o->putArrayInt56(VS, n);      break;
                      case 't':    o->putArrayUint56(VT, n);     break;
                    }
                } else if (spec[j] == ' ' || spec[j] == '\t') {
                    ; // skip spaces
                } else {
                    // spec[j] is not in [0-9] and is not a space.  Break.
                    // assign 'i' to j - 1 b/c 'i' will be incremented later.
                    i = j - 1;
                    break;
                }

                if ('\0' == spec[j + 1]) {
                    // next char is null, assign 'i' and break.
                    i = j;
                    break;
                }
            }

            if (!haveDigit) {
                if (veryVerbose)
                    cout << "*** missing digit after letter ***" << endl;
                return 0;     // discontinue processing this spec.
            }
        } else {
            if (veryVerbose)
                cout << "*** bad character ('" << spec[i] << "') in spec \""
                     << spec << "\" at position " << i << " ***" << endl;
            return 0;         // discontinue processing this spec.
        }
    }
    return 1;
}

//=============================================================================
//                    FUNCTION 'testGetArray' FOR TESTING
//-----------------------------------------------------------------------------
// The function 'testGetArray' is a generic, templatized function to test array
// input methods of various data types.  The function accepts an array of
// vectors having the structure defined by 'ArrayTestTable' (see above) as its
// test data.  It iterates over the vectors in the array and performs an
// independent test for each vector.  In each test, it first generates a test
// stream using the generator function 'g' with spec 'd_spec', then attempts to
// read 'd_numArr' number of arrays from the stream with consecutive array
// input method calls.  For the Nth array input method call, it attempts to
// read an array having a length equal to the value of the Nth element of
// 'd_arrLen' array.  For example, if N is 5 and 'getArrayInt8' is being
// tested, then 'getArrayInt8(input_array, d_arrLen[5])' will be called (where
// 'input_array' is an array that will contain the values read from the stream
// if the call returns successfully).  The resulting length of the input array
// is verified against the value of the Nth element of 'd_expArrLen' array.
// The value of each element in the input array is also verified against the
// value of the respective element in the 'origVal' array.  If a test stream
// contains all valid data, then the stream is verified to be empty and valid
// after all input operations.  If a test stream is intentionally configured
// with invalid data, then after the attempt to read the invalid data, the
// element values of the input array is verified to be unchanged, and that the
// stream becomes invalid.  Note that error messages from the stream
// bdex_TestInStreamFormatter is displayed only in "veryVerbose" mode.
//-----------------------------------------------------------------------------

template <class ElemType, class FuncPtr>
inline
void testGetArray(const ArrayTestTable* data, int numTest,
                  const ElemType *origVal, FuncPtr getArrayFunc)
    // Iterate over the vectors in the specified 'data' by the specified
    // 'numTest' times.  Generate a test stream in each iteration, invoke the
    // array input method pointed to by the specified 'getArrayFunc' member
    // pointer, and then verify the result by comparing the values in the
    // extracted array to the values in the specified 'origVal' array.
{
    // int verbose = globalVerbose;
    int veryVerbose = globalVeryVerbose;

    for (int i = 0; i < numTest; ++i)
    {
        const char *spec = data[i].d_spec;
        const int line = data[i].d_line;
        if (veryVerbose) cout << "\tSPEC : \"" <<  spec << '"' << endl;

        bdesb_MemOutStreamBuf osb;
        bdex_TestOutStreamFormatter o(&osb);
        int res = g(&o, spec);
        LOOP2_ASSERT(line, i, 1 == res);
        bdesb_FixedMemInStreamBuf sb(const_cast<char *>(osb.data()),
                                                             osb.length());
        bdex_TestInStreamFormatter x(&sb);
        x.setQuiet(!veryVerbose);
        x.setSuppressVersionCheck(data[i].d_suppressVer);

        if (res) {
            const int expbdex_TestInStreamFormatterValidity =
                                                             data[i].d_isValid;
            const int numArr = data[i].d_numArr;

            if (!x.isSuppressVersionCheck()) {
                char version = 0;
                x.getInt8(version);
            }

            // attempt to read each array in the stream
            for (int j = 0; j < numArr; ++j) {
                const int SIZE = 100;                 // temporary array size
                ElemType arr[SIZE];                   // array of read values
                const ElemType VX = (ElemType) 0xFF;  // "uninitialized" value
                int k;
                for (k = 0; k < SIZE; ++k) arr[k] = VX;

                const int arrLen = data[i].d_arrLen[j];
                (x.*getArrayFunc)(arr, arrLen);

                const int expArrLen = data[i].d_expArrLen[j];
                // verify read values
                for (k = 0; k < expArrLen; ++k)
                    LOOP4_ASSERT(line, i, j, k, origVal[k] == arr[k]);
                // Check for overrun
                for (k = expArrLen; k < SIZE - expArrLen; ++k)
                    LOOP4_ASSERT(line, i, j, k, VX == arr[k]);
            }
            LOOP2_ASSERT(line,
                         i,
                         !!x == !!expbdex_TestInStreamFormatterValidity);
            if (expbdex_TestInStreamFormatterValidity) {
                LOOP2_ASSERT(line, i, sb.length() == 0);
                LOOP2_ASSERT(line,
                             i,
                             x.cursor() ==
                                                    x.length());
            }
        }
    }
}

//=============================================================================
//                    FUNCTION 'testGetScalar' FOR TESTING
//-----------------------------------------------------------------------------
// The function 'testGetScalar' is a generic, templatized function to test
// scalar input methods of various data types.  The function accepts an array
// of vectors having the structure defined by 'ScalarTestTable' (see above) as
// its test data.  It iterates over the vectors in the array and performs an
// independent test for each vector.  In each test, it first generates a test
// stream using the generator function 'g' with spec 'd_spec', then attempts to
// read 'd_numVals' number of scalar values from the stream with consecutive
// input method calls.  For the Nth input method call, the value read is
// verified against the value of the Nth element of array 'd_exp'.  For
// example, if N is 5 and 'getInt8' is being tested, then 'getInt8(val)' is
// called, and the resulting value of 'val' is verified against 'd_exp[5]'.  If
// a test stream contains all valid data, then the stream is verified to be
// empty and valid after all input operations.  If a test stream is
// intentionally configured with invalid data, then after the attempt to read
// the invalid data, the value of the input variable is verified to be
// unchanged, and that the stream becomes invalid.  Note that error messages
// from the stream object is displayed only in "veryVerbose" mode.
//-----------------------------------------------------------------------------

template <class ElemType, class FuncPtr>
inline
void testGetScalar(const ScalarTestTable<ElemType> *data, int numTest,
                   FuncPtr getFunc)
    // Iterate over the vectors in the specified 'data' by the specified
    // 'numTest' times.  Generate a test stream in each iteration, invoke the
    // input method pointed to by the specified 'getFunc' member pointer, and
    // then verify the result by comparing the extracted values to the values
    // specified in the test vector.
{
    // int verbose = globalVerbose;
    int veryVerbose = globalVeryVerbose;

    for (int i = 0; i < numTest; ++i)
    {
        const char *spec = data[i].d_spec;
        const int line = data[i].d_line;
        if (veryVerbose) cout << "\tSPEC : \"" <<  spec << '"' << endl;
        bdesb_MemOutStreamBuf osb;
        bdex_TestOutStreamFormatter o(&osb);
        int res = g(&o, spec);

        LOOP2_ASSERT(line, i, 1 == res);
        bdesb_FixedMemInStreamBuf sb(const_cast<char *>(osb.data()),
                                        osb.length());
        bdex_TestInStreamFormatter x(&sb);
        x.setQuiet(!veryVerbose);
        x.setSuppressVersionCheck(data[i].d_suppressVer);

        if (res) {
            const int numVals = data[i].d_numVals;
            int numRead = 0;

            if (!x.isSuppressVersionCheck()) {
                char version = 0;
                x.getInt8(version);
            }

            // attempt to read every value in stream
            for (int j = 0; j < numVals; ++j) {
                const ElemType VX = (ElemType) 0xFF;  // "uninitialized" value
                ElemType val = VX;                    // initialize to VX
                (x.*getFunc)(val);

                const ElemType expVal = data[i].d_exp[j];
                if (expVal != 0) {       // valid value read
                    LOOP3_ASSERT(line, i, j, expVal == val);
                    ++numRead;
                } else {                 // invalid value read
                    LOOP3_ASSERT(line, i, j, VX == val);
                    LOOP3_ASSERT(line, i, j, !x);
                }
            }

            if (numVals == numRead) {
                LOOP2_ASSERT(line, i, !!x);
                LOOP2_ASSERT(line, i, sb.length() == 0);
                LOOP2_ASSERT(line, i, x.cursor() == x.length());
            }
        }
    }
}

//=============================================================================
//                FUNCTION 'testGetArrayInputLimit' FOR TESTING
//-----------------------------------------------------------------------------
// The function 'testGetArrayInputLimit' is a generic, templatized function to
// test the behavior of array input methods with varying stream input limit
// values.  The function accepts as its test data an array of vectors having
// the structure defined by 'InputLimitTestTable' (see above) and performs an
// independent test for each vector.  In each test, a test input stream is
// created and initialized with the bdex_TestOutStreamFormatter::put* of the
// generator function 'g' using 'spec'.  The stream's input limit is set to
// 'd_inputLimit', and the stream's input method referred to by the 'getFunc'
// function pointer is invoked repeatedly within a loop up to 'd_numInput'
// times.  Depending on the stream's input limit, the input method may throw an
// exception and exit the 'loop'.  When the loop exits, the number of times
// that the input method was executed is verified against 'd_numSuccessInput',
// and the flag that indicates whether an exception was thrown is verified
// against 'd_willThrow'.  The input method is again executed 'd_numInput'
// times to ensure that after a non-negative input limit has been exceeded and
// an exception has been thrown, subsequent input method invocations do not
// throw unless the input limit is updated with a non-negative value.
//-----------------------------------------------------------------------------

template <class ElemType, class FuncPtr>
inline
void testGetArrayInputLimit(const InputLimitTestTable *data,
                            int                        numData,
                            const char                *spec,
                            int                        numArrayElments,
                            FuncPtr                    getFunc,
                            bdex_FieldCode::Type       dataType)
    // Iterate over the specified 'data' test vectors 'numData' times.  In each
    // iteration, create a test input stream bdex_TestInStreamFormatter
    // initialized with the bdex_TestOutStreamFormatter::put* of the generator
    // function 'g' using the specified 'spec'.  Invoke some number of times
    // (specified in the test vector) the array input method referred to by the
    // specified 'getFunc' member function pointer to input an array containing
    // the specified 'numArrayElments'.  Verify that the number of times the
    // input method was invoked is equal to the expected value specified in the
    // test vector, and that an exception was thrown and caught when expected.
    // If an exception was thrown, verified that the exception
    // bdex_TestInStreamFormatter contains the specified 'dataType'.
{
#ifdef BDE_BUILD_TARGET_EXC
    // int verbose = globalVerbose;
    int veryVerbose = globalVeryVerbose;

    const int SIZE = 100;
    ElemType array[SIZE];

    bdesb_MemOutStreamBuf osb;
    bdex_TestOutStreamFormatter o(&osb);
    int res = g(&o, spec);    ASSERT(res);

    for (int novers = 0; novers < 2; ++novers) {
        if (veryVerbose) cout << "[ "
                              << (novers ? "With bdex_TestOutStreamFormatter"
                                         : "With")
                              << " version check ]" << endl;

        for (int i = 0; i < numData; ++i) {
            const int LINE     = data[i].d_line;
            const int LIMIT    = data[i].d_inputLimit;
            const int NUM_IN   = data[i].d_numInput;
            const int THROWN   = data[i].d_willThrow;
            const int NUM_SUCC = data[i].d_numSuccessInput;
            LOOP2_ASSERT(LINE, i, NUM_IN <= SIZE);

            int offset = novers ? VERSION_LEN : 0;

            bdesb_FixedMemInStreamBuf sb(
                                const_cast<char *>(osb.data() + offset),
                                osb.length() - offset);
            bdex_TestInStreamFormatter x(&sb);
            x.setSuppressVersionCheck(novers);
            if (!novers) { char ver; x.getInt8(ver); }
            x.setInputLimit(LIMIT);

            int numInput;
            int thrown = 0;
            try {
                for (numInput = 0; numInput < NUM_IN; ++numInput) {
                    (x.*getFunc)(array, numArrayElments);
                }
            }
            catch (bdex_TestInStreamException& e) {
                thrown = 1;
                if (veryVerbose) cout << "\t*** Caught Exception : type = "
                                      << e.dataType() << " ***" << endl;
                LOOP3_ASSERT(LINE, i, numInput, dataType == e.dataType());
            }
            if (veryVerbose) {
                cout << '\t';
                P_(numInput);
                P(x.inputLimit());
            }
            LOOP2_ASSERT(LINE, i, NUM_SUCC == numInput);
            LOOP2_ASSERT(LINE, i,   THROWN == thrown);
            LOOP2_ASSERT(LINE, i, x);

            // ensure that once input limit is exceeded and exception has
            // been thrown, then no exception will be thrown again
            if (x.inputLimit() < 0) {
                x.seek(0);
                if (!novers) { char ver; x.getInt8(ver); }
                try {
                    for (numInput = 0; numInput < NUM_IN; ++numInput) {
                        (x.*getFunc)(array, numArrayElments);
                    }
                }
                catch (bdex_TestInStreamException& e) {
                    LOOP3_ASSERT(LINE, i, numInput,
                                 0 && "\t*** Unexpected exception ***\n");
                    if (veryVerbose) {
                        cout << "\ttype = " << e.dataType() << endl;
                    }
                }
            }
        }
    }

#endif
}

//=============================================================================
//               FUNCTION 'testGetScalarInputLimit' FOR TESTING
//-----------------------------------------------------------------------------
// The function 'testGetScalarInputLimit' is a generic, templatized function to
// test the behavior of scalar input methods with varying stream input limit
// values.  The function accepts as its test data an array of vectors having
// the structure defined by 'InputLimitTestTable' (see above) and performs an
// independent test for each vector.  In each test, a test input stream is
// created and initialized with the bdex_TestOutStreamFormatter::put* of the
// generator function 'g' using 'spec'.  The stream's input limit is set to
// 'd_inputLimit', and the stream's input method referred to by the 'getFunc'
// function pointer is invoked repeatedly within a loop up to 'd_numInput'
// times.  Depending on the stream's input limit, the input method may throw an
// exception and exit the 'loop'.  When the loop exits, the number of times
// that the input method was executed is verified against 'd_numSuccessInput',
// and the flag that indicates whether an exception was thrown is verified
// against 'd_willThrow'.  The input method is again executed 'd_numInput'
// times to ensure that after a non-negative input limit has been exceeded and
// an exception has been thrown, subsequent input method invocations do not
// throw unless the input limit is updated with a non-negative value.
//-----------------------------------------------------------------------------

template <class ElemType, class FuncPtr>
inline
void testGetScalarInputLimit(const InputLimitTestTable *data,
                             int                        numData,
                             const char                *spec,
                             FuncPtr                    getFunc,
                             bdex_FieldCode::Type       dataType)
    // Iterate over the specified 'data' test vectors 'numData' times.  In each
    // iteration, create a test input stream bdex_TestInStreamFormatter
    // initialized with the bdex_TestOutStreamFormatter::put* of the generator
    // function 'g' using the specified 'spec'.  Invoke some number of times
    // (specified in the test vector) the scalar input method referred to by
    // the specified 'getFunc' member function pointer.  Verify that the
    // number of times the input method was invoked is equal to the expected
    // value specified in the test vector, and that an exception was thrown
    // and caught when expected.  If an exception was thrown, verified that
    // the exception bdex_TestInStreamFormatter contains the specified
    // 'dataType'.
{
#ifdef BDE_BUILD_TARGET_EXC
    // int verbose = globalVerbose;
    int veryVerbose = globalVeryVerbose;

    ElemType value;

    bdesb_MemOutStreamBuf osb;
    bdex_TestOutStreamFormatter o(&osb);
    int res = g(&o, spec);    ASSERT(res);

    for (int novers = 0; novers < 2; ++novers) {
        if (veryVerbose) cout << "[ "
                              << (novers ? "With bdex_TestOutStreamFormatter"
                                         : "With")
                              << " version check ]" << endl;

        for (int i = 0; i < numData; ++i) {
            const int LINE    = data[i].d_line;
            const int LIMIT   = data[i].d_inputLimit;
            const int NUM_IN  = data[i].d_numInput;
            const int THROWN   = data[i].d_willThrow;
            const int NUM_SUCC = data[i].d_numSuccessInput;

            int offset = novers ? VERSION_LEN : 0;
            bdesb_FixedMemInStreamBuf
                                    sb(const_cast<char *>(osb.data() + offset),
                                       osb.length() - offset);
            bdex_TestInStreamFormatter x(&sb);
            x.setSuppressVersionCheck(novers);
            if (!novers) { char ver; x.getInt8(ver); }
            x.setInputLimit(LIMIT);

            int numInput;
            int thrown = 0;
            try {
                for (numInput = 0; numInput < NUM_IN; ++numInput) {
                    (x.*getFunc)(value);
                }
            }
            catch (bdex_TestInStreamException& e) {
                thrown = 1;
                if (veryVerbose) cout << "\t*** Caught Exception : type = "
                                      << e.dataType() << " ***" << endl;
                LOOP3_ASSERT(LINE, i, numInput, dataType == e.dataType());
            }
            if (veryVerbose) {
                cout << '\t';
                P_(numInput);
                P(x.inputLimit());
            }
            LOOP2_ASSERT(LINE, i, NUM_SUCC == numInput);
            LOOP2_ASSERT(LINE, i,   THROWN == thrown);
            LOOP2_ASSERT(LINE, i, x);

            // ensure that once input limit is exceeded and exception has
            // been thrown, then no exception will be thrown again
            if (x.inputLimit() < 0) {
                x.seek(0);
                if (!novers) { char ver; x.getInt8(ver); }
                try {
                    for (numInput = 0; numInput < NUM_IN; ++numInput) {
                        (x.*getFunc)(value);
                    }
                }
                catch (bdex_TestInStreamException& e) {
                    LOOP3_ASSERT(LINE, i, numInput,
                                 0 && "\t*** Unexpected exception ***\n");
                    if (veryVerbose) {
                        cout << "\ttype = " << e.dataType() << endl;
                    }
                }
            }
        }
    }

#endif
}

//=============================================================================
//                     'my_DoubleArray' FOR USAGE TESTING
//-----------------------------------------------------------------------------
// my_DoubleArray.h

class my_DoubleArray {
    double *d_array_p;  // dynamically allocated array (d_size elements)
    int     d_size;     // physical capacity of this array (in elements)
    int     d_length;   // logical length of this array (in elements)

  private:
    void increaseSize();

  public:
    // CLASS METHODS
    static int maxSupportedBdexVersion() { return 1; }

    // CREATORS
    my_DoubleArray();
    my_DoubleArray(const my_DoubleArray& original);
    ~my_DoubleArray();

    // MANIPULATORS
    my_DoubleArray& operator=(const my_DoubleArray& rhs);
    void append(double item);
    void setLength(int newLength);
    void removeAll()                             { d_length = 0;            }
    template <class STREAM>
    STREAM& bdexStreamIn(STREAM& stream, int version);

    // ACCESSORS
    int length() const                           { return d_length;         }
    const double *data() const                   { return d_array_p;        }
    const double& operator[](int index) const    { return d_array_p[index]; }
    template <class STREAM>
    STREAM& bdexStreamOut(STREAM& stream, int version) const;
};

bool operator==(const my_DoubleArray& lhs, const my_DoubleArray& rhs);

ostream& operator<<(ostream& stream, const my_DoubleArray& array);

inline
void my_DoubleArray::append(double item)
{
    if (d_length >= d_size) {
        increaseSize();
    }
    d_array_p[d_length++] = item;
}

inline
bool operator!=(const my_DoubleArray& lhs, const my_DoubleArray& rhs)
{
    return !(lhs == rhs);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// my_DoubleArray.cpp

enum {
    INITIAL_SIZE = 1,     // initial physical capacity (number of elements)
    GROW_FACTOR = 2       // multiplicative factor by which to grow 'd_size'
};

                        // --------------
                        // STATIC METHODS
                        // --------------

inline
static int nextSize(int size)
    // Return the specified 'size' multiplied by the constant 'GROW_FACTOR'.
{
    return size * GROW_FACTOR;
}

inline
static int calculateSufficientSize(int minLength, int size)
    // Geometrically grow the specified current 'size' value while it is less
    // than the specified 'minLength' value.  Return the new size value.  The
    // behavior is undefined unless 1 <= size and 0 <= minLength.  Note that
    // if minLength <= size then 'size' is returned.
{
    ASSERT(1 <= size);
    ASSERT(0 <= minLength);

    while (size < minLength) {
        size = nextSize(size);
    };

    ASSERT(size >= minLength);
    return size;
}

inline static
void reallocate(double **array, int *size, int newSize, int length)
    // Reallocate memory in the specified 'array' and update the specified size
    // to the specified 'newSize'.  The specified 'length' number of leading
    // elements are preserved.  If the allocation should throw an exception,
    // this function has no effect.  The behavior is undefined unless
    // 1 <= newSize, 0 <= length, and newSize <= length.
{
    ASSERT(array);
    ASSERT(*array);             // this is not 'allocate'
    ASSERT(size);
    ASSERT(1 <= newSize);
    ASSERT(0 <= length);
    ASSERT(length <= *size);    // sanity check
    ASSERT(length <= newSize);  // ensure class invariant

    double *tmp = *array;

    *array = (double *) operator new(newSize * sizeof **array);
    // COMMIT
    memcpy(*array, tmp, length * sizeof **array);
    *size = newSize;
    operator delete(tmp);
}

inline
static void initializeWithDefaultValue(double *array, int length)
    // Initialize the specified 'length' leading elements of the specified
    // array with the default value.  The behavior is undefined unless
    // 0 <= length.
{
    ASSERT(array);
    ASSERT(0 <= length);
    memset(array, 0, length * sizeof *array);
}

                        // ---------------
                        // PRIVATE METHODS
                        // ---------------

void my_DoubleArray::increaseSize()
{
    reallocate(&d_array_p, &d_size, nextSize(d_size), d_length);
}

                        // --------
                        // CREATORS
                        // --------

my_DoubleArray::my_DoubleArray()
: d_size(INITIAL_SIZE)
, d_length(0)
{
    d_array_p = (double *) operator new(d_size * sizeof *d_array_p);
}

my_DoubleArray::my_DoubleArray(const my_DoubleArray& original)
: d_length(original.d_length)
{
    d_size = calculateSufficientSize(d_length, INITIAL_SIZE);
    d_array_p = (double *) operator new(d_size * sizeof *d_array_p);
    memcpy(d_array_p, original.d_array_p, d_length * sizeof *d_array_p);
}

my_DoubleArray::~my_DoubleArray()
{
    ASSERT(d_array_p);
    ASSERT(1 <= d_size);
    ASSERT(0 <= d_length);
    ASSERT(d_length <= d_size);

    operator delete(d_array_p);
}

                        // ------------
                        // MANIPULATORS
                        // ------------

my_DoubleArray& my_DoubleArray::operator=(const my_DoubleArray& rhs)
{
    if (this != &rhs) {
        if (d_size < rhs.d_length) {
            double *tmp = d_array_p;
            int newSize = calculateSufficientSize(rhs.d_length, d_size);
            d_array_p = (double *) operator new(newSize * sizeof *d_array_p);
            // COMMIT
            d_size = newSize;
            operator delete(tmp);
        }
        ASSERT(d_size >= rhs.d_length);
        d_length = rhs.d_length;
        memcpy(d_array_p, rhs.d_array_p, d_length * sizeof *d_array_p);
    }
    return *this;
}

void my_DoubleArray::setLength(int newLength)
{
    ASSERT(0 <= newLength);

    if (newLength > d_length) {
        if (newLength > d_size) {
            int newSize = calculateSufficientSize(newLength, d_size);
            reallocate(&d_array_p, &d_size, newSize, d_length);
        }
        initializeWithDefaultValue(d_array_p + d_length, newLength - d_length);
    }
    d_length = newLength;
}

template <class STREAM>
STREAM& my_DoubleArray::bdexStreamIn(STREAM& stream, int version)
{
    if (stream) {
        switch (version) {  // Switch on the schema version (starting with 1).
          case 1: {
            int newLength;
            stream.getLength(newLength);
            if (!stream) {
                return stream;                                  // RETURN
            }
            if (newLength < 0) {
                stream.invalidate();
                return stream;                                  // RETURN
            }

            if (newLength > d_size) {
                int newSize = calculateSufficientSize(newLength, d_size);
                reallocate(&d_array_p, &d_size, newSize, d_length);
            }
            ASSERT(newLength <= d_size);

            // No need to initialize any new elements (newLength > d_length).

            d_length = newLength;

            stream.getArrayFloat64(d_array_p, d_length);
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;                                              // RETURN
}

                        // ---------
                        // ACCESSORS
                        // ---------

template <class STREAM>
STREAM& my_DoubleArray::bdexStreamOut(STREAM& stream, int version) const
{
    if (stream) {
        switch (version) {  // Switch on the schema version (starting with 1).
          case 1: {
            stream.putLength(d_length);
            stream.putArrayFloat64(d_array_p, d_length);
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;
}

                        // --------------
                        // FREE OPERATORS
                        // --------------

bool operator==(const my_DoubleArray& lhs, const my_DoubleArray& rhs)
{
    const int len = lhs.length();
    return len == rhs.length()
        && 0 == memcmp(lhs.data(), rhs.data(), len * sizeof *lhs.data());
}

ostream& operator<<(ostream& stream, const my_DoubleArray& rhs)
{
    stream << '[';
    for (int i = 0; i < rhs.length(); ++i) {
        stream << ' ' << rhs[i];
    }
    return stream << " ]" << flush;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// my_DoubleArray.t.cpp

typedef double Element;

const Element VALUES[] = { 1.5, 2.5, 3.5, 4.75, -5.25 }; // avoid DEFAULT_VALUE

const Element &VV0 = VALUES[0], &VVA = VV0,  // VV0, VV1, ... are used in
              &VV1 = VALUES[1], &VVB = VV1,  // conjunction with VALUES array.
              &VV2 = VALUES[2], &VVC = VV2,
              &VV3 = VALUES[3], &VVD = VV3,  // VVA, VVB, ... are used in
              &VV4 = VALUES[4], &VVE = VV4;  // conjunction with 'g' and 'gg'.

const int NUM_VALUES = sizeof VALUES / sizeof *VALUES;

int hhh(my_DoubleArray *object, const char *spec, int verboseFlag = 1)
    // Configure the specified 'bdex_TestInStreamFormatter' according to the
    // specified 'spec', using only the primary manipulator function 'append'
    // and white-box manipulator 'removeAll'.  Optionally specify a zero
    // 'verboseFlag' to suppresses 'spec' syntax error messages.  Return the
    // index of the first invalid character, and a negative value otherwise.
    // Note that this function is used to implement 'hh' as well as allow for
    // verification of syntax error detection.
{
    enum { SUCCESS = -1 };
    for (int i = 0; spec[i]; ++i) {
        if ('A' <= spec[i] && spec[i] <= 'E') {
            object->append(VALUES[spec[i] - 'A']);
        }
        else if ('~' == spec[i]) {
            object->setLength(0);
        }
        else {
            if (verboseFlag) {
                cout << "Error, bad character ('" << spec[i] << "') in spec \""
                     << spec << "\" at position " << i << '.' << endl;
            }
            return i;  // Discontinue processing this spec.
        }
   }
   return SUCCESS;
}

my_DoubleArray& hh(my_DoubleArray *object, const char *spec)
    // Return, by reference, the specified object with its value adjusted
    // according to the specified 'spec'.
{
    ASSERT(hhh(object, spec) < 0);
    return *object;
}

my_DoubleArray h(const char *spec)
    // Return, by value, a new object corresponding to the specified 'spec'.
{
    my_DoubleArray object;
    return hh(&object, spec);
}

void stretch(my_DoubleArray *object,
             int             size)
   // Using only primary manipulators, extend the length of the specified
   // 'object' by the specified size.  The resulting value is not specified.
   // The behavior is undefined unless 0 <= size.
{
    ASSERT(object);
    ASSERT(0 <= size);
    for (int i = 0; i < size; ++i) {
        object->append(VV0);
    }
    ASSERT(object->length() >= size);
}

void stretchRemoveAll(my_DoubleArray *object,
                      int             size)
   // Using only primary manipulators, extend the capacity of the specified
   // 'object' to (at least) the specified size; then remove all elements
   // leaving 'object' empty.  The behavior is undefined unless 0 <= size.
{
    ASSERT(object);
    ASSERT(0 <= size);
    stretch(object, size);
    object->removeAll();
    ASSERT(0 == object->length());
}

//=============================================================================
//                                MAIN PROGRAM
//-----------------------------------------------------------------------------

int main(int argc, char *argv[])
{
    int test = argc > 1 ? atoi(argv[1]) : 0;
    int verbose = argc > 2;
    int veryVerbose = globalVeryVerbose = argc > 3;
    int veryVeryVerbose = argc > 4;
    // int veryVeryVerbose = globalVeryVeryVerbose = argc > 4;

    cout << "TEST " << __FILE__ << " CASE " << test << endl;

    switch (test) { case 0:
      case 30: {
        // --------------------------------------------------------------------
        // TESTING USAGE EXAMPLE
        //   Perform the tests of the hypothetical 'my_DoubleArray::streamout'
        //   and 'my_DoubleArray::streamIn' functions according to the
        //   following test plan.  Note that the 'bdex_TestInStreamFormatter'
        //   and 'bdex_TestOutStreamFormatter' components are used to test the
        //   'my_DoubleArray' functionality.  Also note that the macros
        //   'BEGIN_BSLMA_EXCEPTION_TEST' and 'END_BSLMA_EXCEPTION_TEST' are
        //   defined to be empty here for simplicity.
        // --------------------------------------------------------------------
        // TESTING STREAMING FUNCTIONALITY:
        //   1. The (free) streaming operators '<<' and '>>' are implemented
        //      using the respective member functions 'streamOut' and
        //      'streamIn'.
        //   2. Streaming must be neutral to exceptions thrown as a result of
        //      either allocating memory or streaming in values.
        //   3. Ensure that streaming works under the following conditions:
        //       VALID - may contain any sequence of valid values.
        //       EMPTY - valid, but contains no data.
        //       INVALID - may or may not be empty.
        //       INCOMPLETE - the stream is truncated, but otherwise valid.
        //       CORRUPTED - the data contains explicitly inconsistent fields.
        //
        //   Plan:
        //     First perform a trivial direct (breathing) test of the
        //     'outStream' and 'inStream' methods (to address concern 1).  Note
        //     that the rest of the testing will use the stream operators.
        //
        //     Next, specify a set S of unique object values with substantial
        //     and varied differences, ordered by increasing length.  For each
        //     value in S, construct an object x along with a sequence of
        //     similarly constructed duplicates x1, x2, ..., xN.  Attempt to
        //     affect every aspect of white-box state by altering each xi in
        //     a unique way.  Let the union of all such objects be the set T.
        //
        //   VALID STREAMS (and exceptions)
        //      Using all combinations of (u, v) in T X T, stream out the value
        //      of u into a buffer and stream it back into (an independent
        //      instance of) v, and assert that u == v.
        //
        //   EMPTY AND INVALID STREAMS
        //     For each x in T, attempt to stream into (a temporary copy of) x
        //     from an empty and then invalid stream.  Verify after each try
        //     that the object is unchanged and that the stream is invalid.
        //
        //   INCOMPLETE (BUT OTHERWISE VALID) DATA
        //     Write 3 distinct objects to an output stream buffer of total
        //     length N.  For each partial stream length from 0 to N - 1,
        //     construct a truncated input stream and attempt to read into
        //     objects initialized with distinct values.  Verify values of
        //     objects that are either successfully modified or left entirely
        //     unmodified,  and that the stream became invalid immediately
        //     after the first incomplete read.  Finally ensure that each
        //     object streamed into is in some valid state by creating a copy
        //     and then assigning a known value to that copy; allow the
        //     original instance to leave scope without further modification,
        //     so that the destructor asserts internal object invariants
        //     appropriately.
        //
        //   CORRUPTED DATA
        //     We will assume that the incomplete test fail every field,
        //     including a char (multi-byte representation) hence we need
        //     only to produce values that are inconsistent with a valid
        //     value and verify that they are detected.  Use the underlying
        //     stream package to simulate an instance of a typical valid
        //     (control) stream and verify that it can be streamed in
        //     successfully.  Then for each data field in the stream (beginning
        //     with the version number), provide one or more similar tests with
        //     that data field corrupted.  After each test, verify that the
        //     object is in some valid state after streaming, and that the
        //     input stream has gone invalid.
        //
        // Testing:
        //   bdex_TestInStreamFormatter& bdexStreamIn(stream, version);
        //   bdex_TestOutStreamFormatter& bdexStreamOut(stream, version) const;
        // --------------------------------------------------------------------

        if (verbose) cout << endl
                          << "USAGE EXAMPLE" << endl
                          << "=============" << endl;

        const int VERSION = my_DoubleArray::maxSupportedBdexVersion();

        if (verbose) cout << "\nDirect initial trial of 'streamOut' and"
                             " (valid) 'streamIn' functionality." << endl;
        {
            const my_DoubleArray X(h("ABC"));

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter out(&osb);
            X.bdexStreamOut(out, VERSION);

            const char *const OD  = osb.data();
            const int         LOD = osb.length();

            bdesb_FixedMemInStreamBuf sb(const_cast<char *>(OD), LOD);
            bdex_TestInStreamFormatter in(&sb);  ASSERT(in);
            ASSERT(sb.length() > 0);

            my_DoubleArray t(h("DE"));

            if (veryVerbose) { cout << "\tValue being overwritten: "; P(t); }
            ASSERT(X != t);
            t.bdexStreamIn(in, VERSION); ASSERT(in);  ASSERT(0 == sb.length());

            if (veryVerbose) { cout << "\t  Value after overwrite: "; P(t); }
            ASSERT(X == t);
        }
        if (verbose) cout <<
            "\nTesting bdex stream functions." << endl;

        if (verbose) cout << "\tOn valid, non-empty stream data." << endl;
        {
            static const char *SPECS[] = { // len: 0 - 5,
                "",       "A",      "BC",     "CDE",    "DEAB",   "EABCD",
            0}; // Null string required as last element.

            static const int EXTEND[] = {
                0, 1, 2, 3, 4, 5,
            };
            const int NUM_EXTEND = sizeof EXTEND / sizeof *EXTEND;

            int uOldLen = -1;
            for (int ui = 0; SPECS[ui]; ++ui) {
                const char *const U_SPEC = SPECS[ui];
                const int uLen = strlen(U_SPEC);

                if (verbose) {
                    cout << "\t\tFor source objects of length "
                                                        << uLen << ":\t";
                    P(U_SPEC);
                }

                LOOP_ASSERT(U_SPEC, uOldLen < uLen);  // strictly increasing
                uOldLen = uLen;

                const my_DoubleArray UU = h(U_SPEC);             // control
                LOOP_ASSERT(ui, uLen == UU.length());   // same lengths

                for (int uj = 0; uj < NUM_EXTEND; ++uj) {
                    const int U_N = EXTEND[uj];

                    my_DoubleArray mU;              stretchRemoveAll(&mU, U_N);
                    const my_DoubleArray& U = mU;   hh(&mU, U_SPEC);

                    bdesb_MemOutStreamBuf osb;
                    bdex_TestOutStreamFormatter out(&osb);

                    // testing stream-out operator here
                    bdex_OutStreamFunctions::streamOut(out, U, VERSION);

                    const char *const OD  = osb.data();
                    const int         LOD = osb.length();

                    // Must reset stream for each iteration of inner loop.
                    bdesb_FixedMemInStreamBuf sb(const_cast<char *>(OD), LOD);
                    bdex_TestInStreamFormatter testInStream(&sb);
                    testInStream.setSuppressVersionCheck(1);
                    LOOP2_ASSERT(U_SPEC, U_N, testInStream);
                    LOOP2_ASSERT(U_SPEC, U_N, sb.length() > 0);

                    for (int vi = 0; SPECS[vi]; ++vi) {
                        const char *const V_SPEC = SPECS[vi];
                        const int vLen = strlen(V_SPEC);

                        const my_DoubleArray VV = h(V_SPEC);      // control

                        if (0 == uj && veryVerbose || veryVeryVerbose) {
                            cout << "\t\t\tFor destination objects of length "
                                                        << vLen << ":\t";
                            P(V_SPEC);
                        }

                        const int Z = ui == vi; // flag indicating same values

                        for (int vj = 0; vj < NUM_EXTEND; ++vj) {
//                          BEGIN_BSLMA_EXCEPTION_TEST {
                          BEGIN_BDEX_EXCEPTION_TEST {
                            testInStream.reset();
                            const int V_N = EXTEND[vj];
            //--------------^
            LOOP4_ASSERT(U_SPEC, U_N, V_SPEC, V_N, testInStream);
            LOOP4_ASSERT(U_SPEC, U_N, V_SPEC, V_N, sb.length() > 0);
            //--------------v
                            my_DoubleArray mV;
                            stretchRemoveAll(&mV, V_N);
                            const my_DoubleArray& V = mV;  hh(&mV, V_SPEC);

                            static int firstFew = 2 * NUM_EXTEND * NUM_EXTEND;
                            if (veryVeryVerbose||veryVerbose && firstFew > 0) {
                                cout << "\t |"; P_(U_N); P_(V_N); P_(U); P(V);
                                --firstFew;
                            }

                            LOOP4_ASSERT(U_SPEC, U_N, V_SPEC, V_N, UU == U);
                            LOOP4_ASSERT(U_SPEC, U_N, V_SPEC, V_N, VV == V);
                            LOOP4_ASSERT(U_SPEC, U_N, V_SPEC, V_N, Z==(U==V));

                            // test stream-in operator here
                            bdex_InStreamFunctions::streamIn(testInStream,
                                                             mV,
                                                             VERSION);

                            LOOP4_ASSERT(U_SPEC, U_N, V_SPEC, V_N, UU == U);
                            LOOP4_ASSERT(U_SPEC, U_N, V_SPEC, V_N, UU == V);
                            LOOP4_ASSERT(U_SPEC, U_N, V_SPEC, V_N,  U == V);

                          } END_BDEX_EXCEPTION_TEST
//                          } END_BSLMA_EXCEPTION_TEST
                        }
                    }
                }
            }
        }
        if (verbose) cout << "\tOn empty and invalid streams." << endl;
        {
            static const char *SPECS[] = { // len: 0 - 5, 7, 8, 9, 15, 16, 17
                "",      "A",      "BC",     "CDE",    "DEAB",   "EABCD",
                "ABCDEAB",         "ABCDEABC",         "ABCDEABCD",
                "ABCDEABCDEABCDE", "ABCDEABCDEABCDEA", "ABCDEABCDEABCDEAB",
            0}; // Null string required as last element.

            static const int EXTEND[] = {
                0, 1, 2, 3, 4, 5, 7, 8, 9, 15, 16, 17
            };
            const int NUM_EXTEND = sizeof EXTEND / sizeof *EXTEND;

            bdesb_FixedMemInStreamBuf sb("", 0);
            bdex_TestInStreamFormatter testInStream(&sb);
            testInStream.setSuppressVersionCheck(1);

            int oldLen = -1;
            for (int ti = 0; SPECS[ti]; ++ti) {
                const char *const SPEC = SPECS[ti];
                const int curLen = strlen(SPEC);

                if (verbose) cout << "\t\tFor objects of length "
                                                    << curLen << '.' << endl;
                LOOP_ASSERT(SPEC, oldLen < curLen); // strictly increasing
                oldLen = curLen;

                if (veryVerbose) { cout << "\t\t\t"; P(SPEC); }

                // Create control object X.

                my_DoubleArray mX;    hh(&mX, SPEC);
                const my_DoubleArray& X = mX;
                LOOP_ASSERT(ti, curLen == X.length());  // same lengths

                for (int ei = 0; ei < NUM_EXTEND; ++ei) {
//                  BEGIN_BSLMA_EXCEPTION_TEST {
                  BEGIN_BDEX_EXCEPTION_TEST {
                    testInStream.reset();

                    const int N = EXTEND[ei];

                    if (veryVerbose) { cout << "\t\t\t\t"; P(N); }

                    my_DoubleArray t;           hh(&t, SPEC);
                    stretchRemoveAll(&t, N);    hh(&t, SPEC);

                  // Ensure that reading from an empty or invalid input stream
                  // leaves the stream invalid and the target object unchanged.

                                    LOOP2_ASSERT(ti, ei, testInStream);
                                    LOOP2_ASSERT(ti, ei, X == t);

                    bdex_InStreamFunctions::streamIn(testInStream, t, VERSION);
                                    LOOP2_ASSERT(ti, ei, !testInStream);
                                    LOOP2_ASSERT(ti, ei, X == t);

                    bdex_InStreamFunctions::streamIn(testInStream, t, VERSION);
                                    LOOP2_ASSERT(ti, ei, !testInStream);
                                    LOOP2_ASSERT(ti, ei, X == t);

                  } END_BDEX_EXCEPTION_TEST
//                  } END_BSLMA_EXCEPTION_TEST
                }
            }
        }
        if (verbose) cout <<
            "\tOn incomplete (but otherwise valid) data." << endl;
        {
            const my_DoubleArray X1 = h("CDCD"), Y1 = h("BB"), Z1 = h("ABCDE");
            const my_DoubleArray X2 = h("ADE"),  Y2 = h("CABDE"), Z2 = h("B");
            const my_DoubleArray X3 = h("DEEDDE"), Y3 = h("C"), Z3 = h("DBED");

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter out(&osb);
            bdex_OutStreamFunctions::streamOut(out, Y1, VERSION);
            const int LOD1 = osb.length();
            bdex_OutStreamFunctions::streamOut(out, Y2, VERSION);
            const int LOD2 = osb.length();
            bdex_OutStreamFunctions::streamOut(out, Y3, VERSION);
            const int LOD  = osb.length();
            const char *const OD = osb.data();

            for (int i = 0; i < LOD; ++i) {
                bdesb_FixedMemInStreamBuf sb(const_cast<char *>(OD), i);
                bdex_TestInStreamFormatter testInStream(&sb);
                bdex_TestInStreamFormatter& in = testInStream;
                in.setSuppressVersionCheck(1);
                LOOP_ASSERT(i, in);  LOOP_ASSERT(i, !i == (sb.length() == 0));

                if (veryVerbose) { cout << "\t\t"; P(i); }

//                BEGIN_BSLMA_EXCEPTION_TEST {
                BEGIN_BDEX_EXCEPTION_TEST { in.reset();

                LOOP_ASSERT(i, in);  LOOP_ASSERT(i, !i == (sb.length() == 0));

                my_DoubleArray t1(X1), t2(X2), t3(X3);

                if (i < LOD1) {
                    bdex_InStreamFunctions::streamIn(in, t1, VERSION);
                    LOOP_ASSERT(i, !in);
                                        if (0 == i) LOOP_ASSERT(i, X1 == t1);
                    bdex_InStreamFunctions::streamIn(in, t2, VERSION);
                    LOOP_ASSERT(i, !in);  LOOP_ASSERT(i, X2 == t2);
                    bdex_InStreamFunctions::streamIn(in, t3, VERSION);
                    LOOP_ASSERT(i, !in);  LOOP_ASSERT(i, X3 == t3);
                }
                else if (i < LOD2) {
                    bdex_InStreamFunctions::streamIn(in, t1, VERSION);
                    LOOP_ASSERT(i,  in);  LOOP_ASSERT(i, Y1 == t1);
                    bdex_InStreamFunctions::streamIn(in, t2, VERSION);
                    LOOP_ASSERT(i, !in);
                                     if (LOD1 == i) LOOP_ASSERT(i, X2 == t2);
                    bdex_InStreamFunctions::streamIn(in, t3, VERSION);
                    LOOP_ASSERT(i, !in);  LOOP_ASSERT(i, X3 == t3);
                }
                else {
                    bdex_InStreamFunctions::streamIn(in, t1, VERSION);
                    LOOP_ASSERT(i,  in);  LOOP_ASSERT(i, Y1 == t1);
                    bdex_InStreamFunctions::streamIn(in, t2, VERSION);
                    LOOP_ASSERT(i,  in);  LOOP_ASSERT(i, Y2 == t2);
                    bdex_InStreamFunctions::streamIn(in, t3, VERSION);
                    LOOP_ASSERT(i, !in);
                                     if (LOD2 == i) LOOP_ASSERT(i, X3 == t3);
                }

                my_DoubleArray w1(t1), w2(t2), w3(t3);
                                              // make copies to be sure we can

                                LOOP_ASSERT(i, Z1 != w1);
                w1 = Z1;        LOOP_ASSERT(i, Z1 == w1);

                                LOOP_ASSERT(i, Z2 != w2);
                w2 = Z2;        LOOP_ASSERT(i, Z2 == w2);

                                LOOP_ASSERT(i, Z3 != w3);
                w3 = Z3;        LOOP_ASSERT(i, Z3 == w3);

                } END_BDEX_EXCEPTION_TEST
//                } END_BSLMA_EXCEPTION_TEST
            }
        }
        if (verbose) cout << "\tOn corrupted data." << endl;

        const my_DoubleArray W = h("");            // default value
        const my_DoubleArray X = h("ABCDE");       // original value
        const my_DoubleArray Y = h("DCB");         // new value

        enum { A_LEN = 3 };
        Element a[A_LEN];  a[0] = VVD;  a[1] = VVC;  a[2] = VVB;

        if (verbose) cout << "\t\tGood stream (for control)." << endl;
        {
            const int length   = 3;

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter out(&osb);
            out.putLength(length);
            out.putArrayFloat64(a, A_LEN);
            const char *const OD  = osb.data();
            const int         LOD = osb.length();

            my_DoubleArray t(X);   ASSERT(W != t);
            ASSERT(X == t);    ASSERT(Y != t);
            bdesb_FixedMemInStreamBuf sb(const_cast<char *>(OD), LOD);
            bdex_TestInStreamFormatter in(&sb); ASSERT(in);
            in.setSuppressVersionCheck(1);
            bdex_InStreamFunctions::streamIn(in, t, VERSION);
            ASSERT(in);
            ASSERT(W != t);    ASSERT(X != t);      ASSERT(Y == t);
        }

        if (verbose) cout << "\t\tBad version." << endl;
        {
            const char version = 0; // too small
            const int length   = 3;

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter out(&osb);
            out.putLength(length);
            out.putArrayFloat64(a, A_LEN);
            const char *const OD  = osb.data();
            const int         LOD = osb.length();

            my_DoubleArray t(X);   ASSERT(W != t);
                                   ASSERT(X == t);    ASSERT(Y != t);
            bdesb_FixedMemInStreamBuf sb(const_cast<char *>(OD), LOD);
            bdex_TestInStreamFormatter in(&sb);
            in.setSuppressVersionCheck(1); ASSERT(in);
            bdex_InStreamFunctions::streamIn(in, t, version); ASSERT(!in);
                        ASSERT(W != t);    ASSERT(X == t);      ASSERT(Y != t);
        }
        {
            const char version = 2; // too large
            const int length   = 3;

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter out(&osb);
            out.putLength(length);
            out.putArrayFloat64(a, A_LEN);
            const char *const OD  = osb.data();
            const int         LOD = osb.length();

            my_DoubleArray t(X);   ASSERT(W != t);
                                   ASSERT(X == t);    ASSERT(Y != t);
            bdesb_FixedMemInStreamBuf sb(const_cast<char *>(OD), LOD);
            bdex_TestInStreamFormatter in(&sb);
            in.setSuppressVersionCheck(1); ASSERT(in);
            bdex_InStreamFunctions::streamIn(in, t, version); ASSERT(!in);
                        ASSERT(W != t);    ASSERT(X == t);      ASSERT(Y != t);
        }
      } break;
      case 29: {
        // --------------------------------------------------------------------
        // GET LENGTH AND VERSION TEST:
        //
        // Testing:
        //   getLength(int &variable);
        //   getVersion(int &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET LENGTH AND VERSION TEST" << endl
                                  << "===========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getLength'." << endl;
        {
            for (int len = 0; len <= 256; ++len) {
                bdesb_MemOutStreamBuf osb;
                bdex_TestOutStreamFormatter out(&osb);
                out.putVersion(1);
                out.putLength(len);
                bdesb_FixedMemInStreamBuf sb(const_cast<char *>(osb.data()),
                                             osb.length());
                bdex_TestInStreamFormatter in(&sb);

                int tmp;
                in.getVersion(tmp);
                in.getLength(tmp);
                LOOP_ASSERT(len, len == tmp);
            }
        }

        if (verbose) cout << "\nTesting 'getVersion'." << endl;
        {
            typedef int ElemType;
            typedef bdex_TestInStreamFormatter&
                       (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getVersion;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream without version
    { L_, "C01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "C0123",          1,     4,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "C4567",          1,     4,      { VC[4], VC[5], VC[6], VC[7] }    },
    // valid streams
    { L_, "A0 C0123",       0,     4,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "A0 C4567",       0,     4,      { VC[4], VC[5], VC[6], VC[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 B1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 C01 E2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C012 F3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C0123 G4",    0,     5,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "A0 C012 H3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C01 I2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C0 J1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 K0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 L1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 C01 M2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C012 N3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C0123 O4",    0,     5,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "A0 C012 P3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C01 Q2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C0 R1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 S0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 T1 C234",  0,     5,      { VC[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 28: {
        // --------------------------------------------------------------------
        // RELOAD TEST:
        //   Create 'bdex_TestInStreamFormatter' objects containing data of
        //   varying lengths.  Invalidate each stream and then invoke its
        //   'reload'  method with data of varying lengths.  Verify that each
        //   resulting stream is valid and contains the expected length and
        //   content.  Note that since we only wish to ensure that 'reload'
        //   correctly replaces a stream's content with its supplied data, it
        //   is sufficient to use only one data type (int) for the test data.
        //
        // Testing:
        //   void reload(const char *buffer, int numBytes);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "RELOAD TEST" << endl
                                  << "===========" << endl;

        if (verbose) cout << "\nTesting 'reload'." << endl;
        {
            const int MAX_ELEM = 100;
            struct {
                int         d_line;          // line number
                const char *d_spec;          // data stream spec
                int         d_numVals;       // number of expected values
                int         d_exp[MAX_ELEM]; // expected values
            } DATA[] = {
 //-------------^
 //line  data                    num.    expected
 //no.   spec                    values  values
 //----  ----------------------  ------  ------------------------------------
 { L_,   "",                        0,   { 0 }                               },
 { L_,   "G0G1G2G3G4G5G6G7G8G9",   10,   {VG[0], VG[1], VG[2], VG[3], VG[4],
                                          VG[5], VG[6], VG[7], VG[8], VG[9] }},
 { L_,   "G9G8G7G6G5G4G3G2G1G0"
         "G9G8G7G6G5G4G3G2G1G0"
         "G9G8G7G6G5G4G3G2G1G0",   30,   {VG[9], VG[8], VG[7], VG[6], VG[5],
                                          VG[4], VG[3], VG[2], VG[1], VG[0],
                                          VG[9], VG[8], VG[7], VG[6], VG[5],
                                          VG[4], VG[3], VG[2], VG[1], VG[0],
                                          VG[9], VG[8], VG[7], VG[6], VG[5],
                                          VG[4], VG[3], VG[2], VG[1], VG[0] } }
 //-------------v
            };
            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int di = 0; di < NUM_DATA; ++di) {
                const char *SPEC = DATA[di].d_spec;
                bdesb_MemOutStreamBuf osb;
                bdex_TestOutStreamFormatter mO(&osb);
                LOOP_ASSERT(di, g(&mO, SPEC));

                for (int dj = 0; dj < NUM_DATA; ++dj) {
                    const char *SPEC2 = DATA[dj].d_spec;
                    bdesb_MemOutStreamBuf osb2;
                    bdex_TestOutStreamFormatter mO2(&osb2);
                    LOOP2_ASSERT(di, dj, g(&mO2, SPEC2));

                    bdesb_FixedMemInStreamBuf
                                             sb(const_cast<char *>(osb.data()),
                                                osb.length());
                    bdex_TestInStreamFormatter x(&sb);
                    x.setSuppressVersionCheck(1);

                    x.invalidate();    LOOP2_ASSERT(di, dj, !x);

                    x.reload(osb2.data(), osb2.length());
                    LOOP2_ASSERT(di,
                                 dj,
                                 osb2.length() ==
                                                    x.length());
                    LOOP2_ASSERT(di, dj, x);

                    const int NUM_VALUES = DATA[dj].d_numVals;
                    const int *EXP = DATA[dj].d_exp;
                    for (int k = 0; k < NUM_VALUES; ++k) {
                        int n;
                        x.getInt32(n);
                        LOOP3_ASSERT(di, dj, k, EXP[k] == n);
                    }
                    LOOP2_ASSERT(di, dj, sb.length() == 0);
                }
            }
        }
      } break;
      case 27: {
        // --------------------------------------------------------------------
        // INPUT LIMIT EXCEPTION TEST:
        //   See description of the testing mechanisms in the above function
        //   descriptions of 'testGetArrayInputLimit' (for array input methods)
        //   and 'testGetScalarInputLimit' (for scalar input methods).
        //
        // Testing:
        //   Ensure every input method correctly modifies the input limit and
        //   throws an exception when the input limit is exceeded.
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "INPUT LIMIT EXCEPTION TEST" << endl
                                  << "==========================" << endl;

                //
        // Testing:
        //   void setInputLimit(int limit);
        //   int inputLimit() const;
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET/SET INPUT LIMIT TEST" << endl
                                  << "========================" << endl;

        if (verbose)
            cout << "\nTesting 'setInputLimit' and 'inputLimit'." << endl;

        {
            char localBuf[4]; // g++ 2.95 crashes if size is < 4
            bdesb_FixedMemInStreamBuf sb(localBuf, 2);
            bdex_TestInStreamFormatter x(&sb);
            ASSERT(  0 >  x.inputLimit());
            x.setInputLimit(0);
            ASSERT(  0 == x.inputLimit());
            x.setInputLimit(10);
            ASSERT( 10 == x.inputLimit());
            x.setInputLimit(-10);
            ASSERT(-10 == x.inputLimit());
        }
      } break;
      case 25: {
        // --------------------------------------------------------------------
        // SEEK/RESET TEST:
        //   Create a 'bdex_TestInStreamFormatter' object initialized with
        //   arbitrary data.  Invalidate the stream and then invoke its 'seek'
        //   method with varying values.  Verify that the resulting stream is
        //   valid and its cursor is correctly modified.  Then use 'seek' to
        //   modify the stream's cursor to varying values.  Invalidate the
        //   stream and then invoke its 'reset' method.  Verify that the
        //   resulting stream is valid and its cursor is 0.
        //
        // Testing:
        //   void seek(int offset);
        //   void reset();
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "SEEK/RESET TEST" << endl
                                  << "===============" << endl;

        if (verbose) cout << "\nTesting 'seek' and 'reset'." << endl;
        {
            const char *SPEC = "k10 k10 k10 k10"; // fairly long stream
            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);
            int res = g(&o, SPEC);          ASSERT( 1 == res);
            bdesb_FixedMemInStreamBuf sb(const_cast<char *>(osb.data()),
                                         osb.length());
            bdex_TestInStreamFormatter x(&sb);
            ASSERT( 0 == x.cursor());

            x.invalidate();                 ASSERT(!x);
            x.seek(10);     ASSERT(x);
            ASSERT(10 == x.cursor());

            x.invalidate();                 ASSERT(!x);
            x.seek(5);      ASSERT(x);
            ASSERT( 5 == x.cursor());

            x.invalidate();                 ASSERT(!x);
            x.seek(0);      ASSERT(x);
            ASSERT( 0 == x.cursor());

            x.invalidate();                 ASSERT(!x);
            x.reset();      ASSERT(x);
            ASSERT( 0 == x.cursor());

            x.seek(5);
            x.invalidate();                 ASSERT(!x);
            x.reset();      ASSERT(x);
            ASSERT( 0 == x.cursor());

            x.seek(10);
            x.invalidate();                 ASSERT(!x);
            x.reset();      ASSERT(x);
            ASSERT( 0 == x.cursor());
        }
      } break;
      case 24: {
        // --------------------------------------------------------------------
        // GET 64-BIT FLOAT ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayFloat64(double *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 64-BIT FLOAT ARRAYS TEST" << endl
                                  << "============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayFloat64'." << endl;
        {
            typedef double ElemType;
            typedef bdex_TestInStreamFormatter&
                       (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayFloat64;
            const ElemType *V_ORIG = VL;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "l1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "l0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "l1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "l2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "l3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 l0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 l1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 l2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 l3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 l2 l3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 l4 b5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 l7 l8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 l1 d2 l3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 l5 l6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 l7 f8 l9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 l1 l2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 l4 h5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 i7 l8 l9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 l1 j2 l3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 l4 l5 k6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 l7 l8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 l1 n2 l3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 l5 l6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 l7 p8 l9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 l1 l2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 l1 s2 l3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 l5 l6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 l1 q2 l3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 23: {
        // --------------------------------------------------------------------
        // GET 32-BIT FLOAT ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayFloat32(float *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 32-BIT FLOAT ARRAYS TEST" << endl
                                  << "============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayFloat32'." << endl;
        {
            typedef float ElemType;
            typedef bdex_TestInStreamFormatter&
                       (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayFloat32;
            const ElemType *V_ORIG = VK;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "k1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "k0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "k1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "k2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "k3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 k0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 k1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 k2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 k3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 k2 k3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 k4 b5 k6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 k7 k8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 k1 d2 k3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 k5 k6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 k7 f8 k9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 k1 k2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 k4 h5 k6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 i7 k8 k9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 k1 j2 k3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 k4 k5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 k7 k8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 k1 n2 k3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 k5 k6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 k7 p8 k9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 k1 k2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 k1 s2 k3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 k5 k6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 k1 q2 k3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 22: {
        // --------------------------------------------------------------------
        // GET 64-BIT INTEGER ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayInt64(bsls::Types::Int64 *array, int numValues);
        //   getArrayUint64(bsls::Types::Uint64 *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 64-BIT INTEGER ARRAYS TEST" << endl
                                  << "==============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayInt64'." << endl;
        {
            typedef bsls::Types::Int64 ElemType;
            typedef bdex_TestInStreamFormatter&
                     (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt64;
            const ElemType *V_ORIG = VI;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "i1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "i0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "i1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "i2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "i3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 i0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 i1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 i2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 i3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 i2 i3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 i4 b5 i6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 i7 i8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 i1 d2 i3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 i5 i6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 i7 f8 i9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 i1 i2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 i4 h5 i6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 i8 i9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 i1 k2 i3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 i4 i5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 i7 i8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 i1 n2 i3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 i5 i6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 i7 p8 i9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 i1 i2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 i1 s2 i3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 i5 i6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 i1 q2 i3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getArrayUint64'." << endl;
        {
            typedef bsls::Types::Uint64 ElemType;
            typedef bdex_TestInStreamFormatter&
                      (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint64;
            const ElemType *V_ORIG = VJ;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream with bdex_TestOutStreamFormatter version
  { L_, "j1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams with bdex_TestOutStreamFormatter version and version check
  // turned off
  { L_, "j0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "j1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "j2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "j3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 j0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 j1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 j2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 j3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 j2 j3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 j4 b5 j6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 j8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 j1 d2 j3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 j5 j6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 j7 f8 j9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 j1 j2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 j4 h5 j6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 i7 j8 j9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 j1 k2 j3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 j4 j5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 j7 j8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 j1 n2 j3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 j5 j6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 j7 p8 j9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 j1 j2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 j1 s2 j3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 j5 j6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 j1 q2 j3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };

            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 21: {
        // --------------------------------------------------------------------
        // GET 56-BIT INTEGER ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayInt56(bsls::Types::Int64 *array, int numValues);
        //   getArrayUint56(bsls::Types::Uint64 *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 56-BIT INTEGER ARRAYS TEST" << endl
                                  << "==============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayInt56'." << endl;
        {
            typedef bsls::Types::Int64 ElemType;
            typedef bdex_TestInStreamFormatter&
                     (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt56;
            const ElemType *V_ORIG = VI;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "s1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "s0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "s1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "s2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "s3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 s0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 s1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 s2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 s3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 s2 s3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 s4 b5 s6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 s7 s8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 s1 d2 s3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 s5 s6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 s7 f8 s9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 s1 s2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 s4 h5 s6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 s8 s9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 s1 k2 s3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 s4 s5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 s7 s8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 s1 n2 s3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 s5 s6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 s7 p8 s9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 s1 s2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 s1 i2 s3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 s5 s6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 s1 q2 s3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getArrayUint56'." << endl;
        {
            typedef bsls::Types::Uint64 ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint56;
            const ElemType *V_ORIG = VJ;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "t1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "t0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "t1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "t2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "t3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 t0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 t1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 t2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 t3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 t2 t3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 t4 b5 t6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 t7 t8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 t1 d2 t3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 t5 t6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 t7 f8 t9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 t1 t2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 t4 h5 t6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 i7 t8 t9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 t1 k2 t3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 t5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 t7 t8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 t1 n2 t3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 t5 t6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 t7 p8 t9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 t1 t2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 t1 s2 t3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 j4 t5 t6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 t1 q2 t3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };

            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 20: {
        // --------------------------------------------------------------------
        // GET 48-BIT INTEGER ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayInt48(bsls::Types::Int64 *array, int numValues);
        //   getArrayUint48(bsls::Types::Uint64 *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 48-BIT INTEGER ARRAYS TEST" << endl
                                  << "==============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayInt48'." << endl;
        {
            typedef bsls::Types::Int64 ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt48;
            const ElemType *V_ORIG = VI;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "q1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "q0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "q1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "q2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "q3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 q0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 q1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 q2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 q3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 q2 q3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 q4 b5 q6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 q7 q8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 q1 d2 q3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 q5 q6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 q7 f8 q9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 q1 q2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 q4 h5 q6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 q8 q9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 q1 k2 q3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 q4 q5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 q7 q8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 q1 n2 q3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 q5 q6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 q7 p8 q9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 q1 q2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 q1 s2 q3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 q5 q6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 q1 i2 q3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getArrayUint48'." << endl;
        {
            typedef bsls::Types::Uint64 ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint48;
            const ElemType *V_ORIG = VJ;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "r1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "r0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "r1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "r2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "r3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 r0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 r1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 r2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 r3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 r2 r3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 r4 b5 r6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 r7 r8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 r1 d2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 r5 r6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 r7 f8 r9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 r1 r2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 r4 h5 r6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 i7 r8 r9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 r1 k2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 r4 r5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 r7 r8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 r1 n2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 r5 r6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 r7 p8 r9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 r1 r2 j3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 r1 s2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 r5 r6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 r1 q2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };

            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 19: {
        // --------------------------------------------------------------------
        // GET 40-BIT INTEGER ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayInt40(bsls::Types::Int64 *array, int numValues);
        //   getArrayUint40(bsls::Types::Uint64 *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 40-BIT INTEGER ARRAYS TEST" << endl
                                  << "==============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayInt40'." << endl;
        {
            typedef bsls::Types::Int64 ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt40;
            const ElemType *V_ORIG = VI;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "o1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "o0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "o1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "o2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "o3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 o0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 o1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 o2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 o3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 o2 o3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 o4 b5 o6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 o7 o8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 o1 d2 o3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 o5 o6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 o7 f8 o9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 o1 o2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 o4 h5 o6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 o8 o9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 o1 k2 o3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 o5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 o7 o8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 o1 n2 o3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 i4 o5 o6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 o7 p8 o9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 o1 o2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 o1 s2 o3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 o5 o6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 o1 q2 o3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getArrayUint40'." << endl;
        {
            typedef bsls::Types::Uint64 ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint40;
            const ElemType *V_ORIG = VJ;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "p1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "p0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "p1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "p2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "p3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 p0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 p1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 p2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 p3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 p2 p3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 p4 b5 p6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 p7 p8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 p1 d2 p3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 p5 p6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 p7 f8 p9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 p1 p2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 p4 h5 p6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 i7 p8 p9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 p1 k2 p3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 p4 p5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 p7 p8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 p1 n2 p3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 p5 p6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 p7 j8 p9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 p1 p2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 p1 s2 p3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 p5 p6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 p1 q2 p3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };

            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 18: {
        // --------------------------------------------------------------------
        // GET 32-BIT INTEGER ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayInt32(int *array, int numValues);
        //   getArrayUint32(unsigned int *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 32-BIT INTEGER ARRAYS TEST" << endl
                                  << "==============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayInt32'." << endl;
        {
            typedef int ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt32;
            const ElemType *V_ORIG = VG;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream with version
  { L_, "g1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "g0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "g1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "g2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "g3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 g0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 g1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 g2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 g3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 g2 g3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 g4 b5 g6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 g7 g8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 g1 d2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 g5 g6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 g7 f8 g9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 g1 g2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 g4 i5 g6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 g8 g9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 g1 k2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 g4 g5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 g7 g8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 g1 n2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 g5 g6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 g7 p8 g9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 g1 g2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 g1 s2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 g5 g6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 g1 q2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getArrayUint32'." << endl;
        {
            typedef unsigned int ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint32;
            const ElemType *V_ORIG = VH;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "h1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams with version and version check turned off
  { L_, "h0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "h1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "h2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "h3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 h0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 h1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 h2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 h3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 h2 h3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 h4 b5 h6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 h7 h8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 h1 d2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 h5 h6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 h7 f8 h9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 h1 h2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 h4 i5 h6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 h8 h9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 h1 k2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 h4 h5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 h7 h8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 h1 n2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 h5 h6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 h7 p8 h9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 h1 h2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 h1 s2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 h5 h6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 h1 q2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 17: {
        // --------------------------------------------------------------------
        // GET 24-BIT INTEGER ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayInt24(int *array, int numValues);
        //   getArrayUint24(unsigned int *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 24-BIT INTEGER ARRAYS TEST" << endl
                                  << "==============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayInt24'." << endl;
        {
            typedef int ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt24;
            const ElemType *V_ORIG = VG;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "m1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "m0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "m1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "m2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "m3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 m0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 m1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 m2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 m3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 m2 m3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 m4 b5 m6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 m7 m8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 m1 d2 m3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 m5 m6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 m7 f8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 m1 m2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 m4 i5 m6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 m8 m9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 m1 k2 m3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 m4 m5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 m7 m8 g9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 m1 n2 m3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 m5 m6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 m7 p8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 m1 m2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 m1 s2 m3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 m5 m6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 m1 q2 m3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getArrayUint24'." << endl;
        {
            typedef unsigned int ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint24;
            const ElemType *V_ORIG = VH;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "n1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "n0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "n1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "n2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "n3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 n0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 n1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 n2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 n3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 n2 n3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 n4 b5 n6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 n7 n8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 n1 d2 n3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 n5 n6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 n7 f8 n9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 n1 n2 g3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 n4 i5 n6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 n8 n9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 n1 k2 n3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 n4 n5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 n7 n8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 n1 h2 n3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 n5 n6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 n7 p8 n9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 n1 n2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 n1 s2 n3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 n5 n6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 n1 q2 n3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 16: {
        // --------------------------------------------------------------------
        // GET 16-BIT INTEGER ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //   getArrayInt16(short *array, int numValues);
        //   getArrayUint16(unsigned short *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 16-BIT INTEGER ARRAYS TEST" << endl
                                  << "==============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayInt16'." << endl;
        {
            typedef short ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt16;
            const ElemType *V_ORIG = VE;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "e1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "e0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "e1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "e2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "e3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 e0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 e1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 e2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 e3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 e2 e3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 e4 b5 e6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 e7 e8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 e1 d2 e3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 f4 e5 e6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 e7 g8 e9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 e1 e2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 e4 i5 e6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 e8 e9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 e1 k2 e3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 e5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 e7 e8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 e1 n2 e3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 e5 e6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 e7 p8 e9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 e1 e2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 e1 s2 e3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 e5 e6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 e1 q2 e3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getArrayUint16'." << endl;
        {
            typedef unsigned short ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint16;
            const ElemType *V_ORIG = VF;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,      0,        1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "f1",           0,      0,        1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "f0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "f1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "f2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "f3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 f0",        0,      1,        1,      { 0 },         { 0 }       },
  { L_, "A0 f1",        0,      1,        1,      { 1 },         { 1 }       },
  { L_, "A0 f2",        0,      1,        1,      { 2 },         { 2 }       },
  { L_, "A0 f3",        0,      1,        1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 f2 f3",  0,      0,        3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 f4 b5 f6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 f7 f8 c9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 f1 d2 f3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 e4 f5 f6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 f7 g8 f9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 f1 f2 h3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 f4 i5 f6",  0,      0,        3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 j7 f8 f9",  0,      0,        3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 f1 k2 f3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 f4 f5 l6",  0,      0,        3,      { 4, 5, 6 },   { 4, 5, 0 } },
  { L_, "A0 f7 f8 m9",  0,      0,        3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 f1 n2 f3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 f5 f6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 f7 p8 f9",  0,      0,        3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 f1 f2 r3",  0,      0,        3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 f1 s2 f3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 f5 f6",  0,      0,        3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 f1 q2 f3",  0,      0,        3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 15: {
        // --------------------------------------------------------------------
        // GET 8-BIT INTEGER ARRAYS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetArray'
        //
        // Testing:
        //    getArrayInt8(char *array, int numValues);
        //    getArrayInt8(signed char *array, int numValues);
        //    getArrayUint8(char *array, int numValues);
        //    getArrayUint8(unsigned char *array, int numValues);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 8-BIT INTEGER ARRAYS TEST" << endl
                                  << "=============================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getArrayInt8' w/ 'char*'." << endl;
        {
            typedef char ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt8;
            const ElemType *V_ORIG = VA;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,        0,      1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "a1",           0,        0,      1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "a0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "a1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "a2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "a3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 a0",        0,        1,      1,      { 0 },         { 0 }       },
  { L_, "A0 a1",        0,        1,      1,      { 1 },         { 1 }       },
  { L_, "A0 a2",        0,        1,      1,      { 2 },         { 2 }       },
  { L_, "A0 a3",        0,        1,      1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 c1 a2 a3",  0,        0,      3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 a4 d5 a6",  0,        0,      3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 a7 a8 e9",  0,        0,      3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 a1 f2 a3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 g4 a5 a6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 a7 h8 a9",  0,        0,      3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 a1 a2 i3",  0,        0,      3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 a4 j5 a6",  0,        0,      3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 k7 a8 a9",  0,        0,      3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 a1 l2 a3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 a7 a8 m9",  0,        0,      3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 a1 n2 a3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 a5 a6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 a7 p8 a9",  0,        0,      3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 a1 a2 r3",  0,        0,      3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 a1 s2 a3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 a5 a6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 a1 q2 a3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose)
            cout << "\nTesting 'getArrayInt8' w/ 'signed char*'." << endl;
        {
            typedef signed char ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayInt8;
            const ElemType *V_ORIG = VB;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,        0,      1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "b1",           0,        0,      1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "b0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "b1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "b2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "b3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 b0",        0,        1,      1,      { 0 },         { 0 }       },
  { L_, "A0 b1",        0,        1,      1,      { 1 },         { 1 }       },
  { L_, "A0 b2",        0,        1,      1,      { 2 },         { 2 }       },
  { L_, "A0 b3",        0,        1,      1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 c1 b2 b3",  0,        0,      3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 b4 d5 b6",  0,        0,      3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 b7 b8 e9",  0,        0,      3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 b1 f2 b3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 g4 b5 b6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 b7 h8 b9",  0,        0,      3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 b1 b2 i3",  0,        0,      3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 b4 j5 b6",  0,        0,      3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 k7 b8 b9",  0,        0,      3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 b1 l2 b3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 b7 b8 m9",  0,        0,      3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 b1 n2 b3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 b5 b6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 b7 p8 b9",  0,        0,      3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 b1 b2 r3",  0,        0,      3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 b1 s2 b3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 b5 b6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 b1 q2 b3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getArrayUint8' w/ 'char*'." << endl;
        {
            typedef char ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint8;
            const ElemType *V_ORIG = VC;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,        0,      1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "c1",           0,        0,      1,      { 1 },         { 0 }       },
  // valid streams without version and version check turned off
  { L_, "c0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "c1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "c2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "c3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 c0",        0,        1,      1,      { 0 },         { 0 }       },
  { L_, "A0 c1",        0,        1,      1,      { 1 },         { 1 }       },
  { L_, "A0 c2",        0,        1,      1,      { 2 },         { 2 }       },
  { L_, "A0 c3",        0,        1,      1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 c2 c3",  0,        0,      3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 c4 b5 c6",  0,        0,      3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 c7 c8 e9",  0,        0,      3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 c1 f2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 g4 c5 c6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 c7 h8 c9",  0,        0,      3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 c1 c2 i3",  0,        0,      3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 c4 j5 c6",  0,        0,      3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 k7 c8 c9",  0,        0,      3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 c1 l2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 c7 c8 m9",  0,        0,      3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 c1 n2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 c5 c6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 c7 p8 c9",  0,        0,      3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 c1 c2 r3",  0,        0,      3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 c1 s2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 c5 c6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 c1 q2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose)
            cout << "\nTesting 'getArrayUint8' w/ 'unsigned char*'." << endl;
        {
            typedef unsigned char ElemType;
            typedef bdex_TestInStreamFormatter&
                        (bdex_TestInStreamFormatter::*FuncPtr)(ElemType*, int);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getArrayUint8;
            const ElemType *V_ORIG = VD;        // base-comparison array

            static const ArrayTestTable DATA[] = {
  //                   supp  expected  # arrays   array lengths  expected
  //L#  spec           ver   validity  to read    to read        array lengths
  //--  -------------  ----  --------  ---------  -------------  -------------
  // read from empty stream
  { L_, "",             0,        0,      1,      { 1 },         { 0 }       },
  // stream without version
  { L_, "d1",           0,        0,      1,      { 1 },         { 0 }       },
  // valid streams with version and version check turned off
  { L_, "d0",           1,      1,        1,      { 0 },         { 0 }       },
  { L_, "d1",           1,      1,        1,      { 1 },         { 1 }       },
  { L_, "d2",           1,      1,        1,      { 2 },         { 2 }       },
  { L_, "d3",           1,      1,        1,      { 3 },         { 3 }       },
  // valid streams
  { L_, "A0 d0",        0,        1,      1,      { 0 },         { 0 }       },
  { L_, "A0 d1",        0,        1,      1,      { 1 },         { 1 }       },
  { L_, "A0 d2",        0,        1,      1,      { 2 },         { 2 }       },
  { L_, "A0 d3",        0,        1,      1,      { 3 },         { 3 }       },
  // streams containing incompatible data types
  { L_, "A0 a1 c2 c3",  0,        0,      3,      { 1, 2, 3 },   { 0, 0, 0 } },
  { L_, "A0 c4 b5 c6",  0,        0,      3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 c7 c8 e9",  0,        0,      3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 c1 f2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 g4 c5 c6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 c7 h8 c9",  0,        0,      3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 c1 c2 i3",  0,        0,      3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 c4 j5 c6",  0,        0,      3,      { 4, 5, 6 },   { 4, 0, 0 } },
  { L_, "A0 k7 c8 c9",  0,        0,      3,      { 7, 8, 9 },   { 0, 0, 0 } },
  { L_, "A0 c1 l2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 c7 c8 m9",  0,        0,      3,      { 7, 8, 9 },   { 7, 8, 0 } },
  { L_, "A0 c1 n2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 o4 c5 c6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 c7 p8 c9",  0,        0,      3,      { 7, 8, 9 },   { 7, 0, 0 } },
  { L_, "A0 c1 c2 r3",  0,        0,      3,      { 1, 2, 3 },   { 1, 2, 0 } },
  { L_, "A0 c1 s2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
  { L_, "A0 t4 c5 c6",  0,        0,      3,      { 4, 5, 6 },   { 0, 0, 0 } },
  { L_, "A0 c1 q2 c3",  0,        0,      3,      { 1, 2, 3 },   { 1, 0, 0 } },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetArray<ElemType, FuncPtr>(DATA, DATA_LEN, V_ORIG, FUNC);
        }
      } break;
      case 14: {
        // --------------------------------------------------------------------
        // GET 64-BIT FLOATS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getFloat64(double &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 64-BIT FLOATS TEST" << endl
                                  << "======================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getFloat64'." << endl;
        {
            typedef double ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getFloat64;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream without version
    { L_, "L01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "L0123",          1,     4,      { VL[0], VL[1], VL[2], VL[3] }    },
    { L_, "L4567",          1,     4,      { VL[4], VL[5], VL[6], VL[7] }    },
    // valid streams
    { L_, "A0 L0123",       0,     4,      { VL[0], VL[1], VL[2], VL[3] }    },
    { L_, "A0 L4567",       0,     4,      { VL[4], VL[5], VL[6], VL[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 L1234",    0,     5,      { 0 }                             },
    { L_, "A0 L0 B1 L234",  0,     5,      { VL[0] }                         },
    { L_, "A0 L01 C2 L34",  0,     5,      { VL[0], VL[1] }                  },
    { L_, "A0 L012 D3 L4",  0,     5,      { VL[0], VL[1], VL[2] }           },
    { L_, "A0 L0123 E4",    0,     5,      { VL[0], VL[1], VL[2], VL[3] }    },
    { L_, "A0 L012 F3 L4",  0,     5,      { VL[0], VL[1], VL[2] }           },
    { L_, "A0 L01 G2 L34",  0,     5,      { VL[0], VL[1] }                  },
    { L_, "A0 L0 H1 L234",  0,     5,      { VL[0] }                         },
    { L_, "A0 I0 L1234",    0,     5,      { 0 }                             },
    { L_, "A0 L0 J1 L234",  0,     5,      { VL[0] }                         },
    { L_, "A0 L01 K2 L34",  0,     5,      { VL[0], VL[1] }                  },
    { L_, "A0 L01 M2 L34",  0,     5,      { VL[0], VL[1] }                  },
    { L_, "A0 L012 N3 L4",  0,     5,      { VL[0], VL[1], VL[2] }           },
    { L_, "A0 L0123 O4",    0,     5,      { VL[0], VL[1], VL[2], VL[3] }    },
    { L_, "A0 L012 P3 L4",  0,     5,      { VL[0], VL[1], VL[2] }           },
    { L_, "A0 L01 Q2 L34",  0,     5,      { VL[0], VL[1] }                  },
    { L_, "A0 L0 R1 L234",  0,     5,      { VL[0] }                         },
    { L_, "A0 S0 L1234",    0,     5,      { 0 }                             },
    { L_, "A0 L0 T1 L234",  0,     5,      { VL[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 13: {
        // --------------------------------------------------------------------
        // GET 32-BIT FLOATS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getFloat32(float &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 32-BIT FLOATS TEST" << endl
                                  << "======================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getFloat32'." << endl;
        {
            typedef float ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getFloat32;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream without version
    { L_, "K01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "K0123",          1,     4,      { VK[0], VK[1], VK[2], VK[3] }    },
    { L_, "K4567",          1,     4,      { VK[4], VK[5], VK[6], VK[7] }    },
    // valid streams
    { L_, "A0 K0123",       0,     4,      { VK[0], VK[1], VK[2], VK[3] }    },
    { L_, "A0 K4567",       0,     4,      { VK[4], VK[5], VK[6], VK[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 K1234",    0,     5,      { 0 }                             },
    { L_, "A0 K0 B1 K234",  0,     5,      { VK[0] }                         },
    { L_, "A0 K01 C2 K34",  0,     5,      { VK[0], VK[1] }                  },
    { L_, "A0 K012 D3 K4",  0,     5,      { VK[0], VK[1], VK[2] }           },
    { L_, "A0 K0123 E4",    0,     5,      { VK[0], VK[1], VK[2], VK[3] }    },
    { L_, "A0 K012 F3 K4",  0,     5,      { VK[0], VK[1], VK[2] }           },
    { L_, "A0 K01 G2 K34",  0,     5,      { VK[0], VK[1] }                  },
    { L_, "A0 K0 H1 K234",  0,     5,      { VK[0] }                         },
    { L_, "A0 I0 K1234",    0,     5,      { 0 }                             },
    { L_, "A0 K0 J1 K234",  0,     5,      { VK[0] }                         },
    { L_, "A0 K01 L2 K34",  0,     5,      { VK[0], VK[1] }                  },
    { L_, "A0 K01 M2 K34",  0,     5,      { VK[0], VK[1] }                  },
    { L_, "A0 K012 N3 K4",  0,     5,      { VK[0], VK[1], VK[2] }           },
    { L_, "A0 K0123 O4",    0,     5,      { VK[0], VK[1], VK[2], VK[3] }    },
    { L_, "A0 K012 P3 K4",  0,     5,      { VK[0], VK[1], VK[2] }           },
    { L_, "A0 K01 Q2 K34",  0,     5,      { VK[0], VK[1] }                  },
    { L_, "A0 K0 R1 K234",  0,     5,      { VK[0] }                         },
    { L_, "A0 S0 K1234",    0,     5,      { 0 }                             },
    { L_, "A0 K0 T1 K234",  0,     5,      { VK[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 12: {
        // --------------------------------------------------------------------
        // GET 64-BIT INTEGERS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getInt64(bsls::Types::Int64 val &variable);
        //   getUint64(bsls::Types::Uint64 val &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 64-BIT INTEGERS TEST" << endl
                                  << "========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getInt64'." << endl;
        {
            typedef bsls::Types::Int64 ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt64;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream without version
    { L_, "I01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "I0123",          1,     4,      { VI[0], VI[1], VI[2], VI[3] }    },
    { L_, "I4567",          1,     4,      { VI[4], VI[5], VI[6], VI[7] }    },
    // valid streams
    { L_, "A0 I0123",       0,     4,      { VI[0], VI[1], VI[2], VI[3] }    },
    { L_, "A0 I4567",       0,     4,      { VI[4], VI[5], VI[6], VI[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 I1234",    0,     5,      { 0 }                             },
    { L_, "A0 I0 B1 I234",  0,     5,      { VI[0] }                         },
    { L_, "A0 I01 C2 I34",  0,     5,      { VI[0], VI[1] }                  },
    { L_, "A0 I012 D3 I4",  0,     5,      { VI[0], VI[1], VI[2] }           },
    { L_, "A0 I0123 E4",    0,     5,      { VI[0], VI[1], VI[2], VI[3] }    },
    { L_, "A0 I012 F3 I4",  0,     5,      { VI[0], VI[1], VI[2] }           },
    { L_, "A0 I01 G2 I34",  0,     5,      { VI[0], VI[1] }                  },
    { L_, "A0 I0 H1 I234",  0,     5,      { VI[0] }                         },
    { L_, "A0 J0 I1234",    0,     5,      { 0 }                             },
    { L_, "A0 I0 K1 I234",  0,     5,      { VI[0] }                         },
    { L_, "A0 I01 L2 I34",  0,     5,      { VI[0], VI[1] }                  },
    { L_, "A0 I01 M2 I34",  0,     5,      { VI[0], VI[1] }                  },
    { L_, "A0 I012 N3 I4",  0,     5,      { VI[0], VI[1], VI[2] }           },
    { L_, "A0 I0123 O4",    0,     5,      { VI[0], VI[1], VI[2], VI[3] }    },
    { L_, "A0 I012 P3 I4",  0,     5,      { VI[0], VI[1], VI[2] }           },
    { L_, "A0 I01 Q2 I34",  0,     5,      { VI[0], VI[1] }                  },
    { L_, "A0 I0 R1 I234",  0,     5,      { VI[0] }                         },
    { L_, "A0 S0 I1234",    0,     5,      { 0 }                             },
    { L_, "A0 I0 T1 I234",  0,     5,      { VI[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getUint64'." << endl;
        {
            typedef bsls::Types::Uint64 ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint64;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "J01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "J0123",          1,     4,      { VJ[0], VJ[1], VJ[2], VJ[3] }    },
    { L_, "J4567",          1,     4,      { VJ[4], VJ[5], VJ[6], VJ[7] }    },
    // valid streams
    { L_, "A0 J0123",       0,     4,      { VJ[0], VJ[1], VJ[2], VJ[3] }    },
    { L_, "A0 J4567",       0,     4,      { VJ[4], VJ[5], VJ[6], VJ[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 J1234",    0,     5,      { 0 }                             },
    { L_, "A0 J0 B1 J234",  0,     5,      { VJ[0] }                         },
    { L_, "A0 J01 C2 J34",  0,     5,      { VJ[0], VJ[1] }                  },
    { L_, "A0 J012 D3 J4",  0,     5,      { VJ[0], VJ[1], VJ[2] }           },
    { L_, "A0 J0123 E4",    0,     5,      { VJ[0], VJ[1], VJ[2], VJ[3] }    },
    { L_, "A0 J012 F3 J4",  0,     5,      { VJ[0], VJ[1], VJ[2] }           },
    { L_, "A0 J01 G2 J34",  0,     5,      { VJ[0], VJ[1] }                  },
    { L_, "A0 J0 H1 J234",  0,     5,      { VJ[0] }                         },
    { L_, "A0 I0 J1234",    0,     5,      { 0 }                             },
    { L_, "A0 J0 K1 J234",  0,     5,      { VJ[0] }                         },
    { L_, "A0 J01 L2 J34",  0,     5,      { VJ[0], VJ[1] }                  },
    { L_, "A0 J01 M2 J34",  0,     5,      { VJ[0], VJ[1] }                  },
    { L_, "A0 J012 N3 J4",  0,     5,      { VJ[0], VJ[1], VJ[2] }           },
    { L_, "A0 J0123 O4",    0,     5,      { VJ[0], VJ[1], VJ[2], VJ[3] }    },
    { L_, "A0 J012 P3 J4",  0,     5,      { VJ[0], VJ[1], VJ[2] }           },
    { L_, "A0 J01 Q2 J34",  0,     5,      { VJ[0], VJ[1] }                  },
    { L_, "A0 J0 R1 J234",  0,     5,      { VJ[0] }                         },
    { L_, "A0 S0 J1234",    0,     5,      { 0 }                             },
    { L_, "A0 J0 T1 J234",  0,     5,      { VJ[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 11: {
        // --------------------------------------------------------------------
        // GET 56-BIT INTEGERS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getInt56(bsls::Types::Int64 val &variable);
        //   getUint56(bsls::Types::Uint64 val &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 56-BIT INTEGERS TEST" << endl
                                  << "========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getInt56'." << endl;
        {
            typedef bsls::Types::Int64 ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt56;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "S01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "S0123",          1,     4,      { VS[0], VS[1], VS[2], VS[3] }    },
    { L_, "S4567",          1,     4,      { VS[4], VS[5], VS[6], VS[7] }    },
    // valid streams
    { L_, "A0 S0123",       0,     4,      { VS[0], VS[1], VS[2], VS[3] }    },
    { L_, "A0 S4567",       0,     4,      { VS[4], VS[5], VS[6], VS[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 S1234",    0,     5,      { 0 }                             },
    { L_, "A0 S0 B1 S234",  0,     5,      { VS[0] }                         },
    { L_, "A0 S01 C2 S34",  0,     5,      { VS[0], VS[1] }                  },
    { L_, "A0 S012 D3 S4",  0,     5,      { VS[0], VS[1], VS[2] }           },
    { L_, "A0 S0123 E4",    0,     5,      { VS[0], VS[1], VS[2], VS[3] }    },
    { L_, "A0 S012 F3 S4",  0,     5,      { VS[0], VS[1], VS[2] }           },
    { L_, "A0 S01 G2 S34",  0,     5,      { VS[0], VS[1] }                  },
    { L_, "A0 S0 H1 S234",  0,     5,      { VS[0] }                         },
    { L_, "A0 J0 S1234",    0,     5,      { 0 }                             },
    { L_, "A0 S0 K1 S234",  0,     5,      { VS[0] }                         },
    { L_, "A0 S01 L2 S34",  0,     5,      { VS[0], VS[1] }                  },
    { L_, "A0 S01 M2 S34",  0,     5,      { VS[0], VS[1] }                  },
    { L_, "A0 S012 N3 S4",  0,     5,      { VS[0], VS[1], VS[2] }           },
    { L_, "A0 S0123 O4",    0,     5,      { VS[0], VS[1], VS[2], VS[3] }    },
    { L_, "A0 S012 P3 S4",  0,     5,      { VS[0], VS[1], VS[2] }           },
    { L_, "A0 S01 Q2 S34",  0,     5,      { VS[0], VS[1] }                  },
    { L_, "A0 S0 R1 S234",  0,     5,      { VS[0] }                         },
    { L_, "A0 I0 S1234",    0,     5,      { 0 }                             },
    { L_, "A0 S0 T1 S234",  0,     5,      { VS[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getUint56'." << endl;
        {
            typedef bsls::Types::Uint64 ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint56;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "T01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "T0123",          1,     4,      { VT[0], VT[1], VT[2], VT[3] }    },
    { L_, "T4567",          1,     4,      { VT[4], VT[5], VT[6], VT[7] }    },
    // valid streams
    { L_, "A0 T0123",       0,     4,      { VT[0], VT[1], VT[2], VT[3] }    },
    { L_, "A0 T4567",       0,     4,      { VT[4], VT[5], VT[6], VT[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 T1234",    0,     5,      { 0 }                             },
    { L_, "A0 T0 B1 T234",  0,     5,      { VT[0] }                         },
    { L_, "A0 T01 C2 T34",  0,     5,      { VT[0], VT[1] }                  },
    { L_, "A0 T012 D3 T4",  0,     5,      { VT[0], VT[1], VT[2] }           },
    { L_, "A0 T0123 E4",    0,     5,      { VT[0], VT[1], VT[2], VT[3] }    },
    { L_, "A0 T012 F3 T4",  0,     5,      { VT[0], VT[1], VT[2] }           },
    { L_, "A0 T01 G2 T34",  0,     5,      { VT[0], VT[1] }                  },
    { L_, "A0 T0 H1 T234",  0,     5,      { VT[0] }                         },
    { L_, "A0 I0 T1234",    0,     5,      { 0 }                             },
    { L_, "A0 T0 K1 T234",  0,     5,      { VT[0] }                         },
    { L_, "A0 T01 L2 T34",  0,     5,      { VT[0], VT[1] }                  },
    { L_, "A0 T01 M2 T34",  0,     5,      { VT[0], VT[1] }                  },
    { L_, "A0 T012 N3 T4",  0,     5,      { VT[0], VT[1], VT[2] }           },
    { L_, "A0 T0123 O4",    0,     5,      { VT[0], VT[1], VT[2], VT[3] }    },
    { L_, "A0 T012 P3 T4",  0,     5,      { VT[0], VT[1], VT[2] }           },
    { L_, "A0 T01 Q2 T34",  0,     5,      { VT[0], VT[1] }                  },
    { L_, "A0 T0 R1 T234",  0,     5,      { VT[0] }                         },
    { L_, "A0 S0 T1234",    0,     5,      { 0 }                             },
    { L_, "A0 T0 J1 T234",  0,     5,      { VT[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 10: {
        // --------------------------------------------------------------------
        // GET 48-BIT INTEGERS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getInt48(bsls::Types::Int64 val &variable);
        //   getUint48(bsls::Types::Uint64 val &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 48-BIT INTEGERS TEST" << endl
                                  << "========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getInt48'." << endl;
        {
            typedef bsls::Types::Int64 ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt48;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream without version
    { L_, "Q01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "Q0123",          1,     4,      { VQ[0], VQ[1], VQ[2], VQ[3] }    },
    { L_, "Q4567",          1,     4,      { VQ[4], VQ[5], VQ[6], VQ[7] }    },
    // valid streams
    { L_, "A0 Q0123",       0,     4,      { VQ[0], VQ[1], VQ[2], VQ[3] }    },
    { L_, "A0 Q4567",       0,     4,      { VQ[4], VQ[5], VQ[6], VQ[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 Q1234",    0,     5,      { 0 }                             },
    { L_, "A0 Q0 B1 Q234",  0,     5,      { VQ[0] }                         },
    { L_, "A0 Q01 C2 Q34",  0,     5,      { VQ[0], VQ[1] }                  },
    { L_, "A0 Q012 D3 Q4",  0,     5,      { VQ[0], VQ[1], VQ[2] }           },
    { L_, "A0 Q0123 E4",    0,     5,      { VQ[0], VQ[1], VQ[2], VQ[3] }    },
    { L_, "A0 Q012 F3 Q4",  0,     5,      { VQ[0], VQ[1], VQ[2] }           },
    { L_, "A0 Q01 G2 Q34",  0,     5,      { VQ[0], VQ[1] }                  },
    { L_, "A0 Q0 H1 Q234",  0,     5,      { VQ[0] }                         },
    { L_, "A0 J0 Q1234",    0,     5,      { 0 }                             },
    { L_, "A0 Q0 K1 Q234",  0,     5,      { VQ[0] }                         },
    { L_, "A0 Q01 L2 Q34",  0,     5,      { VQ[0], VQ[1] }                  },
    { L_, "A0 Q01 M2 Q34",  0,     5,      { VQ[0], VQ[1] }                  },
    { L_, "A0 Q012 N3 Q4",  0,     5,      { VQ[0], VQ[1], VQ[2] }           },
    { L_, "A0 Q0123 O4",    0,     5,      { VQ[0], VQ[1], VQ[2], VQ[3] }    },
    { L_, "A0 Q012 P3 Q4",  0,     5,      { VQ[0], VQ[1], VQ[2] }           },
    { L_, "A0 Q01 I2 Q34",  0,     5,      { VQ[0], VQ[1] }                  },
    { L_, "A0 Q0 R1 Q234",  0,     5,      { VQ[0] }                         },
    { L_, "A0 S0 Q1234",    0,     5,      { 0 }                             },
    { L_, "A0 Q0 T1 Q234",  0,     5,      { VQ[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getUint48'." << endl;
        {
            typedef bsls::Types::Uint64 ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint48;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "R01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "R0123",          1,     4,      { VR[0], VR[1], VR[2], VR[3] }    },
    { L_, "R4567",          1,     4,      { VR[4], VR[5], VR[6], VR[7] }    },
    // valid streams
    { L_, "A0 R0123",       0,     4,      { VR[0], VR[1], VR[2], VR[3] }    },
    { L_, "A0 R4567",       0,     4,      { VR[4], VR[5], VR[6], VR[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 R1234",    0,     5,      { 0 }                             },
    { L_, "A0 R0 B1 R234",  0,     5,      { VR[0] }                         },
    { L_, "A0 R01 C2 R34",  0,     5,      { VR[0], VR[1] }                  },
    { L_, "A0 R012 D3 R4",  0,     5,      { VR[0], VR[1], VR[2] }           },
    { L_, "A0 R0123 E4",    0,     5,      { VR[0], VR[1], VR[2], VR[3] }    },
    { L_, "A0 R012 F3 R4",  0,     5,      { VR[0], VR[1], VR[2] }           },
    { L_, "A0 R01 G2 R34",  0,     5,      { VR[0], VR[1] }                  },
    { L_, "A0 R0 H1 R234",  0,     5,      { VR[0] }                         },
    { L_, "A0 I0 R1234",    0,     5,      { 0 }                             },
    { L_, "A0 R0 K1 R234",  0,     5,      { VR[0] }                         },
    { L_, "A0 R01 L2 R34",  0,     5,      { VR[0], VR[1] }                  },
    { L_, "A0 R01 M2 R34",  0,     5,      { VR[0], VR[1] }                  },
    { L_, "A0 R012 N3 R4",  0,     5,      { VR[0], VR[1], VR[2] }           },
    { L_, "A0 R0123 O4",    0,     5,      { VR[0], VR[1], VR[2], VR[3] }    },
    { L_, "A0 R012 P3 R4",  0,     5,      { VR[0], VR[1], VR[2] }           },
    { L_, "A0 R01 Q2 R34",  0,     5,      { VR[0], VR[1] }                  },
    { L_, "A0 R0 J1 R234",  0,     5,      { VR[0] }                         },
    { L_, "A0 S0 R1234",    0,     5,      { 0 }                             },
    { L_, "A0 R0 T1 R234",  0,     5,      { VR[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 9: {
        // --------------------------------------------------------------------
        // GET 40-BIT INTEGERS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getInt40(bsls::Types::Int64 val &variable);
        //   getUint40(bsls::Types::Uint64 val &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 40-BIT INTEGERS TEST" << endl
                                  << "========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getInt40'." << endl;
        {
            typedef bsls::Types::Int64 ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt40;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "O01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "O0123",          1,     4,      { VO[0], VO[1], VO[2], VO[3] }    },
    { L_, "O4567",          1,     4,      { VO[4], VO[5], VO[6], VO[7] }    },
    // valid streams
    { L_, "A0 O0123",       0,     4,      { VO[0], VO[1], VO[2], VO[3] }    },
    { L_, "A0 O4567",       0,     4,      { VO[4], VO[5], VO[6], VO[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 O1234",    0,     5,      { 0 }                             },
    { L_, "A0 O0 B1 O234",  0,     5,      { VO[0] }                         },
    { L_, "A0 O01 C2 O34",  0,     5,      { VO[0], VO[1] }                  },
    { L_, "A0 O012 D3 O4",  0,     5,      { VO[0], VO[1], VO[2] }           },
    { L_, "A0 O0123 E4",    0,     5,      { VO[0], VO[1], VO[2], VO[3] }    },
    { L_, "A0 O012 F3 O4",  0,     5,      { VO[0], VO[1], VO[2] }           },
    { L_, "A0 O01 G2 O34",  0,     5,      { VO[0], VO[1] }                  },
    { L_, "A0 O0 H1 O234",  0,     5,      { VO[0] }                         },
    { L_, "A0 J0 O1234",    0,     5,      { 0 }                             },
    { L_, "A0 O0 K1 O234",  0,     5,      { VO[0] }                         },
    { L_, "A0 O01 L2 O34",  0,     5,      { VO[0], VO[1] }                  },
    { L_, "A0 O01 M2 O34",  0,     5,      { VO[0], VO[1] }                  },
    { L_, "A0 O012 N3 O4",  0,     5,      { VO[0], VO[1], VO[2] }           },
    { L_, "A0 O0123 I4",    0,     5,      { VO[0], VO[1], VO[2], VO[3] }    },
    { L_, "A0 O012 P3 O4",  0,     5,      { VO[0], VO[1], VO[2] }           },
    { L_, "A0 O01 Q2 O34",  0,     5,      { VO[0], VO[1] }                  },
    { L_, "A0 O0 R1 O234",  0,     5,      { VO[0] }                         },
    { L_, "A0 S0 O1234",    0,     5,      { 0 }                             },
    { L_, "A0 O0 T1 O234",  0,     5,      { VO[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getUint40'." << endl;
        {
            typedef bsls::Types::Uint64 ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint40;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "P01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "P0123",          1,     4,      { VP[0], VP[1], VP[2], VP[3] }    },
    { L_, "P4567",          1,     4,      { VP[4], VP[5], VP[6], VP[7] }    },
    // valid streams
    { L_, "A0 P0123",       0,     4,      { VP[0], VP[1], VP[2], VP[3] }    },
    { L_, "A0 P4567",       0,     4,      { VP[4], VP[5], VP[6], VP[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 P1234",    0,     5,      { 0 }                             },
    { L_, "A0 P0 B1 P234",  0,     5,      { VP[0] }                         },
    { L_, "A0 P01 C2 P34",  0,     5,      { VP[0], VP[1] }                  },
    { L_, "A0 P012 D3 P4",  0,     5,      { VP[0], VP[1], VP[2] }           },
    { L_, "A0 P0123 E4",    0,     5,      { VP[0], VP[1], VP[2], VP[3] }    },
    { L_, "A0 P012 F3 P4",  0,     5,      { VP[0], VP[1], VP[2] }           },
    { L_, "A0 P01 G2 P34",  0,     5,      { VP[0], VP[1] }                  },
    { L_, "A0 P0 H1 P234",  0,     5,      { VP[0] }                         },
    { L_, "A0 I0 P1234",    0,     5,      { 0 }                             },
    { L_, "A0 P0 K1 P234",  0,     5,      { VP[0] }                         },
    { L_, "A0 P01 L2 P34",  0,     5,      { VP[0], VP[1] }                  },
    { L_, "A0 P01 M2 P34",  0,     5,      { VP[0], VP[1] }                  },
    { L_, "A0 P012 N3 P4",  0,     5,      { VP[0], VP[1], VP[2] }           },
    { L_, "A0 P0123 O4",    0,     5,      { VP[0], VP[1], VP[2], VP[3] }    },
    { L_, "A0 P012 J3 P4",  0,     5,      { VP[0], VP[1], VP[2] }           },
    { L_, "A0 P01 Q2 P34",  0,     5,      { VP[0], VP[1] }                  },
    { L_, "A0 P0 R1 P234",  0,     5,      { VP[0] }                         },
    { L_, "A0 S0 P1234",    0,     5,      { 0 }                             },
    { L_, "A0 P0 T1 P234",  0,     5,      { VP[0] }                         },

            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 8: {
        // --------------------------------------------------------------------
        // GET 32-BIT INTEGERS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getInt32(int &variable);
        //   getUint32(unsigned int &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 32-BIT INTEGERS TEST" << endl
                                  << "========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getInt32'." << endl;
        {
            typedef int ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt32;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "G01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "G0123",          1,     4,      { VG[0], VG[1], VG[2], VG[3] }    },
    { L_, "G4567",          1,     4,      { VG[4], VG[5], VG[6], VG[7] }    },
    // valid streams
    { L_, "A0 G0123",       0,     4,      { VG[0], VG[1], VG[2], VG[3] }    },
    { L_, "A0 G4567",       0,     4,      { VG[4], VG[5], VG[6], VG[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 G1234",    0,     5,      { 0 }                             },
    { L_, "A0 G0 B1 G234",  0,     5,      { VG[0] }                         },
    { L_, "A0 G01 C2 G34",  0,     5,      { VG[0], VG[1] }                  },
    { L_, "A0 G012 D3 G4",  0,     5,      { VG[0], VG[1], VG[2] }           },
    { L_, "A0 G0123 E4",    0,     5,      { VG[0], VG[1], VG[2], VG[3] }    },
    { L_, "A0 G012 F3 G4",  0,     5,      { VG[0], VG[1], VG[2] }           },
    { L_, "A0 G01 H2 G34",  0,     5,      { VG[0], VG[1] }                  },
    { L_, "A0 G0 I1 G234",  0,     5,      { VG[0] }                         },
    { L_, "A0 J0 G1234",    0,     5,      { 0 }                             },
    { L_, "A0 G0 K1 G234",  0,     5,      { VG[0] }                         },
    { L_, "A0 G01 L2 G34",  0,     5,      { VG[0], VG[1] }                  },
    { L_, "A0 G01 M2 G34",  0,     5,      { VG[0], VG[1] }                  },
    { L_, "A0 G012 N3 G4",  0,     5,      { VG[0], VG[1], VG[2] }           },
    { L_, "A0 G0123 O4",    0,     5,      { VG[0], VG[1], VG[2], VG[3] }    },
    { L_, "A0 G012 P3 G4",  0,     5,      { VG[0], VG[1], VG[2] }           },
    { L_, "A0 G01 Q2 G34",  0,     5,      { VG[0], VG[1] }                  },
    { L_, "A0 G0 R1 G234",  0,     5,      { VG[0] }                         },
    { L_, "A0 S0 G1234",    0,     5,      { 0 }                             },
    { L_, "A0 G0 T1 G234",  0,     5,      { VG[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getUint32'." << endl;
        {
            typedef unsigned int ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint32;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "H01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "H0123",          1,     4,      { VH[0], VH[1], VH[2], VH[3] }    },
    { L_, "H4567",          1,     4,      { VH[4], VH[5], VH[6], VH[7] }    },
    // valid streams
    { L_, "A0 H0123",       0,     4,      { VH[0], VH[1], VH[2], VH[3] }    },
    { L_, "A0 H4567",       0,     4,      { VH[4], VH[5], VH[6], VH[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 H1234",    0,     5,      { 0 }                             },
    { L_, "A0 H0 B1 H234",  0,     5,      { VH[0] }                         },
    { L_, "A0 H01 C2 H34",  0,     5,      { VH[0], VH[1] }                  },
    { L_, "A0 H012 D3 H4",  0,     5,      { VH[0], VH[1], VH[2] }           },
    { L_, "A0 H0123 E4",    0,     5,      { VH[0], VH[1], VH[2], VH[3] }    },
    { L_, "A0 H012 F3 H4",  0,     5,      { VH[0], VH[1], VH[2] }           },
    { L_, "A0 H01 G2 H34",  0,     5,      { VH[0], VH[1] }                  },
    { L_, "A0 H0 I1 H234",  0,     5,      { VH[0] }                         },
    { L_, "A0 J0 H1234",    0,     5,      { 0 }                             },
    { L_, "A0 H0 K1 H234",  0,     5,      { VH[0] }                         },
    { L_, "A0 H01 L2 H34",  0,     5,      { VH[0], VH[1] }                  },
    { L_, "A0 H01 M2 H34",  0,     5,      { VH[0], VH[1] }                  },
    { L_, "A0 H012 N3 H4",  0,     5,      { VH[0], VH[1], VH[2] }           },
    { L_, "A0 H0123 O4",    0,     5,      { VH[0], VH[1], VH[2], VH[3] }    },
    { L_, "A0 H012 P3 H4",  0,     5,      { VH[0], VH[1], VH[2] }           },
    { L_, "A0 H01 Q2 H34",  0,     5,      { VH[0], VH[1] }                  },
    { L_, "A0 H0 R1 H234",  0,     5,      { VH[0] }                         },
    { L_, "A0 S0 H1234",    0,     5,      { 0 }                             },
    { L_, "A0 H0 T1 H234",  0,     5,      { VH[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 7: {
        // --------------------------------------------------------------------
        // GET 24-BIT INTEGERS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getInt24(int &variable);
        //   getUint24(unsigned int &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 24-BIT INTEGERS TEST" << endl
                                  << "========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getInt24'." << endl;
        {
            typedef int ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt24;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "M01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "M0123",          1,     4,      { VM[0], VM[1], VM[2], VM[3] }    },
    { L_, "M4567",          1,     4,      { VM[4], VM[5], VM[6], VM[7] }    },
    // valid streams
    { L_, "A0 M0123",       0,     4,      { VM[0], VM[1], VM[2], VM[3] }    },
    { L_, "A0 M4567",       0,     4,      { VM[4], VM[5], VM[6], VM[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 M1234",    0,     5,      { 0 }                             },
    { L_, "A0 M0 B1 M234",  0,     5,      { VM[0] }                         },
    { L_, "A0 M01 C2 M34",  0,     5,      { VM[0], VM[1] }                  },
    { L_, "A0 M012 D3 M4",  0,     5,      { VM[0], VM[1], VM[2] }           },
    { L_, "A0 M0123 E4",    0,     5,      { VM[0], VM[1], VM[2], VM[3] }    },
    { L_, "A0 M012 F3 M4",  0,     5,      { VM[0], VM[1], VM[2] }           },
    { L_, "A0 M01 H2 M34",  0,     5,      { VM[0], VM[1] }                  },
    { L_, "A0 M0 I1 M234",  0,     5,      { VM[0] }                         },
    { L_, "A0 J0 M1234",    0,     5,      { 0 }                             },
    { L_, "A0 M0 K1 M234",  0,     5,      { VM[0] }                         },
    { L_, "A0 M01 L2 M34",  0,     5,      { VM[0], VM[1] }                  },
    { L_, "A0 M01 G2 M34",  0,     5,      { VM[0], VM[1] }                  },
    { L_, "A0 M012 N3 M4",  0,     5,      { VM[0], VM[1], VM[2] }           },
    { L_, "A0 M0123 O4",    0,     5,      { VM[0], VM[1], VM[2], VM[3] }    },
    { L_, "A0 M012 P3 M4",  0,     5,      { VM[0], VM[1], VM[2] }           },
    { L_, "A0 M01 Q2 M34",  0,     5,      { VM[0], VM[1] }                  },
    { L_, "A0 M0 R1 M234",  0,     5,      { VM[0] }                         },
    { L_, "A0 S0 M1234",    0,     5,      { 0 }                             },
    { L_, "A0 M0 T1 M234",  0,     5,      { VM[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getUint24'." << endl;
        {
            typedef unsigned int ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint24;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "N01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "N0123",          1,     4,      { VN[0], VN[1], VN[2], VN[3] }    },
    { L_, "N4567",          1,     4,      { VN[4], VN[5], VN[6], VN[7] }    },
    // valid streams
    { L_, "A0 N0123",       0,     4,      { VN[0], VN[1], VN[2], VN[3] }    },
    { L_, "A0 N4567",       0,     4,      { VN[4], VN[5], VN[6], VN[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 N1234",    0,     5,      { 0 }                             },
    { L_, "A0 N0 B1 N234",  0,     5,      { VN[0] }                         },
    { L_, "A0 N01 C2 N34",  0,     5,      { VN[0], VN[1] }                  },
    { L_, "A0 N012 D3 N4",  0,     5,      { VN[0], VN[1], VN[2] }           },
    { L_, "A0 N0123 E4",    0,     5,      { VN[0], VN[1], VN[2], VN[3] }    },
    { L_, "A0 N012 F3 N4",  0,     5,      { VN[0], VN[1], VN[2] }           },
    { L_, "A0 N01 G2 N34",  0,     5,      { VN[0], VN[1] }                  },
    { L_, "A0 N0 I1 N234",  0,     5,      { VN[0] }                         },
    { L_, "A0 J0 N1234",    0,     5,      { 0 }                             },
    { L_, "A0 N0 K1 N234",  0,     5,      { VN[0] }                         },
    { L_, "A0 N01 L2 N34",  0,     5,      { VN[0], VN[1] }                  },
    { L_, "A0 N01 M2 N34",  0,     5,      { VN[0], VN[1] }                  },
    { L_, "A0 N012 H3 N4",  0,     5,      { VN[0], VN[1], VN[2] }           },
    { L_, "A0 N0123 O4",    0,     5,      { VN[0], VN[1], VN[2], VN[3] }    },
    { L_, "A0 N012 P3 N4",  0,     5,      { VN[0], VN[1], VN[2] }           },
    { L_, "A0 N01 Q2 N34",  0,     5,      { VN[0], VN[1] }                  },
    { L_, "A0 N0 R1 N234",  0,     5,      { VN[0] }                         },
    { L_, "A0 S0 N1234",    0,     5,      { 0 }                             },
    { L_, "A0 N0 T1 N234",  0,     5,      { VN[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 6: {
        // --------------------------------------------------------------------
        // GET 16-BIT INTEGERS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'
        //
        // Testing:
        //   getInt16(short &variable);
        //   getUint16(unsigned short &variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 16-BIT INTEGERS TEST" << endl
                                  << "========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getInt16'." << endl;
        {
            typedef short ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt16;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "E01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "E0123",          1,     4,      { VE[0], VE[1], VE[2], VE[3] }    },
    { L_, "E4567",          1,     4,      { VE[4], VE[5], VE[6], VE[7] }    },
    // valid streams
    { L_, "A0 E0123",       0,     4,      { VE[0], VE[1], VE[2], VE[3] }    },
    { L_, "A0 E4567",       0,     4,      { VE[4], VE[5], VE[6], VE[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 E1234",    0,     5,      { 0 }                             },
    { L_, "A0 E0 B1 E234",  0,     5,      { VE[0] }                         },
    { L_, "A0 E01 C2 E34",  0,     5,      { VE[0], VE[1] }                  },
    { L_, "A0 E012 D3 E4",  0,     5,      { VE[0], VE[1], VE[2] }           },
    { L_, "A0 E0123 F4",    0,     5,      { VE[0], VE[1], VE[2], VE[3] }    },
    { L_, "A0 E012 G3 E4",  0,     5,      { VE[0], VE[1], VE[2] }           },
    { L_, "A0 E01 H2 E34",  0,     5,      { VE[0], VE[1] }                  },
    { L_, "A0 E0 I1 E234",  0,     5,      { VE[0] }                         },
    { L_, "A0 J0 E1234",    0,     5,      { 0 }                             },
    { L_, "A0 E0 K1 E234",  0,     5,      { VE[0] }                         },
    { L_, "A0 E01 L2 E34",  0,     5,      { VE[0], VE[1] }                  },
    { L_, "A0 E01 M2 E34",  0,     5,      { VE[0], VE[1] }                  },
    { L_, "A0 E012 N3 E4",  0,     5,      { VE[0], VE[1], VE[2] }           },
    { L_, "A0 E0123 O4",    0,     5,      { VE[0], VE[1], VE[2], VE[3] }    },
    { L_, "A0 E012 P3 E4",  0,     5,      { VE[0], VE[1], VE[2] }           },
    { L_, "A0 E01 Q2 E34",  0,     5,      { VE[0], VE[1] }                  },
    { L_, "A0 E0 R1 E234",  0,     5,      { VE[0] }                         },
    { L_, "A0 S0 E1234",    0,     5,      { 0 }                             },
    { L_, "A0 E0 T1 E234",  0,     5,      { VE[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getUint16'." << endl;
        {
            typedef unsigned short ElemType;
            typedef bdex_TestInStreamFormatter&
                             (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint16;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "F01",            0,     2,      { 0 }                             },
    // valid streams with bdex_TestOutStreamFormatter version and version check
    // turned off
    { L_, "F0123",          1,     4,      { VF[0], VF[1], VF[2], VF[3] }    },
    { L_, "F4567",          1,     4,      { VF[4], VF[5], VF[6], VF[7] }    },
    // valid streams
    { L_, "A0 F0123",       0,     4,      { VF[0], VF[1], VF[2], VF[3] }    },
    { L_, "A0 F4567",       0,     4,      { VF[4], VF[5], VF[6], VF[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 F1234",    0,     5,      { 0 }                             },
    { L_, "A0 F0 B1 F234",  0,     5,      { VF[0] }                         },
    { L_, "A0 F01 C2 F34",  0,     5,      { VF[0], VF[1] }                  },
    { L_, "A0 F012 D3 F4",  0,     5,      { VF[0], VF[1], VF[2] }           },
    { L_, "A0 F0123 E4",    0,     5,      { VF[0], VF[1], VF[2], VF[3] }    },
    { L_, "A0 F012 G3 F4",  0,     5,      { VF[0], VF[1], VF[2] }           },
    { L_, "A0 F01 H2 F34",  0,     5,      { VF[0], VF[1] }                  },
    { L_, "A0 F0 I1 F234",  0,     5,      { VF[0] }                         },
    { L_, "A0 J0 F1234",    0,     5,      { 0 }                             },
    { L_, "A0 F0 K1 F234",  0,     5,      { VF[0] }                         },
    { L_, "A0 F01 L2 F34",  0,     5,      { VF[0], VF[1] }                  },
    { L_, "A0 F01 M2 F34",  0,     5,      { VF[0], VF[1] }                  },
    { L_, "A0 F012 N3 F4",  0,     5,      { VF[0], VF[1], VF[2] }           },
    { L_, "A0 F0123 O4",    0,     5,      { VF[0], VF[1], VF[2], VF[3] }    },
    { L_, "A0 F012 P3 F4",  0,     5,      { VF[0], VF[1], VF[2] }           },
    { L_, "A0 F01 Q2 F34",  0,     5,      { VF[0], VF[1] }                  },
    { L_, "A0 F0 R1 F234",  0,     5,      { VF[0] }                         },
    { L_, "A0 S0 F1234",    0,     5,      { 0 }                             },
    { L_, "A0 F0 T1 F234",  0,     5,      { VF[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 5: {
        // --------------------------------------------------------------------
        // GET 8-BIT INTEGERS TEST:
        //   See description of the testing mechanism in the above function
        //   description of 'testGetScalar'.  Note that getInt8(char&) is
        //   tested in the PRIMARY MANIPULATORS test.
        //
        // Testing:
        //   getInt8(signed char& variable);
        //   getUint8(char& variable);
        //   getUint8(unsigned char& variable);
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "GET 8-BIT INTEGERS TEST" << endl
                                  << "=======================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting 'getInt8' w/ 'signed char'." << endl;
        {
            typedef signed char ElemType;
            typedef bdex_TestInStreamFormatter&
                    (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt8;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // ** Cannot test stream without version, since version is of type INT8
    // valid streams without version and version check turned off
    { L_, "B0123",          1,     4,      { VB[0], VB[1], VB[2], VB[3] }    },
    { L_, "B4567",          1,     4,      { VB[4], VB[5], VB[6], VB[7] }    },
    // valid streams
    { L_, "A0 B0123",       0,     4,      { VB[0], VB[1], VB[2], VB[3] }    },
    { L_, "A0 B4567",       0,     4,      { VB[4], VB[5], VB[6], VB[7] }    },
    // streams containing incompatible data types
    { L_, "A0 C0 B1234",    0,     5,      { 0 }                             },
    { L_, "A0 B0 D1 B234",  0,     5,      { VB[0] }                         },
    { L_, "A0 B01 E2 B34",  0,     5,      { VB[0], VB[1] }                  },
    { L_, "A0 B012 F3 B4",  0,     5,      { VB[0], VB[1], VB[2] }           },
    { L_, "A0 B0123 G4",    0,     5,      { VB[0], VB[1], VB[2], VB[3] }    },
    { L_, "A0 B012 H3 B4",  0,     5,      { VB[0], VB[1], VB[2] }           },
    { L_, "A0 B01 I2 B34",  0,     5,      { VB[0], VB[1] }                  },
    { L_, "A0 B0 J1 B234",  0,     5,      { VB[0] }                         },
    { L_, "A0 K0 B1234",    0,     5,      { 0 }                             },
    { L_, "A0 B0 L1 B234",  0,     5,      { VB[0] }                         },
    { L_, "A0 B01 M2 B34",  0,     5,      { VB[0], VB[1] }                  },
    { L_, "A0 B012 N3 B4",  0,     5,      { VB[0], VB[1], VB[2] }           },
    { L_, "A0 B0123 O4",    0,     5,      { VB[0], VB[1], VB[2], VB[3] }    },
    { L_, "A0 B012 P3 B4",  0,     5,      { VB[0], VB[1], VB[2] }           },
    { L_, "A0 B01 Q2 B34",  0,     5,      { VB[0], VB[1] }                  },
    { L_, "A0 B0 R1 B234",  0,     5,      { VB[0] }                         },
    { L_, "A0 S0 B1234",    0,     5,      { 0 }                             },
    { L_, "A0 B0 T1 B234",  0,     5,      { VB[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'getUint8' w/ 'char'." << endl;
        {
            typedef unsigned char ElemType;
            typedef bdex_TestInStreamFormatter&
                     (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint8;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "C01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "C0123",          1,     4,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "C4567",          1,     4,      { VC[4], VC[5], VC[6], VC[7] }    },
    // valid streams
    { L_, "A0 C0123",       0,     4,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "A0 C4567",       0,     4,      { VC[4], VC[5], VC[6], VC[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 B1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 C01 E2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C012 F3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C0123 G4",    0,     5,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "A0 C012 H3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C01 I2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C0 J1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 K0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 L1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 C01 M2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C012 N3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C0123 O4",    0,     5,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "A0 C012 P3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C01 Q2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C0 R1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 S0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 T1 C234",  0,     5,      { VC[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }

        // --------------------------------------------------------------------

        if (verbose)cout << "\nTesting 'getUint8' w/ 'unsigned char'." << endl;
        {
            typedef unsigned char ElemType;
            typedef bdex_TestInStreamFormatter&
                     (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getUint8;

            static const ScalarTestTable<ElemType> DATA[] = {
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // stream with bdex_TestOutStreamFormatter version
    { L_, "D01",            0,     2,      { 0 }                             },
    // valid streams without version and version check turned off
    { L_, "D0123",          1,     4,      { VD[0], VD[1], VD[2], VD[3] }    },
    { L_, "D4567",          1,     4,      { VD[4], VD[5], VD[6], VD[7] }    },
    // valid streams
    { L_, "A0 D0123",       0,     4,      { VD[0], VD[1], VD[2], VD[3] }    },
    { L_, "A0 D4567",       0,     4,      { VD[4], VD[5], VD[6], VD[7] }    },
    // streams containing incompatible data types
    { L_, "A0 A0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 B1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 C01 E2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C012 F3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C0123 G4",    0,     5,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "A0 C012 H3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C01 I2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C0 J1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 K0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 L1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 C01 M2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C012 N3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C0123 O4",    0,     5,      { VC[0], VC[1], VC[2], VC[3] }    },
    { L_, "A0 C012 P3 C4",  0,     5,      { VC[0], VC[1], VC[2] }           },
    { L_, "A0 C01 Q2 C34",  0,     5,      { VC[0], VC[1] }                  },
    { L_, "A0 C0 R1 C234",  0,     5,      { VC[0] }                         },
    { L_, "A0 S0 C1234",    0,     5,      { 0 }                             },
    { L_, "A0 C0 T1 C234",  0,     5,      { VC[0] }                         },
            };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
        }
      } break;
      case 4: {
        // --------------------------------------------------------------------
        // BASIC ACCESSORS TEST:
        //   For each independent test, create objects containing various data.
        //   Use basic accessors to verify the initial state of the objects.
        //   Then use primary manipulators 'getInt8' and 'invalidate' to modify
        //   the state of the objects, and use basic accessors to verify the
        //   resulting state.
        //
        // Testing
        //   operator const void *() const;
        //   int length() const;
        //   int cursor() const;
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "BASIC ACCESSORS TEST" << endl
                                  << "====================" << endl;

        if (verbose) cout << "\nTesting 'operator const void *'." << endl;

        int i;

        for (i = 0; i < 3; ++i) {
            char localBuf[4]; // g++ 2.95 crashes if size is < 4
            bdesb_FixedMemInStreamBuf sb(localBuf, 2);
            bdex_TestInStreamFormatter x(&sb);
            int j;
            LOOP_ASSERT(i, x);

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);
            o.putInt8(VERSION);
            for (j = 0; j < i;  ++j)
                o.putInt8(j);

            bdesb_FixedMemInStreamBuf sb2(const_cast<char *>(osb.data()),
                                          osb.length());
            bdex_TestInStreamFormatter x2(&sb2);
            LOOP_ASSERT(i, x2);

            LOOP_ASSERT(i, x && x2);
            x.invalidate();
            LOOP_ASSERT(i, !x && x2);

            // invalidate stream x2 by making excessive 'get' calls
            char c;
            x2.setQuiet(1);
            for (j = 0; j < i + 10; ++j)
                x2.getInt8(c);
            LOOP_ASSERT(i, !x && !x2);
        }

        // --------------------------------------------------------------------

        if (verbose)
            cout << "\nTesting 'length' and 'cursor'." << endl;

        for (i = 0; i < 5; ++i) {
            // test default empty objects
            char junk;
            bdesb_FixedMemInStreamBuf sb(&junk, 0);
            bdex_TestInStreamFormatter x(&sb);
            int j;
            LOOP_ASSERT(i, x.length() == 0);
            LOOP_ASSERT(i, x.cursor() == 0);

            // test bdex_TestInStreamFormatters of variable lengths
            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);    o.putInt8(VERSION);
            for (j = 0; j < i;  ++j) o.putInt8(j);

            bdesb_FixedMemInStreamBuf sb2(const_cast<char *>(osb.data()),
                                          osb.length());
            bdex_TestInStreamFormatter x2(&sb2);
            if (veryVerbose) { P(x2) }
            LOOP_ASSERT(i,
                        x2.length() ==
                                                    osb.length());
            LOOP_ASSERT(i, x2.cursor() == 0);

            char c;
            x2.getInt8(c);  // get version
            for (j = 0; j < i; ++j) {
                const int EXP = VERSION_LEN + (SIZEOF_CODE + SIZEOF_INT8) * j;
                LOOP2_ASSERT(i, j, x2.cursor() == EXP);
                x2.getInt8(c);
            }
        }
      } break;
      case 3: {
        // --------------------------------------------------------------------
        // PRIMARY MANIPULATORS TEST:
        //   For testing 'getInt8', see description of the testing mechanism in
        //   the above function description of 'testGetScalar'.  For testing
        //   other manipulators, create objects containing various data, then
        //   use primary manipulators to modify the state of the objects.  Use
        //   basic accessors to verify the final state of the objects.
        //
        // Testing
        //   bdex_TestInStreamFormatter();
        //   bdex_TestInStreamFormatter(const char *buffer, int numBytes);
        //   ~bdex_TestInStreamFormatter();   // by purify
        //   setQuiet(int flag);
        //   setSuppressVersionCheck(int flag);
        //   getInt8(char& variable);
        //   void invalidate();
        //   bool isQuiet();
        //   bool isSuppressVersionCheck();
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "PRIMARY MANIPULATORS TEST" << endl
                                  << "=========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose)cout << "\nTesting 'getInt8' w/ 'char' and ctors." << endl;
        {
            typedef char ElemType;
            typedef bdex_TestInStreamFormatter&
                           (bdex_TestInStreamFormatter::*FuncPtr)(ElemType&);
            const FuncPtr FUNC = &bdex_TestInStreamFormatter::getInt8;

// The g++ 2.95 compiler crashes when compiling the static initialization
// of a table of ScalarTestTable<char>, so we use ScalarTestTable<uchar>
// instead, then cast the table to ScalarTestTable<char>*, below.
#if ! defined(BSLS_PLATFORM_CMP_GNU) || BSLS_PLATFORM_CMP_VER_MAJOR >= 30000
            static const ScalarTestTable<ElemType> DATA[] = {
#else
            static const ScalarTestTable<unsigned char> DATA[] = {
#endif // Gnu compiler bug
    //                     supp  # values   expected
    //L#  spec             ver   to read    values
    //--  ---------------  ----  ---------  ----------------------------------
    // read from empty stream
    { L_, "",               0,     1,      { 0 }                             },
    // ** Cannot test stream without version, since version is of type INT8
    // valid streams without version and version check turned off
    { L_, "A0123",          1,     4,      { VA[0], VA[1], VA[2], VA[3] }    },
    { L_, "A4567",          1,     4,      { VA[4], VA[5], VA[6], VA[7] }    },
    // valid streams
    { L_, "A0 A0123",       0,     4,      { VA[0], VA[1], VA[2], VA[3] }    },
    { L_, "A0 A4567",       0,     4,      { VA[4], VA[5], VA[6], VA[7] }    },
    // streams containing incompatible data types
    { L_, "A0 C0 A1234",    0,     5,      { 0 }                             },
    { L_, "A0 A0 D1 A234",  0,     5,      { VA[0] }                         },
    { L_, "A0 A01 E2 A34",  0,     5,      { VA[0], VA[1] }                  },
    { L_, "A0 A012 F3 A4",  0,     5,      { VA[0], VA[1], VA[2] }           },
    { L_, "A0 A0123 G4",    0,     5,      { VA[0], VA[1], VA[2], VA[3] }    },
    { L_, "A0 A012 H3 A4",  0,     5,      { VA[0], VA[1], VA[2] }           },
    { L_, "A0 A01 I2 A34",  0,     5,      { VA[0], VA[1] }                  },
    { L_, "A0 A0 J1 A234",  0,     5,      { VA[0] }                         },
    { L_, "A0 K0 A1234",    0,     5,      { 0 }                             },
    { L_, "A0 A0 L1 A234",  0,     5,      { VA[0] }                         }

        };
            const int DATA_LEN = sizeof DATA / sizeof *DATA;

#if ! defined(BSLS_PLATFORM_CMP_GNU) || BSLS_PLATFORM_CMP_VER_MAJOR >= 30000
            testGetScalar<ElemType, FuncPtr>(DATA, DATA_LEN, FUNC);
#else
            // Needed to use ScalarTestTable<uchar> instead of
            // ScalarTestTable<char> to avoid gcc internal error.  Now we cast
            // the table to correct type.
            testGetScalar<ElemType, FuncPtr>(
                (const ScalarTestTable<ElemType>*)DATA, DATA_LEN, FUNC);
#endif // Gnu compiler bug
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting 'invalidate'." << endl;
        for (int i = 0; i < 5; ++i) {
            // test default bdex_TestInStreamFormatters
            char localBuf[4]; // g++ 2.95 crashes if size is < 4
            bdesb_FixedMemInStreamBuf sb2(localBuf, 2);
            bdex_TestInStreamFormatter x(&sb2);
            LOOP_ASSERT(i, x);
            x.invalidate();
            LOOP_ASSERT(i, !x);

            // test objects of variable lengths
            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);    o.putInt8(VERSION);
            for (int j = 0; j < i;  ++j) o.putInt8(j);

            bdesb_FixedMemInStreamBuf sb(const_cast<char *>(osb.data()),
                                         osb.length());
            bdex_TestInStreamFormatter x2(&sb);
            if (veryVerbose) { P(x2) }
            LOOP_ASSERT(i, x2);
            x2.invalidate();
            LOOP_ASSERT(i, !x2);
        }

        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting get/set flags" << endl;
        {
            char localBuf[4]; // g++ 2.95 crashes if size is < 4
            bdesb_FixedMemInStreamBuf sb(localBuf, 2);
            bdex_TestInStreamFormatter x(&sb);
            ASSERT(0 == x.isQuiet());
            ASSERT(0 == x.isSuppressVersionCheck());

            if (verbose) cout << "\tQuiet" << endl;
            x.setQuiet(10);
            ASSERT(1 == x.isQuiet());
            ASSERT(0 == x.isSuppressVersionCheck());
            x.setQuiet(0);
            ASSERT(0 == x.isQuiet());
            ASSERT(0 == x.isSuppressVersionCheck());

            if (verbose) cout << "\tSuppressVersionCheck" << endl;
            x.setSuppressVersionCheck(10);
            ASSERT(0 == x.isQuiet());
            ASSERT(1 == x.isSuppressVersionCheck());
            x.setSuppressVersionCheck(0);
            ASSERT(0 == x.isQuiet());
            ASSERT(0 == x.isSuppressVersionCheck());
        }
      } break;
      case 2: {
        // --------------------------------------------------------------------
        // GENERATOR FUNCTION 'g' TEST:
        //   Perform independent tests with spec strings representative of the
        //   different possible formats for the 'g' function.  Generate
        //   "control" objects manually configured with the same sequence of
        //   operations as specified in the spec string.
        //   Verify the resulting output stream configured by the 'g' function
        //   contains the same content as the "control" object.
        //
        // Testing:
        //   int g(bdex_TestOutStreamFormatter* o, const char* spec)
        // --------------------------------------------------------------------
        if (verbose) cout << endl << "Generator Function 'g' TEST" << endl
                                  << "===========================" << endl;

        if (verbose) cout << endl
            << "Note:" << endl
            << "  Error messages can be viewed in veryVerbose mode" << endl;

        if (verbose) cout << "\nTesting empty spec." << endl;
        {
            const char *SPEC = "";
            bdesb_MemOutStreamBuf osb2;
            const bdex_TestOutStreamFormatter X(&osb2);
            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);
            int res = g(&o, SPEC);
            ASSERT(1 == res);
            ASSERT(osb2.length() == osb.length());
            ASSERT(0 == memcmp(osb2.data(),
                               osb.data(),
                               osb2.length()));
        }
        if (verbose) cout << "\nTesting spec w/ single operation." << endl;
        {
            const char *SPEC = "A012";
            if (veryVerbose) cout << "\tSPEC : \"" << SPEC << '"' << endl;
            bdesb_MemOutStreamBuf osb2;
            bdex_TestOutStreamFormatter mX(&osb2);
            mX.putInt8(VA[0]);
            mX.putInt8(VA[1]);
            mX.putInt8(VA[2]);

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);
            int res = g(&o, SPEC);
            ASSERT(1 == res);
            ASSERT(osb2.length() == osb.length());
            ASSERT(0 == memcmp(osb2.data(),
                               osb.data(),
                               osb2.length()));
        }
        if (verbose) cout << "\nTesting spec w/ spaces." << endl;
        {
            const char *SPEC = "  A01 \t 2  A3 \t";
            if (veryVerbose) cout << "\tSPEC : \"" << SPEC << '"' << endl;
            bdesb_MemOutStreamBuf osb2;
            bdex_TestOutStreamFormatter mX(&osb2);
            mX.putInt8(VA[0]);
            mX.putInt8(VA[1]);
            mX.putInt8(VA[2]);
            mX.putInt8(VA[3]);

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);
            int res = g(&o, SPEC);
            ASSERT(1 == res);
            ASSERT(osb2.length() == osb.length());
            ASSERT(0 == memcmp(osb2.data(),
                               osb.data(),
                               osb2.length()));
        }
        if (verbose) cout << "\nTesting spec w/ multiple operations." << endl;
        {
            const char *SPEC = "A0 B12 C0 D12 E345 F67 G8 H90 I123 J45 K6 L78";
            if (veryVerbose) cout << "\tSPEC : \"" << SPEC << '"' << endl;
            bdesb_MemOutStreamBuf osb2;
            bdex_TestOutStreamFormatter mX(&osb2);
            mX.putInt8(VA[0]);
            mX.putInt8(VB[1]);     mX.putInt8(VB[2]);
            mX.putUint8(VC[0]);
            mX.putUint8(VD[1]);    mX.putUint8(VD[2]);
            mX.putInt16(VE[3]);    mX.putInt16(VE[4]);    mX.putInt16(VE[5]);
            mX.putUint16(VF[6]);   mX.putUint16(VF[7]);
            mX.putInt32(VG[8]);
            mX.putUint32(VH[9]);   mX.putUint32(VH[0]);
            mX.putInt64(VI[1]);    mX.putInt64(VI[2]);    mX.putInt64(VI[3]);
            mX.putUint64(VJ[4]);   mX.putUint64(VJ[5]);
            mX.putFloat32(VK[6]);
            mX.putFloat64(VL[7]);  mX.putFloat64(VL[8]);

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);
            int res = g(&o, SPEC);
            ASSERT(1 == res);
            ASSERT(osb2.length() == osb.length());
            ASSERT(0 == memcmp(osb2.data(),
                               osb.data(),
                               osb2.length()));
        }
        if (verbose)
            cout << "\nTesting spec w/ single array operation." << endl;
        {
            int i;
            // test spec's of "a0", "a1", "a2"...
            for (i = 0; i < 3; ++i) {
                static char spec[10];    memset((void *) spec, 0, 10);
                sprintf(spec, "a%d", i);
                if (veryVerbose) cout << "\tSPEC : \"" << spec << '"' << endl;
                bdesb_MemOutStreamBuf osb2;
                bdex_TestOutStreamFormatter mX(&osb2);
                mX.putArrayInt8(VA, i);

                bdesb_MemOutStreamBuf osb;
                bdex_TestOutStreamFormatter o(&osb);
                int res = g(&o, spec);
                ASSERT(1 == res);
                ASSERT(osb2.length() == osb.length());
                ASSERT(0 == memcmp(osb2.data(),
                                   osb.data(),
                                   osb2.length()));
            }

            const char *SPEC = "a012";
            if (veryVerbose) cout << "\tSPEC : \"" << SPEC << '"' << endl;
            bdesb_MemOutStreamBuf osb2;
            bdex_TestOutStreamFormatter mX(&osb2);
            for (i = 0; i < 3; ++i) mX.putArrayInt8(VA, i);

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);
            int res = g(&o, SPEC);
            ASSERT(1 == res);
            ASSERT(osb2.length() == osb.length());
            ASSERT(0 == memcmp(osb2.data(),
                               osb.data(),
                               osb2.length()));
        }
        if (verbose)
            cout << "\nTesting spec w/ multiple array operations." << endl;
        {
            const char *SPEC = "a1 b2 c2 d2 e3 f4 g5 h6 i7 j8 k9 l1";
            if (veryVerbose) cout << "\tSPEC : \"" << SPEC << '"' << endl;
            bdesb_MemOutStreamBuf osb2;
            bdex_TestOutStreamFormatter mX(&osb2);
            mX.putArrayInt8(VA, 1);
            mX.putArrayInt8(VB, 2);
            mX.putArrayUint8(VC, 2);
            mX.putArrayUint8(VD, 2);
            mX.putArrayInt16(VE, 3);
            mX.putArrayUint16(VF, 4);
            mX.putArrayInt32(VG, 5);
            mX.putArrayUint32(VH, 6);
            mX.putArrayInt64(VI, 7);
            mX.putArrayUint64(VJ, 8);
            mX.putArrayFloat32(VK, 9);
            mX.putArrayFloat64(VL, 1);

            bdesb_MemOutStreamBuf osb;
            bdex_TestOutStreamFormatter o(&osb);
            int res = g(&o, SPEC);
            ASSERT(1 == res);
            ASSERT(osb2.length() == osb.length());
            ASSERT(0 == memcmp(osb2.data(),
                               osb.data(),
                               osb2.length()));
        }
        if (verbose) cout << "\nTesting invalid specs." << endl;
        {
            const char *SPEC[] = {
                "a",
                "1",
                "a1 b2 Cf3 F4",
                "A0 B2 CC",
                "1A B2 E3"
                };
            const int NUM_TEST = sizeof SPEC / sizeof *SPEC;
            for (int i = 0; i < NUM_TEST; ++i) {
                if (veryVerbose)
                    cout << "\tSPEC : \"" << SPEC[i] << '"' << endl;
                bdesb_MemOutStreamBuf osb;
                bdex_TestOutStreamFormatter o(&osb);
                int res = g(&o, SPEC[i]);
                ASSERT(0 == res);
            }
        }
      } break;
      case 1: {
        // --------------------------------------------------------------------
        // BREATHING TEST:
        //   Create 'bdex_TestInStreamFormatter' bdex_TestInStreamFormatter
        //   containing various data.
        //   Exercise these bdex_TestInStreamFormatter using appropriate
        //   input methods and primary manipulators, then verify the state of
        //   the resulting bdex_TestInStreamFormatters using basic accessors.
        //
        // Testing:
        //   This "test" exercises basic functionality, but tests nothing.
        // --------------------------------------------------------------------

        if (verbose) cout << endl << "BREATHING TEST" << endl
                                  << "==============" << endl;

        if (verbose) cout <<
                 "\nCreate bdex_TestInStreamFormatter x2 w/ an initial value."
                          << endl;
        int i;
        bdesb_MemOutStreamBuf osb;
        bdex_TestOutStreamFormatter o(&osb);
        o.putInt8(VERSION);
        for (i = 0; i < 5; ++i) o.putInt8(i);

        bdesb_FixedMemInStreamBuf sb(const_cast<char *>(osb.data()),
                                     osb.length());
        bdex_TestInStreamFormatter x2(&sb);
        ASSERT(osb.length() == x2.length());

        if (verbose) cout << "\nTry getInt8() with x2." << endl;
        char c;
        x2.getInt8(c);  // get version
        for (i = 0; i < 5; ++i) {
            x2.getInt8(c);
            LOOP_ASSERT(i, i == c);
        }

        if (verbose) cout << "\nTry invalidate() with x2." << endl;
        x2.invalidate();
        ASSERT(!x2);

        if (verbose) cout <<
                    "\nTry invalid operation with new stream x1." << endl;
        char localBuf[4]; // g++ 2.95 crashes if size is < 4
        bdesb_FixedMemInStreamBuf sb2(localBuf, 2);
        bdex_TestInStreamFormatter x1(&sb2);
        x1.setSuppressVersionCheck(1);
        x1.setQuiet(1);
        ASSERT(x1);
        x1.getInt32(i);
        ASSERT(!x1);
      } break;
      default: {
        cerr << "WARNING: CASE `" << test << "' NOT FOUND." << endl;
        testStatus = -1;
      }
    }

    if (testStatus > 0) {
        cerr << "Error, non-zero test status = " << testStatus << "." << endl;
    }
    return testStatus;
}

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2002
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
