// bdede_charconvertutf32.t.cpp                                       -*-C++-*-

#include <bdede_charconvertutf32.h>

#include <bdede_charconvertstatus.h>

#include <bdeu_random.h>

#include <bslma_testallocator.h>
#include <bslmf_issame.h>
#include <bsls_stopwatch.h>

#include <bsl_algorithm.h>
#include <bsl_iomanip.h>
#include <bsl_iostream.h>
#include <bsl_sstream.h>

#include <bsl_cstring.h>
#include <bsl_cctype.h>

using namespace BloombergLP;

using bsl::cout;
using bsl::cerr;
using bsl::endl;
using bsl::flush;

//===========================================================================
//                                TEST PLAN
//---------------------------------------------------------------------------
//CONCERNS:
//  1) Do not overwrite memory (a) outside the assigned range, nor (b) beyond
//     what you say you have written.  ((b) overlaps with (2a).)
//
//  2) Provide the correct (a) direct return value and (b) return-through-
//     parameter values (when called for).  (c) The null/non-null distinction
//     for the return for parameter values must not affect the operation in
//     any other way.
//
//  3) Do not damage the input string.  (The parameter is 'const', so damage
//     would require deliberate action.)
//
//  4) Create a properly null-terminated string on the output whenever there
//     is room to write anything at all to the output.
//
//  5) Correctly convert every one-character value, of however many
//     bytes/words (in each direction).
//
//  6) (a) Correctly recognize every possible type of input string error
//     (forbidden range, invalid code sequence, etc.) and, when appropriate,
//     write the given error indicator into the output string.  (Note that
//     2a, 2b, and 2c apply here especially, since the error indicator's
//     presence or absence will change the write-counts.)  (b) Verify that
//     the preceding and subsequent characters are handled properly.
//
//  7) Considering all characters that require a given encoding (2-byte,
//     single-word, etc.) to represent an equivalence class for that coding
//     sequence, handle all the possible 'digraphs' and 'trigraphs' of those
//     equivalence classes, and possibly larger sequences.  The test should
//     use varying characters (bit patterns) within each encoding class.
//
//  8) As in (7), but adding the various types of input string error to the
//     set of equivalence classes.  (A 2-byte encoding cut short before
//     another character is not the same as a 3-byte encoding cut short at the
//     end of the string, etc.)  This creates a very large 'alphabet' on which
//     to test strings, but it is important to test that re-sync works
//     properly and that every case consumes at least one input byte or word so
//     that no infinite loop can occur.
//
//  9) Performance: it is highly desirable that the single-byte, single-word
//     case run fast.  There should be a negative test that can be run to
//     confirm that (a) it is faster than the more interesting cases and (b)
//     its performance more closely resembles a byte-to-word or word-to-byte
//     copy than it resembles the performance of more interesting cases.
//
// 10) The combinatorics of these tests, especially (8), could lead to very
//     long run-times if they are not carefully designed.  (5) involves
//     1,114,112 possible iso10646 code values, of which one is null and
//     2048 are invalid (because in utf16 they represent words of two-word
//     encodings) (1,112,063 valid code values).  Once this full test is
//     accomplished, subsequent tests should involve boundary cases and
//     representative, varying values within equivalence classes.
//
//  Translating CONCERNS into tests:
//     Concerns 1 - 4 are basic correctness requirements, and should be
//     checked for all tests, except that 2c multiplies the number of test
//     cases, and should not be applied to tests with a large number of
//     cases.  This does not preclude running some of those cases with one
//     setting and some with another, but large case sets should not be
//     repeated to verify 2c.
//
//     Checking concern 3 requires making copies of the input string and
//     doing comparisons (or running any generating code as comparison code).
//     It probably should be run on all the basic cases and on a limited
//     number of the more complex cases.  (Adjacent memory areas should
//     be checked as well, i.e., the input region should be surrounded by
//     additional memory to be checked.)
//
//     Concerns 5-8 involve increasing complexity and number of cases.  Using
//     equivalence classes, boundary values, and varying non-boundary values
//     should provide strong coverage while holding the number of cases to
//     what can be run routinely.  It must be possible to verify that the
//     values are varying appropriately by using flags of high verbosity.
//
//     Concern 9 requires testing on a processor and operating system that
//     can accurately and reproducibly report processor usage.  (Linux and
//     Windows are disqualified.)  It also may require some control over
//     other things running at the time.  Thus it should be a 'negative'
//     test case intended for manual use only.
//

// --- Convert-forward/convert-back tests on large data sets are possible.
// --- (Generate valid iso10646, turn into utf16, convert to utf8 and back.)

//
//                                Overview
//                                --------
// Exercise boundary cases for both of the conversion mappings as well as
// handling of buffer capacity issues.
//---------------------------------------------------------------------------
// [ 3] utf8ToUtf16
// [ 4] utf16ToUtf8
//---------------------------------------------------------------------------
// [ 1] Breathing test: Enumeration
// [ 2] Conversion does not vary when the return-via-pointer pointers are
//      nulled or made non-null.
// [ 3] All legal characters are properly converted.
// [ 4] All error cases are recognized (testing in isolation)
// [ 5] All possible sequences (trigraphs) of legal codings (one-octet vs.
//      three-octet, one word vs. two word) are handled properly.
// [ 6] All possible sequences (trigraphs) of legal codings and error cases
//      are handled properly.

// SERIOUS THING TO FIX: The tests use varying values for 'BUFFER_ZONE'
// and the value is NOT passed from the place that allocates the space to the
// place that does the work.

//==========================================================================
//              MODIFIED "STANDARD" BDE ASSERT TEST MACRO
//--------------------------------------------------------------------------

// There are two changes here.  First, the variable 'testStatus' and the
// function 'aSsErT' are moved into the anonymous namespace; previously
// they were file-level static.  The Sun compiler (Suite 8) did not believe
// that file-level statics should be visible in a template function.
// Second, the function and macro are changed so that they constitute an
// expression that returns 'true' if the test passes and 'false' otherwise.
// This allows verbose flags to govern additional error reporting when a
// failure occurs.

namespace {
int testStatus = 0;
int testFailures = 0;
int testFailureLim = 100;        // <0 => no limit.

bool aSsErT(int c, const char *s, int i)
{
    if (c) {
        cout << "Error " << __FILE__ << "(" << i << "): " << s
             << "    (failed)" << endl;
        if (testStatus >= 0 && testStatus <= 100)
            ++testStatus;

        ++testFailures;
        if (testFailureLim >= 0
         && testFailures > testFailureLim)
            exit(1);
    }
    return c == 0;
}

}  // close unnamed namespace

#define ASSERT(X) ( aSsErT(!(X), #X, __LINE__) )

//===========================================================================
//                  STANDARD BDE LOOP-ASSERT TEST MACROS
//---------------------------------------------------------------------------

#define LOOP_ASSERT(I,X) { \
   if (!(X)) { cout << #I << ": " << I << "\n"; aSsErT(1, #X, __LINE__); }}

#define LOOP2_ASSERT(I,J,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " \
              << J << "\n"; aSsErT(1, #X, __LINE__); } }

#define LOOP3_ASSERT(I,J,K,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" \
              << #K << ": " << K << "\n"; aSsErT(1, #X, __LINE__); } }

#define LOOP4_ASSERT(I,J,K,L,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" << \
       #K << ": " << K << "\t" << #L << ": " << L << "\n"; \
       aSsErT(1, #X, __LINE__); } }

#define LOOP5_ASSERT(I,J,K,L,M,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" << \
       #K << ": " << K << "\t" << #L << ": " << L << "\t" << \
       #M << ": " << M << "\n"; \
       aSsErT(1, #X, __LINE__); } }

#define LOOP6_ASSERT(I,J,K,L,M,N,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" << \
       #K << ": " << K << "\t" << #L << ": " << L << "\t" << \
       #M << ": " << M << "\t" << #N << ": " << N << "\n"; \
       aSsErT(1, #X, __LINE__); } }

//=============================================================================
//                  SEMI-STANDARD TEST OUTPUT MACROS
//-----------------------------------------------------------------------------

#define P(X) cout << #X " = " << (X) << endl; // Print identifier and value.
#define Q(X) cout << "<| " #X " |>" << endl;  // Quote identifier literally.
#define P_(X) cout << #X " = " << (X) << ", "<< flush; // P(X) without '\n'
#define L_ __LINE__                           // current Line number
#define T_ cout << "\t" << flush;             // Print tab w/o newline

//=============================================================================
//                         CUSTOM TEST OUTPUT MACROS
//-----------------------------------------------------------------------------

#define R(X) #X " = " << (X)
#define R_(X) #X " = " << (X) << " "

//=============================================================================
//                               GLOBAL TYPEDEFS
//-----------------------------------------------------------------------------

typedef bdede_CharConvertUtf32  Util;
typedef bdede_CharConvertStatus Status;

//=============================================================================
//                           CUSTOM TEST APPARATUS
//-----------------------------------------------------------------------------

bool verbose;
bool veryVerbose;
bool veryVeryVerbose;
bool veryVeryVeryVerbose;
bool veryVeryVeryVeryVerbose;

const void *hx(unsigned val)
    // Cast 'val' to 'void *' so it will be printed in hex
{
    return (const void *) val;
}

unsigned char utf8MultiLang[] = {
    239, 187, 191, 'C', 'h', 'i', 'n', 'e', 's', 'e', ':',  13,
     10,  13,  10, 228, 184, 173, 229, 141, 142, 228, 186, 186,
    230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 155, 189,
    239, 188, 140, 233, 128, 154, 231, 167, 176, 228, 184, 173,
    229, 155, 189, '[', 230, 179, 168, ' ', '3', ']', 239, 188,
    140, 230, 152, 175, 228, 189, 141, 230, 150, 188, 228, 186,
    154, 230, 180, 178, 230, 157, 177, 233, 131, 168, 227, 128,
    129, 229, 164, 170, 229, 185, 179, 230, 180, 139, 232, 165,
    191, 229, 178, 184, 231, 154, 132, 228, 184, 128, 228, 184,
    170, 231, 164, 190, 228, 188, 154, 228, 184, 187, 228, 185,
    137, 229, 155, 189, 229, 174, 182, 227, 128, 130, 233, 166,
    150, 233, 131, 189, 231, 130, 186, 229, 140, 151, 228, 186,
    172, 227, 128, 130, 229, 133, 182, 233, 153, 134, 229, 156,
    176, 231, 150, 134, 229, 159, 159, 232, 136, 135, 229, 145,
    168, 233, 130, 138, '1', '4', 229, 128, 139, 229, 156, 139,
    229, 174, 182, 230, 142, 165, 229, 163, 164, 239, 188, 140,
    233, 153, 134, 229, 156, 176, 229, 143, 138, 230, 185, 150,
    230, 179, 138, 231, 154, 132, 230, 128, 187, 233, 157, 162,
    231, 169, 141, 231, 186, 166, '9', '6', '0', 232, 144, 172,
    229, 185, 179, 230, 150, 185, 229, 133, 172, 233, 135, 140,
    '[', '1', '1', ']', '[', '1', '2', ']', '[', '1', '3', ']',
    239, 188, 140, 230, 152, 175, 229, 133, 168, 228, 184, 150,
    231, 149, 140, 233, 153, 134, 229, 156, 176, 233, 157, 162,
    231, 167, 175, 231, 172, 172, 228, 186, 140, 229, 164, 167,
    231, 154, 132, 229, 155, 189, 229, 174, 182, 239, 188, 140,
    230, 128, 187, 233, 157, 162, 231, 167, 175, 231, 172, 172,
    228, 184, 137, 230, 136, 150, 231, 172, 172, 229, 155, 155,
    229, 164, 167, 231, 154, 132, 229, 155, 189, 229, 174, 182,
    227, 128, 130, 229, 133, 182, 228, 186, 186, 229, 143, 163,
    232, 182, 133, 233, 129, 142, '1', '3', 229, 132, 132, 239,
    188, 140, 231, 180, 132, 228, 189, 148, 229, 133, 168, 231,
    144, 131, 228, 186, 186, 229, 143, 163, 231, 154, 132, 228,
    186, 148, 229, 136, 134, 228, 185, 139, 228, 184, 128, 239,
    188, 140, 230, 152, 175, 228, 184, 150, 231, 149, 140, 228,
    184, 138, 228, 186, 186, 229, 143, 163, 230, 156, 128, 229,
    164, 154, 231, 154, 132, 229, 156, 139, 229, 174, 182, 227,
    128, 130,  13,  10,  13,  10, 228, 189, 156, 231, 130, 186,
    231, 164, 190, 228, 188, 154, 228, 184, 187, 228, 185, 137,
    229, 155, 189, 229, 174, 182, 239, 188, 140, 228, 184, 173,
    232, 143, 175, 228, 186, 186, 230, 176, 145, 229, 133, 177,
    229, 146, 140, 229, 156, 139, 228, 187, 165, 233, 169, 172,
    229, 133, 139, 230, 128, 157, 229, 136, 151, 229, 174, 129,
    228, 184, 187, 228, 185, 137, 231, 130, 186, 230, 132, 143,
    232, 173, 152, 229, 189, 162, 230, 133, 139, 239, 188, 140,
    228, 190, 157, 228, 184, 173, 229, 156, 139, 231, 137, 185,
    232, 137, 178, 231, 164, 190, 230, 156, 131, 228, 184, 187,
    231, 190, 169, 231, 144, 134, 232, 174, 186, 230, 140, 135,
    229, 176, 142, 230, 148, 191, 228, 186, 139, 239, 188, 140,
    229, 185, 182, 231, 148, 177, 230, 134, 178, 230, 179, 149,
    230, 137, 128, 232, 179, 166, 228, 186, 136, 228, 184, 173,
    229, 155, 189, 229, 133, 177, 228, 186, 167, 229, 133, 154,
    229, 159, 183, 230, 148, 191, 239, 188, 140, 229, 174, 158,
    232, 161, 140, 228, 184, 173, 229, 155, 189, 229, 133, 177,
    228, 186, 167, 229, 133, 154, 233, 162, 134, 229, 175, 188,
    231, 154, 132, 229, 164, 154, 229, 133, 154, 229, 144, 136,
    228, 189, 156, 229, 146, 140, 230, 148, 191, 230, 178, 187,
    229, 141, 143, 229, 149, 134, 229, 136, 182, 229, 186, 166,
    '[', '1', '4', ']', 227, 128, 130, '1', '9', '4', '9', 229,
    185, 180, '1', '0', 230, 156, 136, '1', 230, 151, 165, 231,
    154, 132, 229, 188, 128, 229, 155, 189, 229, 164, 167, 229,
    133, 184, 228, 184, 173, 239, 188, 140, 228, 184, 173, 229,
    141, 142, 228, 186, 186, 230, 176, 145, 229, 133, 177, 229,
    146, 140, 229, 155, 189, 228, 184, 173, 229, 164, 174, 228,
    186, 186, 230, 176, 145, 230, 148, 191, 229, 186, 156, 230,
    173, 163, 229, 188, 143, 229, 174, 163, 229, 145, 138, 230,
    136, 144, 231, 171, 139, '[', 230, 179, 168, ' ', '4', ']',
    227, 128, 130, 229, 133, 168, 229, 156, 139, 229, 138, 131,
    229, 136, 134, 231, 130, 186, '2', '3', 229, 128, 139, 231,
    156, 129, 239, 188, 136, 229, 133, 182, 228, 184, 173, 229,
    185, 182, 230, 178, 161, 230, 156, 137, 229, 175, 185, 229,
    143, 176, 230, 185, 190, 231, 156, 129, 229, 133, 168, 233,
    131, 168, 228, 184, 142, 231, 166, 143, 229, 187, 186, 231,
    156, 129, 227, 128, 129, 230, 181, 183, 229, 141, 151, 231,
    156, 129, 233, 131, 168, 229, 136, 134, 229, 156, 176, 229,
    140, 186, 229, 174, 158, 233, 153, 133, 231, 174, 161, 232,
    190, 150, 239, 188, 137, 227, 128, 129, '5', 229, 128, 139,
    232, 135, 170, 230, 178, 187, 229, 141, 128, 227, 128, 129,
    '4', 229, 128, 139, 231, 155, 180, 232, 190, 150, 229, 184,
    130, 229, 146, 140, '2', 229, 128, 139, 231, 137, 185, 229,
    136, 165, 232, 161, 140, 230, 148, 191, 229, 140, 186, 239,
    188, 136, 229, 141, 179, 233, 166, 153, 230, 184, 175, 232,
    136, 135, 230, 190, 179, 233, 150, 128, 239, 188, 137, 239,
    188, 140, 231, 156, 129, 231, 186, 167, 228, 186, 186, 230,
    176, 145, 230, 148, 191, 229, 186, 156, 229, 143, 151, 229,
    155, 189, 229, 138, 161, 233, 153, 162, 233, 162, 134, 229,
    175, 188, 239, 188, 140, 231, 137, 185, 229, 136, 165, 232,
    161, 140, 230, 148, 191, 229, 141, 128, 229, 137, 135, 230,
    160, 185, 230, 147, 154, 228, 184, 128, 229, 156, 139, 229,
    133, 169, 229, 136, 182, 230, 148, 191, 231, 173, 150, 229,
    175, 166, 232, 161, 140, 233, 171, 152, 229, 186, 166, 232,
    135, 170, 230, 178, 187, 227, 128, 130, 229, 133, 168, 229,
    155, 189, 232, 183, 168, 232, 182, 138, 228, 186, 148, 228,
    184, 170, 229, 156, 176, 231, 144, 134, 230, 151, 182, 229,
    140, 186, 239, 188, 140, 228, 189, 134, 229, 157, 135, 228,
    189, 191, 231, 148, 168, 228, 184, 173, 229, 156, 139, 230,
    168, 153, 230, 186, 150, 230, 153, 130, 233, 150, 147, 239,
    188, 136, 229, 141, 179, 'U', 'T', 'C', '+', '8', 239, 188,
    137, 227, 128, 130,  13,  10,  13,  10, 228, 184, 173, 232,
    143, 175, 228, 186, 186, 230, 176, 145, 229, 133, 177, 229,
    146, 140, 229, 156, 139, 230, 152, 175, 229, 164, 154, 230,
    176, 145, 230, 151, 143, 229, 155, 189, 229, 174, 182, 239,
    188, 140, 229, 133, 182, 228, 184, 173, 230, 177, 137, 230,
    151, 143, 228, 189, 148, 231, 184, 189, 228, 186, 186, 229,
    143, 163, 231, 154, 132, '9', '1', '.', '5', '9', '%', 239,
    188, 140, 229, 133, 182, 233, 164, 152, '5', '5', 228, 184,
    170, 230, 176, 145, 230, 151, 143, 231, 130, 186, 229, 176,
    145, 230, 149, 176, 230, 176, 145, 230, 151, 143, 239, 188,
    140, 229, 155, 189, 229, 174, 182, 232, 170, 141, 229, 174,
    154, 231, 154, 132, '5', '6', 229, 128, 139, 230, 176, 145,
    230, 151, 143, 229, 144, 136, 231, 167, 176, 226, 128, 156,
    228, 184, 173, 229, 141, 142, 230, 176, 145, 230, 151, 143,
    226, 128, 157, 227, 128, 130, 228, 184, 173, 229, 141, 142,
    228, 186, 186, 230, 176, 145, 229, 133, 177, 229, 146, 140,
    229, 155, 189, 230, 156, 137, '2', '4', 231, 167, 141, 230,
    176, 145, 230, 151, 143, 230, 150, 135, 229, 173, 151, 239,
    188, 140, 229, 133, 171, 229, 141, 129, 229, 164, 154, 231,
    167, 141, 230, 176, 145, 230, 151, 143, 232, 175, 173, 232,
    168, 128, 227, 128, 130, 228, 184, 173, 229, 141, 142, 228,
    186, 186, 230, 176, 145, 229, 133, 177, 229, 146, 140, 229,
    155, 189, 230, 178, 161, 230, 156, 137, 230, 152, 142, 231,
    161, 174, 232, 167, 132, 229, 174, 154, 231, 154, 132, 229,
    155, 189, 229, 174, 182, 232, 175, 173, 232, 168, 128, 239,
    188, 140, 228, 187, 165, 230, 177, 137, 232, 175, 173, 230,
    153, 174, 233, 128, 154, 232, 175, 157, 229, 146, 140, 232,
    167, 132, 232, 140, 131, 231, 174, 128, 229, 140, 150, 230,
    177, 137, 229, 173, 151, 228, 184, 186, 226, 128, 156, 229,
    155, 189, 229, 174, 182, 233, 128, 154, 231, 148, 168, 232,
    175, 173, 232, 168, 128, 230, 150, 135, 229, 173, 151, 226,
    128, 157, '[', 230, 179, 168, ' ', '5', ']', 227, 128, 130,
    228, 184, 173, 229, 155, 189, 228, 188, 160, 231, 187, 159,
    228, 184, 138, 230, 152, 175, 228, 187, 165, 231, 165, 150,
    229, 133, 136, 228, 191, 161, 228, 187, 176, 228, 184, 186,
    228, 184, 187, 231, 154, 132, 229, 155, 189, 229, 174, 182,
    239, 188, 140, 229, 185, 182, 229, 133, 183, 230, 156, 137,
    229, 132, 146, 233, 135, 138, 233, 129, 147, 228, 184, 137,
    230, 149, 153, 229, 144, 136, 230, 181, 129, 231, 154, 132,
    229, 174, 151, 230, 149, 153, 228, 191, 161, 228, 187, 176,
    228, 188, 160, 231, 187, 159, 229, 146, 140, 231, 137, 185,
    231, 130, 185, 239, 188, 140, 229, 144, 140, 230, 151, 182,
    229, 173, 152, 229, 156, 168, 229, 133, 182, 229, 174, 131,
    229, 164, 154, 231, 167, 141, 229, 174, 151, 230, 149, 153,
    227, 128, 130, 228, 184, 173, 229, 141, 142, 228, 186, 186,
    230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 155, 189,
    229, 144, 142, 239, 188, 140, 229, 174, 152, 230, 150, 185,
    229, 165, 137, 232, 161, 140, 230, 151, 160, 231, 165, 158,
    232, 174, 186, 239, 188, 140, 229, 133, 182, 229, 144, 142,
    230, 155, 190, 229, 143, 145, 229, 138, 168, 231, 154, 132,
    230, 150, 135, 229, 140, 150, 229, 164, 167, 233, 157, 169,
    229, 145, 189, 229, 175, 185, 229, 144, 132, 231, 167, 141,
    229, 174, 151, 230, 149, 153, 233, 128, 160, 230, 136, 144,
    228, 184, 165, 233, 135, 141, 231, 160, 180, 229, 157, 143,
    239, 188, 140, 231, 155, 180, 229, 136, 176, 230, 148, 185,
    233, 157, 169, 229, 188, 128, 230, 148, 190, 229, 144, 142,
    230, 137, 141, 230, 156, 137, 230, 137, 128, 232, 189, 172,
    229, 143, 152, 227, 128, 130, 229, 189, 147, 228, 187, 138,
    228, 184, 173, 229, 155, 189, 230, 148, 191, 229, 186, 156,
    229, 175, 185, 229, 174, 151, 230, 149, 153, 228, 184, 142,
    228, 188, 160, 231, 187, 159, 228, 186, 139, 231, 137, 169,
    233, 135, 135, 229, 143, 150, 228, 191, 157, 230, 138, 164,
    231, 154, 132, 230, 128, 129, 229, 186, 166, 227, 128, 130,
     13,  10,  13,  10, 228, 184, 173, 229, 141, 142, 228, 186,
    186, 230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 155,
    189, 230, 152, 175, 229, 155, 189, 233, 153, 133, 231, 164,
    190, 228, 188, 154, 231, 154, 132, 233, 135, 141, 232, 166,
    129, 228, 184, 128, 229, 145, 152, 239, 188, 140, 228, 185,
    159, 230, 152, 175, 228, 188, 151, 229, 164, 154, 230, 173,
    163, 229, 188, 143, 229, 146, 140, 233, 157, 158, 230, 173,
    163, 229, 188, 143, 231, 154, 132, 229, 164, 154, 232, 190,
    185, 231, 187, 132, 231, 187, 135, 231, 154, 132, 230, 136,
    144, 229, 145, 152, 239, 188, 140, 229, 140, 133, 230, 139,
    172, 232, 129, 148, 229, 144, 136, 229, 155, 189, 227, 128,
    129, 228, 184, 150, 231, 149, 140, 232, 180, 184, 230, 152,
    147, 231, 187, 132, 231, 187, 135, 227, 128, 129, 228, 186,
    154, 229, 164, 170, 231, 187, 143, 229, 144, 136, 231, 187,
    132, 231, 187, 135, 227, 128, 129, 233, 135, 145, 231, 160,
    150, 229, 155, 155, 229, 155, 189, 227, 128, 129, 228, 184,
    138, 230, 181, 183, 229, 144, 136, 228, 189, 156, 231, 187,
    132, 231, 187, 135, 229, 146, 140, '2', '0', 229, 155, 189,
    233, 155, 134, 229, 155, 162, 231, 173, 137, 239, 188, 140,
    228, 184, 186, 232, 129, 148, 229, 144, 136, 229, 155, 189,
    229, 174, 137, 229, 133, 168, 231, 144, 134, 228, 186, 139,
    228, 188, 154, 229, 184, 184, 228, 187, 187, 231, 144, 134,
    228, 186, 139, 229, 155, 189, 227, 128, 129, 228, 184, 150,
    231, 149, 140, 231, 172, 172, 228, 186, 140, 229, 164, 167,
    231, 187, 143, 230, 181, 142, 228, 189, 147, 239, 188, 140,
    230, 152, 175, 228, 184, 150, 231, 149, 140, 231, 172, 172,
    228, 184, 128, 229, 164, 167, 229, 135, 186, 229, 143, 163,
    229, 156, 139, 227, 128, 129, 228, 184, 150, 231, 149, 140,
    231, 172, 172, 228, 186, 140, 229, 164, 167, 233, 128, 178,
    229, 143, 163, 229, 156, 139, 239, 188, 140, 230, 147, 129,
    230, 156, 137, 230, 156, 128, 229, 164, 154, 231, 154, 132,
    229, 164, 150, 230, 177, 135, 229, 132, 178, 229, 130, 153,
    239, 188, 140, 230, 156, 128, 228, 184, 176, 229, 175, 140,
    231, 154, 132, 228, 184, 150, 231, 149, 140, 230, 150, 135,
    229, 140, 150, 233, 129, 151, 228, 186, 167, 239, 188, 140,
    228, 186, 166, 230, 152, 175, 228, 184, 150, 231, 149, 140,
    228, 184, 138, 231, 187, 143, 230, 181, 142, 230, 136, 144,
    233, 149, 183, 230, 156, 128, 229, 191, 171, 231, 154, 132,
    229, 156, 139, 229, 174, 182, 228, 185, 139, 228, 184, 128,
    227, 128, 130, 229, 143, 166, 229, 164, 150, 239, 188, 140,
    228, 184, 173, 229, 155, 189, 230, 139, 165, 230, 156, 137,
    228, 184, 150, 231, 149, 140, 228, 184, 138, 231, 142, 176,
    229, 189, 185, 229, 163, 171, 229, 133, 181, 230, 156, 128,
    229, 164, 154, 231, 154, 132, 229, 134, 155, 233, 152, 159,
    239, 188, 155, 229, 134, 155, 228, 186, 139, 229, 188, 128,
    230, 148, 175, 228, 184, 150, 231, 149, 140, 231, 172, 172,
    228, 186, 140, 239, 188, 140, 230, 139, 165, 230, 156, 137,
    230, 160, 184, 230, 173, 166, 229, 153, 168, 239, 188, 140,
    229, 185, 182, 229, 133, 183, 229, 164, 135, 229, 143, 145,
    229, 176, 132, 229, 141, 171, 230, 152, 159, 227, 128, 129,
    232, 175, 149, 233, 170, 140, 229, 158, 139, 231, 169, 186,
    233, 151, 180, 231, 171, 153, 229, 146, 140, 230, 156, 136,
    231, 144, 131, 229, 143, 138, 230, 183, 177, 231, 169, 186,
    230, 142, 162, 230, 181, 139, 229, 153, 168, 231, 154, 132,
    232, 131, 189, 229, 138, 155, 239, 188, 155, '2', '0', '0',
    '3', 229, 185, 180, 239, 188, 140, 228, 184, 173, 229, 155,
    189, 230, 136, 144, 228, 184, 186, 228, 184, 150, 231, 149,
    140, 231, 172, 172, 228, 184, 137, 228, 184, 170, 232, 135,
    170, 228, 184, 187, 230, 136, 144, 229, 138, 159, 229, 143,
    145, 229, 176, 132, 232, 189, 189, 228, 186, 186, 232, 136,
    170, 229, 164, 169, 229, 153, 168, 231, 154, 132, 229, 155,
    189, 229, 174, 182, 227, 128, 130, 228, 184, 173, 229, 155,
    189, 228, 186, 166, 230, 152, 175, 230, 189, 156, 229, 156,
    168, 232, 182, 133, 231, 186, 167, 229, 164, 167, 229, 155,
    189, 228, 185, 139, 228, 184, 128, 239, 188, 140, 232, 162,
    171, 232, 174, 164, 228, 184, 186, 230, 152, 175, 228, 184,
    139, 228, 184, 128, 228, 189, 141, 232, 182, 133, 231, 186,
    167, 229, 164, 167, 229, 155, 189, 231, 154, 132, 230, 156,
    137, 229, 138, 155, 229, 128, 153, 233, 128, 137, 228, 186,
    186, 227, 128, 130,  13,  10,  13,  10, 228, 184, 173, 229,
    141, 142, 228, 186, 186, 230, 176, 145, 229, 133, 177, 229,
    146, 140, 229, 155, 189, 231, 154, 132, 230, 173, 163, 229,
    188, 143, 229, 155, 189, 229, 144, 141, 228, 186, 142, '1',
    '9', '4', '9', 229, 185, 180, 231, 148, 177, 228, 184, 173,
    229, 156, 139, 228, 186, 186, 230, 176, 145, 230, 148, 191,
    230, 178, 187, 229, 141, 148, 229, 149, 134, 230, 156, 131,
    232, 173, 176, 231, 177, 140, 229, 130, 153, 230, 156, 131,
    232, 173, 176, 231, 162, 186, 229, 174, 154, 239, 188, 140,
    229, 189, 147, 229, 136, 157, 230, 155, 190, 229, 138, 160,
    232, 168, 187, 227, 128, 140, 231, 176, 161, 231, 168, 177,
    239, 188, 154, 228, 184, 173, 232, 143, 175, 230, 176, 145,
    229, 156, 139, 227, 128, 141, 239, 188, 140, 228, 189, 134,
    229, 143, 184, 229, 190, 146, 231, 190, 142, 229, 160, 130,
    231, 173, 137, 230, 176, 145, 228, 184, 187, 229, 133, 154,
    230, 180, 190, 228, 186, 186, 229, 163, 171, 232, 174, 164,
    228, 184, 186, 230, 150, 176, 228, 184, 173, 229, 155, 189,
    229, 186, 148, 231, 161, 174, 231, 171, 139, 230, 150, 176,
    229, 155, 189, 229, 144, 141, 239, 188, 140, 228, 187, 165,
    231, 164, 186, 228, 184, 164, 230, 172, 161, 233, 157, 169,
    229, 145, 189, 231, 154, 132, 230, 160, 185, 230, 156, 172,
    230, 132, 143, 228, 185, 137, 228, 184, 141, 229, 144, 140,
    '[', '1', '5', ']', 227, 128, 130, 229, 155, 160, 230, 173,
    164, 231, 155, 180, 232, 135, 179, '9', 230, 156, 136, '2',
    '7', 230, 151, 165, 230, 148, 191, 229, 141, 148, 229, 133,
    168, 233, 171, 148, 230, 156, 131, 232, 173, 176, 232, 161,
    168, 230, 177, 186, 233, 128, 154, 233, 129, 142, 228, 184,
    173, 229, 164, 174, 228, 186, 186, 230, 176, 145, 230, 148,
    191, 229, 186, 156, 231, 181, 132, 231, 185, 148, 230, 179,
    149, 230, 153, 130, 239, 188, 140, 230, 173, 163, 229, 188,
    143, 232, 173, 176, 230, 177, 186, 229, 142, 187, 233, 153,
    164, 230, 173, 164, 229, 138, 160, 232, 168, 187, '[', '1',
    '6', ']', 227, 128, 130,  13,  10,  13,  10, 229, 156, 168,
    229, 133, 168, 233, 131, 168, 229, 156, 139, 233, 154, 155,
    229, 160, 180, 229, 144, 136, 239, 188, 140, 228, 184, 173,
    232, 143, 175, 228, 186, 186, 230, 176, 145, 229, 133, 177,
    229, 146, 140, 229, 156, 139, 228, 184, 128, 232, 136, 172,
    231, 176, 161, 231, 168, 177, 231, 130, 186, 228, 184, 173,
    229, 156, 139, 239, 188, 140, 230, 156, 137, 230, 151, 182,
    229, 128, 153, 228, 185, 159, 229, 155, 160, 229, 133, 182,
    230, 137, 128, 229, 164, 132, 229, 156, 176, 231, 144, 134,
    228, 189, 141, 231, 189, 174, 232, 128, 140, 232, 162, 171,
    231, 167, 176, 228, 184, 186, 228, 184, 173, 229, 155, 189,
    229, 164, 167, 233, 153, 134, 227, 128, 130, 229, 156, 168,
    228, 184, 173, 229, 156, 139, 229, 156, 139, 229, 133, 167,
    239, 188, 140, 231, 149, 182, '1', '9', '4', '9', 229, 185,
    180, 229, 137, 141, 231, 154, 132, 228, 184, 173, 232, 143,
    175, 230, 176, 145, 229, 156, 139, 232, 136, 135, '1', '9',
    '4', '9', 229, 185, 180, 229, 190, 140, 231, 154, 132, 228,
    184, 173, 232, 143, 175, 228, 186, 186, 230, 176, 145, 229,
    133, 177, 229, 146, 140, 229, 156, 139, 229, 129, 154, 229,
    176, 141, 230, 175, 148, 230, 136, 150, 230, 156, 137, 230,
    173, 164, 230, 182, 181, 230, 140, 135, 230, 153, 130, 239,
    188, 140, 229, 137, 141, 232, 128, 133, 229, 184, 184, 232,
    162, 171, 231, 168, 177, 231, 130, 186, 232, 136, 138, 228,
    184, 173, 229, 156, 139, 239, 188, 136, 228, 186, 166, 231,
    168, 177, 232, 136, 138, 231, 164, 190, 230, 156, 131, 239,
    188, 137, 239, 188, 140, 232, 128, 140, 229, 190, 140, 232,
    128, 133, 229, 137, 135, 229, 184, 184, 232, 162, 171, 231,
    168, 177, 231, 130, 186, 230, 150, 176, 228, 184, 173, 229,
    156, 139, 227, 128, 130, 231, 155, 174, 229, 137, 141, 239,
    188, 140, 228, 184, 173, 232, 143, 175, 228, 186, 186, 230,
    176, 145, 229, 133, 177, 229, 146, 140, 229, 156, 139, 232,
    170, 141, 231, 130, 186, 228, 184, 173, 232, 143, 175, 230,
    176, 145, 229, 156, 139, 229, 183, 178, 232, 162, 171, 229,
    133, 182, 229, 143, 150, 228, 187, 163, 239, 188, 140, 228,
    184, 173, 232, 143, 175, 230, 176, 145, 229, 156, 139, 230,
    148, 191, 229, 186, 156, 229, 137, 135, 228, 184, 141, 230,
    137, 191, 232, 170, 141, 228, 184, 173, 232, 143, 175, 228,
    186, 186, 230, 176, 145, 229, 133, 177, 229, 146, 140, 229,
    156, 139, 231, 154, 132, 230, 173, 163, 231, 181, 177, 230,
    128, 167, 239, 188, 140, 231, 149, 182, 229, 156, 168, 228,
    184, 173, 229, 156, 139, 229, 164, 167, 233, 153, 184, 231,
    154, 132, 228, 184, 173, 232, 143, 175, 228, 186, 186, 230,
    176, 145, 229, 133, 177, 229, 146, 140, 229, 156, 139, 230,
    148, 191, 229, 186, 156, 232, 136, 135, 229, 156, 168, 229,
    143, 176, 231, 129, 163, 231, 154, 132, 228, 184, 173, 232,
    143, 175, 230, 176, 145, 229, 156, 139, 230, 148, 191, 229,
    186, 156, 229, 129, 154, 229, 176, 141, 230, 175, 148, 230,
    136, 150, 230, 156, 137, 230, 173, 164, 230, 182, 181, 230,
    140, 135, 230, 153, 130, 239, 188, 140, 229, 137, 141, 232,
    128, 133, 229, 184, 184, 232, 162, 171, 229, 190, 140, 232,
    128, 133, 231, 168, 177, 231, 130, 186, 229, 140, 151, 228,
    186, 172, 231, 149, 182, 229, 177, 128, 227, 128, 129, 229,
    164, 167, 233, 153, 184, 231, 149, 182, 229, 177, 128, 227,
    128, 129, 228, 184, 173, 229, 133, 177, 231, 149, 182, 229,
    177, 128, 227, 128, 129, 228, 184, 173, 229, 156, 139, 229,
    164, 167, 233, 153, 184, 230, 136, 150, 229, 164, 167, 233,
    153, 184, '[', '1', '7', ']', 239, 188, 140, 229, 190, 140,
    232, 128, 133, 229, 184, 184, 232, 162, 171, 229, 137, 141,
    232, 128, 133, 231, 168, 177, 231, 130, 186, 229, 143, 176,
    231, 129, 163, 231, 149, 182, 229, 177, 128, 227, 128, 129,
    229, 143, 176, 229, 140, 151, 231, 149, 182, 229, 177, 128,
    230, 136, 150, 229, 143, 176, 231, 129, 163, '[', '1', '8',
    ']', 227, 128, 130, 232, 136, 135, 230, 184, 175, 230, 190,
    179, 229, 156, 176, 229, 141, 128, 228, 184, 166, 231, 148,
    168, 230, 153, 130, 229, 137, 135, 231, 168, 177, 231, 130,
    186, 228, 184, 173, 229, 156, 139, 229, 133, 167, 229, 156,
    176, 227, 128, 129, 229, 133, 167, 229, 156, 176, '[', '1',
    '9', ']', 227, 128, 130,  13,  10,  13,  10, 231, 149, 182,
    228, 184, 173, 229, 156, 139, 229, 164, 167, 233, 153, 184,
    231, 154, 132, 228, 184, 173, 232, 143, 175, 228, 186, 186,
    230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 156, 139,
    230, 148, 191, 229, 186, 156, 232, 136, 135, 229, 156, 168,
    229, 143, 176, 231, 129, 163, 231, 154, 132, 228, 184, 173,
    232, 143, 175, 230, 176, 145, 229, 156, 139, 230, 148, 191,
    229, 186, 156, 229, 129, 154, 229, 176, 141, 230, 175, 148,
    230, 136, 150, 229, 141, 128, 233, 154, 148, 228, 187, 139,
    231, 180, 185, 230, 153, 130, 239, 188, 140, 233, 128, 154,
    229, 184, 184, 230, 142, 161, 231, 148, 168, 229, 156, 176,
    231, 144, 134, 229, 144, 141, 232, 169, 158, 227, 128, 140,
    228, 184, 173, 229, 156, 139, 229, 164, 167, 233, 153, 184,
    227, 128, 141, 239, 188, 136, 'C', 'h', 'i', 'n', 'a', ' ',
    'M', 'a', 'i', 'n', 'l', 'a', 'n', 'd', 239, 188, 137, 230,
    136, 150, 228, 184, 173, 229, 155, 189, 239, 188, 136, 'C',
    'h', 'i', 'n', 'a', 239, 188, 137, 229, 129, 154, 231, 130,
    186, 228, 184, 173, 232, 143, 175, 228, 186, 186, 230, 176,
    145, 229, 133, 177, 229, 146, 140, 229, 156, 139, 231, 154,
    132, 231, 176, 161, 231, 168, 177, 239, 188, 140, 229, 176,
    141, 230, 150, 188, 228, 184, 173, 232, 143, 175, 230, 176,
    145, 229, 156, 139, 229, 137, 135, 231, 176, 161, 231, 168,
    177, 231, 130, 186, 228, 184, 173, 232, 143, 175, 229, 143,
    176, 229, 140, 151, 239, 188, 136, 'C', 'h', 'i', 'n', 'e',
    's', 'e', ' ', 'T', 'a', 'i', 'p', 'e', 'i', 239, 188, 137,
    230, 136, 150, 229, 143, 176, 231, 129, 163, 239, 188, 136,
    'T', 'a', 'i', 'w', 'a', 'n', 239, 188, 137, 227, 128, 130,
    232, 128, 140, 229, 143, 176, 230, 185, 190, 231, 154, 132,
    229, 170, 146, 228, 189, 147, 229, 137, 135, 229, 184, 184,
    228, 189, 191, 231, 148, 168, 227, 128, 140, 228, 184, 173,
    229, 133, 177, 227, 128, 141, 227, 128, 129, 227, 128, 140,
    229, 164, 167, 233, 153, 184, 229, 156, 176, 229, 141, 128,
    227, 128, 141, 227, 128, 129, 227, 128, 140, 229, 164, 167,
    233, 153, 184, 227, 128, 141, 230, 136, 150, 227, 128, 140,
    228, 184, 173, 229, 155, 189, 227, 128, 141, 230, 157, 165,
    228, 189, 156, 231, 130, 186, 228, 184, 173, 232, 143, 175,
    228, 186, 186, 230, 176, 145, 229, 133, 177, 229, 146, 140,
    229, 156, 139, 231, 154, 132, 231, 176, 161, 231, 168, 177,
    227, 128, 130, 233, 166, 153, 230, 184, 175, 233, 131, 168,
    229, 136, 134, 229, 170, 146, 233, 171, 148, 228, 185, 159,
    230, 156, 137, 228, 189, 191, 231, 148, 168, 227, 128, 140,
    228, 184, 173, 229, 156, 139, 227, 128, 141, 229, 146, 140,
    227, 128, 140, 228, 184, 173, 229, 133, 177, 227, 128, 141,
    228, 190, 134, 230, 140, 135, 228, 187, 163, 228, 184, 173,
    229, 156, 139, 229, 164, 167, 233, 153, 184, 227, 128, 130,
     13,  10,  13,  10, '1', '9', '4', '9', 229, 185, 180, 239,
    188, 140, 230, 173, 183, 230, 153, 130, 228, 184, 137, 229,
    185, 180, 231, 154, 132, 229, 156, 139, 229, 133, 177, 229,
    133, 167, 230, 136, 176, 228, 184, 187, 232, 166, 129, 230,
    136, 176, 229, 189, 185, 231, 181, 144, 230, 157, 159, 239,
    188, 140, 228, 184, 173, 229, 156, 139, 229, 133, 177, 231,
    148, 162, 233, 187, 168, 230, 137, 128, 233, 160, 152, 229,
    176, 142, 231, 154, 132, 228, 184, 173, 229, 156, 139, 228,
    186, 186, 230, 176, 145, 232, 167, 163, 230, 148, 190, 232,
    187, 141, 230, 136, 176, 229, 139, 157, 228, 186, 134, 228,
    184, 173, 229, 156, 139, 229, 156, 139, 230, 176, 145, 233,
    187, 168, 230, 137, 128, 233, 160, 152, 229, 176, 142, 231,
    154, 132, 228, 184, 173, 232, 143, 175, 230, 176, 145, 229,
    156, 139, 229, 155, 189, 232, 187, 141, '[', 230, 179, 168,
    ' ', '6', ']', 239, 188, 140, 228, 184, 166, 229, 183, 178,
    233, 128, 144, 230, 188, 184, 230, 142, 167, 229, 136, 182,
    228, 186, 134, 228, 184, 173, 229, 156, 139, 229, 164, 167,
    233, 153, 184, 229, 164, 167, 233, 131, 168, 229, 136, 134,
    231, 156, 129, 228, 187, 189, 229, 146, 140, 229, 156, 176,
    229, 140, 186, 227, 128, 130,  13,  10,  13,  10, 229, 144,
    140, 229, 185, 180, '9', 230, 156, 136, '2', '1', 230, 151,
    165, 232, 135, 179, '9', 230, 156, 136, '3', '0', 230, 151,
    165, 239, 188, 140, 231, 182, 147, 233, 129, 142, 230, 149,
    184, 230, 156, 136, 231, 154, 132, 231, 177, 140, 229, 130,
    153, 239, 188, 140, 228, 184, 173, 229, 156, 139, 228, 186,
    186, 230, 176, 145, 230, 148, 191, 230, 178, 187, 229, 141,
    148, 229, 149, 134, 230, 156, 131, 232, 173, 176, 231, 172,
    172, 228, 184, 128, 229, 177, 134, 229, 133, 168, 233, 171,
    148, 230, 156, 131, 232, 173, 176, 229, 156, 168, 229, 140,
    151, 229, 185, 179, 229, 143, 172, 233, 150, 139, 227, 128,
    130, '9', 230, 156, 136, '2', '1', 230, 151, 165, 239, 188,
    140, 228, 184, 173, 229, 156, 139, 228, 186, 186, 230, 176,
    145, 230, 148, 191, 230, 178, 187, 229, 141, 148, 229, 149,
    134, 230, 156, 131, 232, 173, 176, 231, 172, 172, 228, 184,
    128, 229, 177, 134, 229, 133, 168, 233, 171, 148, 230, 156,
    131, 232, 173, 176, 230, 173, 163, 229, 188, 143, 229, 174,
    163, 229, 184, 131, 230, 136, 144, 231, 171, 139, 228, 184,
    173, 229, 141, 142, 228, 186, 186, 230, 176, 145, 229, 133,
    177, 229, 146, 140, 229, 155, 189, '[', '2', '0', ']', 227,
    128, 130, 228, 188, 154, 232, 174, 174, 233, 128, 154, 233,
    129, 142, 228, 186, 134, 227, 128, 138, 228, 184, 173, 229,
    156, 139, 228, 186, 186, 230, 176, 145, 230, 148, 191, 230,
    178, 187, 229, 141, 148, 229, 149, 134, 230, 156, 131, 232,
    173, 176, 231, 181, 132, 231, 185, 148, 230, 179, 149, 227,
    128, 139, 227, 128, 129, 227, 128, 138, 228, 184, 173, 232,
    143, 175, 228, 186, 186, 230, 176, 145, 229, 133, 177, 229,
    146, 140, 229, 156, 139, 228, 184, 173, 229, 164, 174, 228,
    186, 186, 230, 176, 145, 230, 148, 191, 229, 186, 156, 231,
    181, 132, 231, 185, 148, 230, 179, 149, 227, 128, 139, 229,
    146, 140, 229, 133, 183, 230, 156, 137, 232, 135, 168, 230,
    153, 130, 230, 134, 178, 230, 179, 149, 230, 128, 167, 232,
    179, 170, 231, 154, 132, 227, 128, 138, 228, 184, 173, 229,
    156, 139, 228, 186, 186, 230, 176, 145, 230, 148, 191, 230,
    178, 187, 229, 141, 148, 229, 149, 134, 230, 156, 131, 232,
    173, 176, 229, 133, 177, 229, 144, 140, 231, 182, 177, 233,
    160, 152, 227, 128, 139, 239, 188, 140, 230, 177, 186, 229,
    174, 154, 228, 187, 165, 229, 140, 151, 229, 185, 179, 231,
    130, 186, 233, 166, 150, 233, 131, 189, 228, 184, 166, 230,
    148, 185, 229, 144, 141, 231, 136, 178, 229, 140, 151, 228,
    186, 172, 227, 128, 129, 228, 187, 165, 229, 133, 172, 229,
    133, 131, 231, 180, 128, 229, 185, 180, 227, 128, 129, 228,
    187, 165, 231, 190, 169, 229, 139, 135, 232, 187, 141, 233,
    128, 178, 232, 161, 140, 230, 155, 178, 231, 130, 186, 228,
    187, 163, 229, 156, 139, 230, 173, 140, 227, 128, 129, 228,
    187, 165, 228, 186, 148, 230, 152, 159, 231, 180, 133, 230,
    151, 151, 231, 130, 186, 229, 156, 139, 230, 151, 151, 239,
    188, 140, 233, 128, 154, 233, 129, 142, 228, 186, 134, 231,
    148, 177, '1', '8', '0', 228, 186, 186, 231, 181, 132, 230,
    136, 144, 231, 154, 132, 228, 184, 173, 229, 156, 139, 228,
    186, 186, 230, 176, 145, 230, 148, 191, 230, 178, 187, 229,
    141, 148, 229, 149, 134, 230, 156, 131, 232, 173, 176, 231,
    172, 172, 228, 184, 128, 229, 177, 134, 229, 133, 168, 229,
    156, 139, 229, 167, 148, 229, 147, 161, 230, 156, 131, 229,
    144, 141, 229, 150, 174, 239, 188, 140, 228, 184, 166, 233,
    129, 184, 232, 136, 137, 230, 175, 155, 230, 190, 164, 230,
    157, 177, 231, 130, 186, 228, 184, 173, 229, 164, 174, 228,
    186, 186, 230, 176, 145, 230, 148, 191, 229, 186, 156, 228,
    184, 187, 229, 184, 173, 227, 128, 129, 230, 156, 177, 229,
    190, 183, 227, 128, 129, 229, 136, 152, 229, 176, 145, 229,
    165, 135, 227, 128, 129, 229, 174, 139, 229, 186, 134, 233,
    190, 132, 227, 128, 129, 230, 157, 142, 230, 181, 142, 230,
    183, 177, 227, 128, 129, 229, 188, 160, 230, 190, 156, 227,
    128, 129, 233, 171, 152, 229, 178, 151, 231, 130, 186, 229,
    137, 175, 228, 184, 187, 229, 184, 173, 227, 128, 129, 229,
    143, 166, 229, 164, 150, '5', '6', 228, 189, 141, 231, 130,
    186, 228, 184, 173, 229, 164, 174, 228, 186, 186, 230, 176,
    145, 230, 148, 191, 229, 186, 156, 229, 167, 148, 229, 147,
    161, 227, 128, 130, '1', '0', 230, 156, 136, '1', 230, 151,
    165, 229, 188, 128, 229, 155, 189, 229, 164, 167, 229, 133,
    184, 229, 156, 168, 229, 140, 151, 228, 186, 172, 228, 184,
    190, 232, 161, 140, 239, 188, 140, 230, 175, 155, 230, 190,
    164, 230, 157, 177, 229, 156, 168, 229, 164, 169, 229, 174,
    137, 233, 151, 168, 229, 159, 142, 230, 165, 188, 229, 174,
    163, 229, 145, 138, 228, 184, 173, 229, 141, 142, 228, 186,
    186, 230, 176, 145, 229, 133, 177, 229, 146, 140, 229, 155,
    189, 228, 184, 173, 229, 164, 174, 228, 186, 186, 230, 176,
    145, 230, 148, 191, 229, 186, 156, 230, 136, 144, 231, 171,
    139, 239, 188, 155, '1', '2', 230, 156, 136, '7', 230, 151,
    165, 239, 188, 140, 228, 184, 173, 232, 143, 175, 230, 176,
    145, 229, 156, 139, 230, 148, 191, 229, 186, 156, 230, 173,
    163, 229, 188, 143, 231, 148, 177, 229, 155, 155, 229, 183,
    157, 231, 156, 129, 230, 136, 144, 233, 131, 189, 229, 184,
    130, 233, 129, 183, 229, 190, 128, 229, 143, 176, 230, 185,
    190, 231, 156, 129, 229, 143, 176, 229, 140, 151, 229, 184,
    130, 239, 188, 140, 228, 184, 166, 231, 185, 188, 231, 186,
    140, 231, 181, 177, 230, 178, 187, 229, 143, 176, 231, 129,
    163, 230, 156, 172, 229, 179, 182, 229, 143, 138, 230, 190,
    142, 230, 185, 150, 227, 128, 129, 233, 131, 168, 229, 136,
    134, 231, 166, 143, 229, 187, 186, 233, 155, 162, 229, 179,
    182, 227, 128, 129, 228, 184, 156, 230, 178, 153, 231, 190,
    164, 229, 178, 155, 227, 128, 129, 229, 164, 170, 229, 185,
    179, 229, 178, 155, 231, 173, 137, 232, 135, 179, 228, 187,
    138, 227, 128, 130, 232, 135, 179, 230, 173, 164, 239, 188,
    140, 228, 184, 173, 229, 156, 139, 230, 173, 183, 229, 143,
    178, 228, 184, 138, 230, 150, 188, 230, 181, 183, 229, 179,
    189, 229, 133, 169, 229, 178, 184, 229, 136, 134, 230, 178,
    187, 231, 154, 132, 230, 148, 191, 230, 178, 187, 230, 160,
    188, 229, 177, 128, 230, 173, 163, 229, 188, 143, 229, 189,
    162, 230, 136, 144, 227, 128, 130,  13,  10,  13,  10, 'H',
    'i', 'n', 'd', 'i', ':',  13,  10,  13,  10, 224, 164, 173,
    224, 164, 190, 224, 164, 176, 224, 164, 164, ',', ' ', 224,
    164, 170, 224, 165, 140, 224, 164, 176, 224, 164, 190, 224,
    164, 163, 224, 164, 191, 224, 164, 149, ' ', 224, 164, 156,
    224, 164, 174, 224, 165, 141, 224, 164, 172, 224, 165, 130,
    224, 164, 166, 224, 165, 141, 224, 164, 181, 224, 165, 128,
    224, 164, 170, ',', ' ', 224, 164, 134, 224, 164, 167, 224,
    165, 129, 224, 164, 168, 224, 164, 191, 224, 164, 149, ' ',
    224, 164, 166, 224, 164, 149, 224, 165, 141, 224, 164, 183,
    224, 164, 191, 224, 164, 163, ' ', 224, 164, 143, 224, 164,
    182, 224, 164, 191, 224, 164, 175, 224, 164, 190, ' ', 224,
    164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164, 184,
    224, 165, 141, 224, 164, 165, 224, 164, 191, 224, 164, 164,
    ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164,
    164, 224, 165, 128, 224, 164, 175, ' ', 224, 164, 137, 224,
    164, 170, 224, 164, 174, 224, 164, 185, 224, 164, 190, 224,
    164, 166, 224, 165, 141, 224, 164, 181, 224, 165, 128, 224,
    164, 170, ' ', 224, 164, 149, 224, 164, 190, ' ', 224, 164,
    184, 224, 164, 172, 224, 164, 184, 224, 165, 135, ' ', 224,
    164, 172, 224, 164, 161, 224, 164, 188, 224, 164, 190, ' ',
    224, 164, 166, 224, 165, 135, 224, 164, 182, ' ', 224, 164,
    185, 224, 165, 136, 224, 165, 164, ' ', 224, 164, 173, 224,
    164, 190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 149,
    224, 164, 190, ' ', 224, 164, 173, 224, 165, 140, 224, 164,
    151, 224, 165, 139, 224, 164, 178, 224, 164, 191, 224, 164,
    149, ' ', 224, 164, 171, 224, 165, 136, 224, 164, 178, 224,
    164, 190, 224, 164, 181, ' ', 224, 165, 174, 224, 165, 166,
    ' ', 224, 165, 170,'\'', ' ', 224, 164, 184, 224, 165, 135,
    ' ', 224, 165, 169, 224, 165, 173, 224, 165, 166, ' ', 224,
    165, 172,'\'', ' ', 224, 164, 137, 224, 164, 164, 224, 165,
    141, 224, 164, 164, 224, 164, 176, 224, 165, 128, ' ', 224,
    164, 133, 224, 164, 149, 224, 165, 141, 224, 164, 183, 224,
    164, 190, 224, 164, 130, 224, 164, 182, ' ', 224, 164, 164,
    224, 164, 149, ' ', 224, 164, 164, 224, 164, 165, 224, 164,
    190, ' ', 224, 165, 172, 224, 165, 174, 224, 165, 166, ' ',
    224, 165, 173,'\'', ' ', 224, 164, 184, 224, 165, 135, ' ',
    224, 165, 175, 224, 165, 173, 224, 165, 166, ' ', 224, 165,
    168, 224, 165, 171,'\'', 224, 164, 170, 224, 165, 130, 224,
    164, 176, 224, 165, 141, 224, 164, 181, 224, 165, 128, ' ',
    224, 164, 166, 224, 165, 135, 224, 164, 182, 224, 164, 190,
    224, 164, 168, 224, 165, 141, 224, 164, 164, 224, 164, 176,
    ' ', 224, 164, 164, 224, 164, 149, ' ', 224, 164, 185, 224,
    165, 136, 224, 165, 164, ' ', 224, 164, 173, 224, 164, 190,
    224, 164, 176, 224, 164, 164, ' ', 224, 164, 149, 224, 164,
    190, ' ', 224, 164, 181, 224, 164, 191, 224, 164, 184, 224,
    165, 141, 224, 164, 164, 224, 164, 190, 224, 164, 176, ' ',
    224, 164, 137, 224, 164, 164, 224, 165, 141, 224, 164, 164,
    224, 164, 176, ' ', 224, 164, 184, 224, 165, 135, ' ', 224,
    164, 166, 224, 164, 149, 224, 165, 141, 224, 164, 183, 224,
    164, 191, 224, 164, 163, ' ', 224, 164, 164, 224, 164, 149,
    ' ', 224, 164, 149, 224, 164, 191, '.', ' ', 224, 164, 174,
    224, 165, 128, '.', ' ', 224, 164, 148, 224, 164, 176, ' ',
    224, 164, 170, 224, 165, 130, 224, 164, 176, 224, 165, 141,
    224, 164, 181, ' ', 224, 164, 184, 224, 165, 135, ' ', 224,
    164, 170, 224, 164, 182, 224, 165, 141, 224, 164, 154, 224,
    164, 191, 224, 164, 174, ' ', 224, 164, 164, 224, 164, 149,
    ' ', 224, 165, 168, ',', 224, 165, 175, 224, 165, 169, 224,
    165, 169, ' ', 224, 164, 149, 224, 164, 191, '.', ' ', 224,
    164, 174, 224, 165, 128, '.', ' ', 224, 164, 185, 224, 165,
    136, 224, 165, 164, ' ', 224, 164, 173, 224, 164, 190, 224,
    164, 176, 224, 164, 164, ' ', 224, 164, 149, 224, 165, 128,
    ' ', 224, 164, 184, 224, 164, 174, 224, 165, 129, 224, 164,
    166, 224, 165, 141, 224, 164, 176, ' ', 224, 164, 164, 224,
    164, 159, ' ', 224, 164, 176, 224, 165, 135, 224, 164, 150,
    224, 164, 190, ' ', 224, 165, 173, 224, 165, 171, 224, 165,
    167, 224, 165, 172, '.', 224, 165, 172, ' ', 224, 164, 149,
    224, 164, 191, 224, 164, 178, 224, 165, 139, 224, 164, 174,
    224, 165, 128, 224, 164, 159, 224, 164, 176, ' ', 224, 164,
    178, 224, 164, 174, 224, 165, 141, 224, 164, 172, 224, 165,
    128, ' ', 224, 164, 185, 224, 165, 136, 224, 165, 164, ' ',
    224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164, 164,
    ',', ' ', 224, 164, 173, 224, 165, 140, 224, 164, 151, 224,
    165, 139, 224, 164, 178, 224, 164, 191, 224, 164, 149, ' ',
    224, 164, 166, 224, 165, 131, 224, 164, 183, 224, 165, 141,
    224, 164, 159, 224, 164, 191, ' ', 224, 164, 184, 224, 165,
    135, ' ', 224, 164, 181, 224, 164, 191, 224, 164, 182, 224,
    165, 141, 224, 164, 181, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 184, 224, 164, 190, 224, 164,
    164, 224, 164, 181, 224, 164, 190, 224, 164, 129, ' ', 224,
    164, 184, 224, 164, 172, 224, 164, 184, 224, 165, 135, ' ',
    224, 164, 172, 224, 164, 161, 224, 164, 188, 224, 164, 190,
    ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 156, 224,
    164, 168, 224, 164, 184, 224, 164, 129, 224, 164, 150, 224,
    165, 141, 224, 164, 175, 224, 164, 190, ' ', 224, 164, 149,
    224, 165, 135, ' ', 224, 164, 166, 224, 165, 131, 224, 164,
    183, 224, 165, 141, 224, 164, 159, 224, 164, 191, 224, 164,
    149, 224, 165, 139, 224, 164, 163, ' ', 224, 164, 184, 224,
    165, 135, ' ', 224, 164, 166, 224, 165, 130, 224, 164, 184,
    224, 164, 176, 224, 164, 190, ' ', 224, 164, 184, 224, 164,
    172, ' ', 224, 164, 184, 224, 165, 135, ' ', 224, 164, 172,
    224, 164, 161, 224, 164, 188, 224, 164, 190, ' ', 224, 164,
    166, 224, 165, 135, 224, 164, 182, ' ', 224, 164, 185, 224,
    165, 136, 224, 165, 164, ' ', 224, 164, 173, 224, 164, 190,
    224, 164, 176, 224, 164, 164, ' ', 224, 164, 149, 224, 165,
    135, ' ', 224, 164, 170, 224, 164, 182, 224, 165, 141, 224,
    164, 154, 224, 164, 191, 224, 164, 174, ' ', 224, 164, 174,
    224, 165, 135, 224, 164, 130, ' ', 224, 164, 170, 224, 164,
    190, 224, 164, 149, 224, 164, 191, 224, 164, 184, 224, 165,
    141, 224, 164, 164, 224, 164, 190, 224, 164, 168, ',', ' ',
    224, 164, 137, 224, 164, 164, 224, 165, 141, 224, 164, 164,
    224, 164, 176, '-', 224, 164, 170, 224, 165, 130, 224, 164,
    176, 224, 165, 141, 224, 164, 181, ' ', 224, 164, 174, 224,
    165, 135, 224, 164, 130, ' ', 224, 164, 154, 224, 165, 128,
    224, 164, 168, ',', ' ', 224, 164, 168, 224, 165, 135, 224,
    164, 170, 224, 164, 190, 224, 164, 178, ',', ' ', 224, 164,
    148, 224, 164, 176, ' ', 224, 164, 173, 224, 165, 130, 224,
    164, 159, 224, 164, 190, 224, 164, 168, ' ', 224, 164, 148,
    224, 164, 176, ' ', 224, 164, 170, 224, 165, 130, 224, 164,
    176, 224, 165, 141, 224, 164, 181, ' ', 224, 164, 174, 224,
    165, 135, 224, 164, 130, ' ', 224, 164, 172, 224, 164, 190,
    224, 164, 130, 224, 164, 151, 224, 165, 141, 224, 164, 178,
    224, 164, 190, 224, 164, 166, 224, 165, 135, 224, 164, 182,
    ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 174, 224,
    165, 141, 224, 164, 175, 224, 164, 190, 224, 164, 168, 224,
    165, 141, 224, 164, 174, 224, 164, 190, 224, 164, 176, ' ',
    224, 164, 166, 224, 165, 135, 224, 164, 182, ' ', 224, 164,
    184, 224, 165, 141, 224, 164, 165, 224, 164, 191, 224, 164,
    164, ' ', 224, 164, 185, 224, 165, 136, 224, 164, 130, 224,
    165, 164, ' ', 224, 164, 185, 224, 164, 191, 224, 164, 168,
    224, 165, 141, 224, 164, 166, ' ', 224, 164, 174, 224, 164,
    185, 224, 164, 190, 224, 164, 184, 224, 164, 190, 224, 164,
    151, 224, 164, 176, ' ', 224, 164, 174, 224, 165, 135, 224,
    164, 130, ' ', 224, 164, 135, 224, 164, 184, 224, 164, 149,
    224, 165, 135, ' ', 224, 164, 166, 224, 164, 149, 224, 165,
    141, 224, 164, 183, 224, 164, 191, 224, 164, 163, ' ', 224,
    164, 170, 224, 164, 182, 224, 165, 141, 224, 164, 154, 224,
    164, 191, 224, 164, 174, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 174, 224, 164, 190, 224, 164,
    178, 224, 164, 166, 224, 165, 128, 224, 164, 181, ',', ' ',
    224, 164, 166, 224, 164, 149, 224, 165, 141, 224, 164, 183,
    224, 164, 191, 224, 164, 163, ' ', 224, 164, 174, 224, 165,
    135, 224, 164, 130, ' ', 224, 164, 182, 224, 165, 141, 224,
    164, 176, 224, 165, 128, 224, 164, 178, 224, 164, 130, 224,
    164, 149, 224, 164, 190, ' ', 224, 164, 148, 224, 164, 176,
    ' ', 224, 164, 166, 224, 164, 149, 224, 165, 141, 224, 164,
    183, 224, 164, 191, 224, 164, 163, '-', 224, 164, 170, 224,
    165, 130, 224, 164, 176, 224, 165, 141, 224, 164, 181, ' ',
    224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164,
    135, 224, 164, 130, 224, 164, 161, 224, 165, 139, 224, 164,
    168, 224, 165, 135, 224, 164, 182, 224, 164, 191, 224, 164,
    175, 224, 164, 190, ' ', 224, 164, 185, 224, 165, 136, 224,
    164, 130, 224, 165, 164, ' ', 224, 164, 137, 224, 164, 164,
    224, 165, 141, 224, 164, 164, 224, 164, 176, '-', 224, 164,
    170, 224, 164, 182, 224, 165, 141, 224, 164, 154, 224, 164,
    191, 224, 164, 174, ' ', 224, 164, 174, 224, 165, 135, 224,
    164, 130, ' ', 224, 164, 133, 224, 164, 171, 224, 164, 188,
    224, 164, 151, 224, 164, 190, 224, 164, 168, 224, 164, 191,
    224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 164, 190,
    224, 164, 168, ' ', 224, 164, 149, 224, 165, 135, ' ', 224,
    164, 184, 224, 164, 190, 224, 164, 165, ' ', 224, 164, 173,
    224, 164, 190, 224, 164, 176, 224, 164, 164, ' ', 224, 164,
    149, 224, 165, 128, ' ', 224, 164, 184, 224, 165, 128, 224,
    164, 174, 224, 164, 190, ' ', 224, 164, 185, 224, 165, 136,
    224, 165, 164, ' ', 224, 164, 135, 224, 164, 184, 224, 164,
    149, 224, 165, 135, ' ', 224, 164, 137, 224, 164, 164, 224,
    165, 141, 224, 164, 164, 224, 164, 176, ' ', 224, 164, 174,
    224, 165, 135, 224, 164, 130, ' ', 224, 164, 185, 224, 164,
    191, 224, 164, 174, 224, 164, 190, 224, 164, 178, 224, 164,
    175, ' ', 224, 164, 170, 224, 164, 176, 224, 165, 141, 224,
    164, 181, 224, 164, 164, ' ', 224, 164, 185, 224, 165, 136,
    ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 166, 224,
    164, 149, 224, 165, 141, 224, 164, 183, 224, 164, 191, 224,
    164, 163, ' ', 224, 164, 174, 224, 165, 135, 224, 164, 130,
    ' ', 224, 164, 185, 224, 164, 191, 224, 164, 168, 224, 165,
    141, 224, 164, 166, ' ', 224, 164, 174, 224, 164, 185, 224,
    164, 190, 224, 164, 184, 224, 164, 190, 224, 164, 151, 224,
    164, 176, ' ', 224, 164, 185, 224, 165, 136, 224, 165, 164,
    ' ', 224, 164, 170, 224, 165, 130, 224, 164, 176, 224, 165,
    141, 224, 164, 181, ' ', 224, 164, 174, 224, 165, 135, 224,
    164, 130, ' ', 224, 164, 172, 224, 164, 130, 224, 164, 151,
    224, 164, 190, 224, 164, 178, ' ', 224, 164, 149, 224, 165,
    128, ' ', 224, 164, 150, 224, 164, 190, 224, 164, 161, 224,
    164, 188, 224, 165, 128, ' ', 224, 164, 185, 224, 165, 136,
    ' ', 224, 164, 164, 224, 164, 165, 224, 164, 190, ' ', 224,
    164, 170, 224, 164, 182, 224, 165, 141, 224, 164, 154, 224,
    164, 191, 224, 164, 174, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 133, 224, 164, 176, 224, 164,
    172, ' ', 224, 164, 184, 224, 164, 190, 224, 164, 151, 224,
    164, 176, 224, 164, 184, 224, 164, 174, 224, 165, 129, 224,
    164, 166, 224, 165, 141, 224, 164, 176, ' ', 224, 164, 185,
    224, 165, 136, 224, 164, 130, ' ', 224, 165, 164, ' ', 224,
    164, 173, 224, 164, 190, 224, 164, 176, 224, 164, 164, ' ',
    224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164,
    149, 224, 164, 136, ' ', 224, 164, 172, 224, 164, 161, 224,
    164, 188, 224, 165, 128, ' ', 224, 164, 168, 224, 164, 166,
    224, 164, 191, 224, 164, 175, 224, 164, 190, 224, 164, 129,
    ' ', 224, 164, 185, 224, 165, 136, 224, 164, 130, ' ', 224,
    165, 164, ' ', 224, 164, 151, 224, 164, 130, 224, 164, 151,
    224, 164, 190, ' ', 224, 164, 168, 224, 164, 166, 224, 165,
    128, ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224,
    164, 164, 224, 165, 128, 224, 164, 175, ' ', 224, 164, 184,
    224, 164, 130, 224, 164, 184, 224, 165, 141, 224, 164, 149,
    224, 165, 131, 224, 164, 164, 224, 164, 191, ' ', 224, 164,
    174, 224, 165, 135, 224, 164, 130, ' ', 224, 164, 133, 224,
    164, 164, 224, 165, 141, 224, 164, 175, 224, 164, 130, 224,
    164, 164, ' ', 224, 164, 170, 224, 164, 181, 224, 164, 191,
    224, 164, 164, 224, 165, 141, 224, 164, 176, ' ', 224, 164,
    174, 224, 164, 190, 224, 164, 168, 224, 165, 128, ' ', 224,
    164, 156, 224, 164, 190, 224, 164, 164, 224, 165, 128, ' ',
    224, 164, 185, 224, 165, 136, 224, 165, 164, ' ', 224, 164,
    133, 224, 164, 168, 224, 165, 141, 224, 164, 175, ' ', 224,
    164, 172, 224, 164, 161, 224, 164, 188, 224, 165, 128, ' ',
    224, 164, 168, 224, 164, 166, 224, 164, 191, 224, 164, 175,
    224, 164, 190, 224, 164, 129, ' ', 224, 164, 184, 224, 164,
    191, 224, 164, 168, 224, 165, 141, 224, 164, 167, 224, 165,
    129, ',', ' ', 224, 164, 168, 224, 164, 176, 224, 165, 141,
    224, 164, 174, 224, 164, 166, 224, 164, 190, ',', ' ', 224,
    164, 172, 224, 165, 141, 224, 164, 176, 224, 164, 185, 224,
    165, 141, 224, 164, 174, 224, 164, 170, 224, 165, 129, 224,
    164, 164, 224, 165, 141, 224, 164, 176, ',', ' ', 224, 164,
    175, 224, 164, 174, 224, 165, 129, 224, 164, 168, 224, 164,
    190, ',', ' ', 224, 164, 151, 224, 165, 139, 224, 164, 166,
    224, 164, 190, 224, 164, 181, 224, 164, 176, 224, 165, 128,
    ',', ' ', 224, 164, 149, 224, 164, 190, 224, 164, 181, 224,
    165, 135, 224, 164, 176, 224, 165, 128, ',', ' ', 224, 164,
    149, 224, 165, 131, 224, 164, 183, 224, 165, 141, 224, 164,
    163, 224, 164, 190, ',', ' ', 224, 164, 154, 224, 164, 174,
    224, 165, 141, 224, 164, 172, 224, 164, 178, ',', ' ', 224,
    164, 184, 224, 164, 164, 224, 164, 178, 224, 164, 156, ',',
    ' ', 224, 164, 181, 224, 165, 141, 224, 164, 175, 224, 164,
    190, 224, 164, 184, ' ', 224, 164, 134, 224, 164, 166, 224,
    164, 191, ' ', 224, 164, 185, 224, 165, 136, 224, 164, 130,
    224, 165, 164,  13,  10,  13,  10, 224, 164, 175, 224, 164,
    185, ' ', 224, 164, 181, 224, 164, 191, 224, 164, 182, 224,
    165, 141, 224, 164, 181, ' ', 224, 164, 149, 224, 164, 190,
    ' ', 224, 164, 184, 224, 164, 172, 224, 164, 184, 224, 165,
    135, ' ', 224, 164, 172, 224, 164, 161, 224, 164, 188, 224,
    164, 190, ' ', 224, 164, 178, 224, 165, 139, 224, 164, 149,
    224, 164, 164, 224, 164, 130, 224, 164, 164, 224, 165, 141,
    224, 164, 176, ' ', 224, 164, 185, 224, 165, 136, 224, 165,
    164, ' ', 224, 164, 175, 224, 164, 185, 224, 164, 190, 224,
    164, 129, ' ', 224, 165, 169, 224, 165, 166, 224, 165, 166,
    ' ', 224, 164, 184, 224, 165, 135, ' ', 224, 164, 133, 224,
    164, 167, 224, 164, 191, 224, 164, 149, ' ', 224, 164, 173,
    224, 164, 190, 224, 164, 183, 224, 164, 190, 224, 164, 143,
    224, 164, 129, ' ', 224, 164, 172, 224, 165, 139, 224, 164,
    178, 224, 165, 128, ' ', 224, 164, 156, 224, 164, 190, 224,
    164, 164, 224, 165, 128, ' ', 224, 164, 185, 224, 165, 136,
    224, 164, 130, ' ', '[', '1', ']', 224, 165, 164, ' ', 224,
    164, 175, 224, 164, 185, ' ', 224, 164, 181, 224, 164, 191,
    224, 164, 182, 224, 165, 141, 224, 164, 181, ' ', 224, 164,
    149, 224, 165, 128, ' ', 224, 164, 149, 224, 165, 129, 224,
    164, 155, ' ', 224, 164, 170, 224, 165, 141, 224, 164, 176,
    224, 164, 190, 224, 164, 154, 224, 165, 128, 224, 164, 168,
    224, 164, 164, 224, 164, 174, ' ', 224, 164, 184, 224, 164,
    173, 224, 165, 141, 224, 164, 175, 224, 164, 164, 224, 164,
    190, 224, 164, 147, 224, 164, 130, ' ', 224, 164, 149, 224,
    165, 128, ' ', 224, 164, 156, 224, 164, 168, 224, 164, 168,
    224, 165, 128, ' ', 224, 164, 176, 224, 164, 185, 224, 164,
    190, ' ', 224, 164, 185, 224, 165, 136, ' ', 224, 164, 156,
    224, 165, 136, 224, 164, 184, 224, 165, 135, ' ', '-', ' ',
    224, 164, 184, 224, 164, 191, 224, 164, 168, 224, 165, 141,
    224, 164, 167, 224, 165, 129, ' ', 224, 164, 152, 224, 164,
    190, 224, 164, 159, 224, 165, 128, ' ', 224, 164, 184, 224,
    164, 173, 224, 165, 141, 224, 164, 175, 224, 164, 164, 224,
    164, 190, ',', ' ', 224, 164, 148, 224, 164, 176, ' ', 224,
    164, 174, 224, 164, 185, 224, 164, 164, 224, 165, 141, 224,
    164, 181, 224, 164, 170, 224, 165, 130, 224, 164, 176, 224,
    165, 141, 224, 164, 163, ' ', 224, 164, 144, 224, 164, 164,
    224, 164, 191, 224, 164, 185, 224, 164, 190, 224, 164, 184,
    224, 164, 191, 224, 164, 149, ' ', 224, 164, 181, 224, 165,
    141, 224, 164, 175, 224, 164, 190, 224, 164, 170, 224, 164,
    190, 224, 164, 176, ' ', 224, 164, 170, 224, 164, 165, 224,
    165, 139, 224, 164, 130, ' ', 224, 164, 149, 224, 164, 190,
    ' ', 224, 164, 133, 224, 164, 173, 224, 164, 191, 224, 164,
    168, 224, 165, 141, 224, 164, 168, ' ', 224, 164, 133, 224,
    164, 130, 224, 164, 151, ' ', 224, 164, 173, 224, 165, 128,
    '.', ' ', 224, 164, 181, 224, 164, 191, 224, 164, 182, 224,
    165, 141, 224, 164, 181, ' ', 224, 164, 149, 224, 165, 135,
    ' ', 224, 164, 154, 224, 164, 190, 224, 164, 176, ' ', 224,
    164, 170, 224, 165, 141, 224, 164, 176, 224, 164, 174, 224,
    165, 129, 224, 164, 150, ' ', 224, 164, 167, 224, 164, 176,
    224, 165, 141, 224, 164, 174, ' ', ':', ' ', 224, 164, 184,
    224, 164, 168, 224, 164, 190, 224, 164, 164, 224, 164, 168,
    '-', 224, 164, 185, 224, 164, 191, 224, 164, 168, 224, 165,
    141, 224, 164, 166, 224, 165, 130, ',', ' ', 224, 164, 172,
    224, 165, 140, 224, 164, 166, 224, 165, 141, 224, 164, 167,
    ',', ' ', 224, 164, 156, 224, 165, 136, 224, 164, 168, ' ',
    224, 164, 164, 224, 164, 165, 224, 164, 190, ' ', 224, 164,
    184, 224, 164, 191, 224, 164, 150, ' ', 224, 164, 173, 224,
    164, 190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 174,
    224, 165, 135, 224, 164, 130, ' ', 224, 164, 185, 224, 165,
    128, ' ', 224, 164, 156, 224, 164, 168, 224, 165, 141, 224,
    164, 174, 224, 165, 135, ' ', 224, 164, 148, 224, 164, 176,
    ' ', 224, 164, 181, 224, 164, 191, 224, 164, 149, 224, 164,
    184, 224, 164, 191, 224, 164, 164, ' ', 224, 164, 185, 224,
    165, 129, 224, 164, 143, 224, 165, 164,  13,  10,  13,  10,
    224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164, 164,
    ' ', 224, 164, 173, 224, 165, 140, 224, 164, 151, 224, 165,
    139, 224, 164, 178, 224, 164, 191, 224, 164, 149, ' ', 224,
    164, 149, 224, 165, 141, 224, 164, 183, 224, 165, 135, 224,
    164, 164, 224, 165, 141, 224, 164, 176, 224, 164, 171, 224,
    164, 178, ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164,
    134, 224, 164, 167, 224, 164, 190, 224, 164, 176, ' ', 224,
    164, 170, 224, 164, 176, ' ', 224, 164, 181, 224, 164, 191,
    224, 164, 182, 224, 165, 141, 224, 164, 181, ' ', 224, 164,
    149, 224, 164, 190, ' ', 224, 164, 184, 224, 164, 190, 224,
    164, 164, 224, 164, 181, 224, 164, 190, 224, 164, 129, ' ',
    224, 164, 184, 224, 164, 172, 224, 164, 184, 224, 165, 135,
    ' ', 224, 164, 172, 224, 164, 161, 224, 164, 188, 224, 164,
    190, ' ', 224, 164, 176, 224, 164, 190, 224, 164, 183, 224,
    165, 141, 224, 164, 159, 224, 165, 141, 224, 164, 176, ' ',
    224, 164, 185, 224, 165, 136, 224, 165, 164, ' ', 224, 164,
    173, 224, 164, 190, 224, 164, 176, 224, 164, 164, ' ', 224,
    164, 149, 224, 165, 128, ' ', 224, 164, 176, 224, 164, 190,
    224, 164, 156, 224, 164, 167, 224, 164, 190, 224, 164, 168,
    224, 165, 128, ' ', 224, 164, 168, 224, 164, 136, ' ', 224,
    164, 166, 224, 164, 191, 224, 164, 178, 224, 165, 141, 224,
    164, 178, 224, 165, 128, ' ', 224, 164, 185, 224, 165, 136,
    224, 165, 164, ' ', 224, 164, 173, 224, 164, 190, 224, 164,
    176, 224, 164, 164, ' ', 224, 164, 149, 224, 165, 135, ' ',
    224, 164, 133, 224, 164, 168, 224, 165, 141, 224, 164, 175,
    ' ', 224, 164, 172, 224, 164, 161, 224, 164, 188, 224, 165,
    135, ' ', 224, 164, 174, 224, 164, 185, 224, 164, 190, 224,
    164, 168, 224, 164, 151, 224, 164, 176, ' ', 224, 164, 174,
    224, 165, 129, 224, 164, 174, 224, 165, 141, 224, 164, 172,
    224, 164, 136, ' ', '(', 224, 164, 172, 224, 164, 174, 224,
    165, 141, 224, 164, 172, 224, 164, 136, ')', ',', ' ', 224,
    164, 149, 224, 165, 139, 224, 164, 178, 224, 164, 149, 224,
    164, 190, 224, 164, 164, 224, 164, 190, ' ', '(', 224, 164,
    149, 224, 164, 178, 224, 164, 149, 224, 164, 164, 224, 165,
    141, 224, 164, 164, 224, 164, 190, ')', ' ', 224, 164, 148,
    224, 164, 176, ' ', 224, 164, 154, 224, 165, 135, 224, 164,
    168, 224, 165, 141, 224, 164, 168, 224, 164, 136, ' ', '(',
    224, 164, 174, 224, 164, 166, 224, 165, 141, 224, 164, 176,
    224, 164, 190, 224, 164, 184, ')', ' ', 224, 164, 185, 224,
    165, 136, 224, 164, 130, 224, 165, 164, ' ', 224, 165, 167,
    224, 165, 175, 224, 165, 170, 224, 165, 173, ' ', 224, 164,
    174, 224, 165, 135, 224, 164, 130, ' ', 224, 164, 184, 224,
    165, 141, 224, 164, 181, 224, 164, 164, 224, 164, 130, 224,
    164, 164, 224, 165, 141, 224, 164, 176, 224, 164, 164, 224,
    164, 190, ' ', 224, 164, 170, 224, 165, 141, 224, 164, 176,
    224, 164, 190, 224, 164, 170, 224, 165, 141, 224, 164, 164,
    224, 164, 191, ' ', 224, 164, 184, 224, 165, 135, ' ', 224,
    164, 170, 224, 165, 130, 224, 164, 176, 224, 165, 141, 224,
    164, 181, ' ', 224, 164, 172, 224, 165, 141, 224, 164, 176,
    224, 164, 191, 224, 164, 159, 224, 164, 191, 224, 164, 182,
    ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164,
    164, ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164, 176,
    224, 165, 130, 224, 164, 170, ' ', 224, 164, 174, 224, 165,
    135, 224, 164, 130, ' ', 224, 164, 172, 224, 165, 141, 224,
    164, 176, 224, 164, 191, 224, 164, 159, 224, 164, 191, 224,
    164, 182, ' ', 224, 164, 184, 224, 164, 190, 224, 164, 174,
    224, 165, 141, 224, 164, 176, 224, 164, 190, 224, 164, 156,
    224, 165, 141, 224, 164, 175, ' ', 224, 164, 149, 224, 165,
    135, ' ', 224, 164, 170, 224, 165, 141, 224, 164, 176, 224,
    164, 174, 224, 165, 129, 224, 164, 150, ' ', 224, 164, 133,
    224, 164, 130, 224, 164, 151, ' ', 224, 164, 173, 224, 164,
    190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 168, 224,
    165, 135, ' ', 224, 164, 181, 224, 164, 191, 224, 164, 151,
    224, 164, 164, ' ', 224, 165, 168, 224, 165, 166, ' ', 224,
    164, 181, 224, 164, 176, 224, 165, 141, 224, 164, 183, ' ',
    224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164,
    184, 224, 164, 190, 224, 164, 176, 224, 165, 141, 224, 164,
    165, 224, 164, 149, ' ', 224, 164, 170, 224, 165, 141, 224,
    164, 176, 224, 164, 151, 224, 164, 164, 224, 164, 191, ' ',
    224, 164, 149, 224, 165, 128, ' ', 224, 164, 185, 224, 165,
    136, ',', ' ', 224, 164, 181, 224, 164, 191, 224, 164, 182,
    224, 165, 135, 224, 164, 183, ' ', 224, 164, 176, 224, 165,
    130, 224, 164, 170, ' ', 224, 164, 184, 224, 165, 135, ' ',
    224, 164, 134, 224, 164, 176, 224, 165, 141, 224, 164, 165,
    224, 164, 191, 224, 164, 149, ' ', 224, 164, 148, 224, 164,
    176, ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224,
    164, 164, 224, 165, 128, 224, 164, 175, ' ', 224, 164, 184,
    224, 165, 135, 224, 164, 168, 224, 164, 190, ' ', 224, 164,
    143, 224, 164, 149, ' ', 224, 164, 149, 224, 165, 141, 224,
    164, 183, 224, 165, 135, 224, 164, 164, 224, 165, 141, 224,
    164, 176, 224, 165, 128, 224, 164, 175, ' ', 224, 164, 182,
    224, 164, 149, 224, 165, 141, 224, 164, 164, 224, 164, 191,
    ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 181, 224,
    164, 191, 224, 164, 182, 224, 165, 141, 224, 164, 181, 224,
    164, 181, 224, 165, 141, 224, 164, 175, 224, 164, 190, 224,
    164, 170, 224, 164, 149, ' ', 224, 164, 182, 224, 164, 149,
    224, 165, 141, 224, 164, 164, 224, 164, 191, ' ', 224, 164,
    185, 224, 165, 136, 224, 165, 164, ' ', 224, 164, 173, 224,
    164, 190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 181,
    224, 164, 191, 224, 164, 182, 224, 165, 141, 224, 164, 181,
    ' ', 224, 164, 149, 224, 165, 128, ' ', 224, 164, 166, 224,
    164, 184, 224, 164, 181, 224, 165, 128, 224, 164, 130, ' ',
    224, 164, 184, 224, 164, 172, 224, 164, 184, 224, 165, 135,
    ' ', 224, 164, 172, 224, 164, 161, 224, 164, 188, 224, 165,
    128, ' ', 224, 164, 133, 224, 164, 176, 224, 165, 141, 224,
    164, 165, 224, 164, 181, 224, 165, 141, 224, 164, 175, 224,
    164, 181, 224, 164, 184, 224, 165, 141, 224, 164, 165, 224,
    164, 190, ' ', 224, 164, 185, 224, 165, 136, 224, 165, 164,
    ' ', 224, 164, 185, 224, 164, 190, 224, 164, 178, ' ', 224,
    164, 149, 224, 165, 135, ' ', 224, 164, 181, 224, 164, 176,
    224, 165, 141, 224, 164, 183, 224, 165, 139, 224, 164, 130,
    ' ', 224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224,
    164, 173, 224, 164, 190, 224, 164, 176, 224, 164, 164, ' ',
    224, 164, 149, 224, 165, 128, ' ', 224, 164, 133, 224, 164,
    176, 224, 165, 141, 224, 164, 165, 224, 164, 181, 224, 165,
    141, 224, 164, 175, 224, 164, 181, 224, 164, 184, 224, 165,
    141, 224, 164, 165, 224, 164, 190, ' ', 224, 164, 168, 224,
    165, 135, ' ', 224, 164, 172, 224, 164, 185, 224, 165, 129,
    224, 164, 164, ' ', 224, 164, 170, 224, 165, 141, 224, 164,
    176, 224, 164, 151, 224, 164, 164, 224, 164, 191, ' ', 224,
    164, 149, 224, 165, 128, ' ', 224, 164, 185, 224, 165, 136,
    ',', ' ', 224, 164, 148, 224, 164, 176, ' ', 224, 164, 164,
    224, 164, 190, 224, 164, 156, 224, 164, 188, 224, 164, 190,
    ' ', 224, 164, 184, 224, 165, 141, 224, 164, 165, 224, 164,
    191, 224, 164, 164, 224, 164, 191, ' ', 224, 164, 174, 224,
    165, 135, 224, 164, 130, ' ', 224, 164, 173, 224, 164, 190,
    224, 164, 176, 224, 164, 164, ' ', 224, 164, 181, 224, 164,
    191, 224, 164, 182, 224, 165, 141, 224, 164, 181, ' ', 224,
    164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164, 164,
    224, 165, 128, 224, 164, 184, 224, 164, 176, 224, 165, 135,
    '-', 224, 164, 154, 224, 165, 140, 224, 164, 165, 224, 165,
    135, ' ', 224, 164, 184, 224, 165, 141, 224, 164, 165, 224,
    164, 190, 224, 164, 168, ' ', 224, 164, 170, 224, 164, 176,
    ' ', 224, 164, 185, 224, 165, 139, 224, 164, 168, 224, 165,
    135, ' ', 224, 164, 149, 224, 164, 190, ' ', 224, 164, 166,
    224, 164, 190, 224, 164, 181, 224, 164, 190, ' ', 224, 164,
    149, 224, 164, 176, 224, 164, 164, 224, 164, 190, ' ', 224,
    164, 185, 224, 165, 136, ' ', 224, 165, 164,  13,  10,  13,
     10, 224, 164, 173, 224, 164, 190, 224, 164, 176, 224, 164,
    164, ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164, 166,
    224, 165, 139, ' ', 224, 164, 134, 224, 164, 167, 224, 164,
    191, 224, 164, 149, 224, 164, 190, 224, 164, 176, 224, 164,
    191, 224, 164, 149, ' ', 224, 164, 168, 224, 164, 190, 224,
    164, 174, ' ', 224, 164, 185, 224, 165, 136, 224, 164, 130,
    '-', ' ', 224, 164, 185, 224, 164, 191, 224, 164, 168, 224,
    165, 141, 224, 164, 166, 224, 165, 128, ' ', 224, 164, 174,
    224, 165, 135, 224, 164, 130, ' ', 224, 164, 173, 224, 164,
    190, 224, 164, 176, 224, 164, 164, ' ', 224, 164, 148, 224,
    164, 176, ' ', 224, 164, 133, 224, 164, 130, 224, 164, 151,
    224, 165, 141, 224, 164, 176, 224, 165, 135, 224, 164, 156,
    224, 164, 188, 224, 165, 128, ' ', 224, 164, 174, 224, 165,
    135, 224, 164, 130, ' ', 224, 164, 135, 224, 164, 163, 224,
    165, 141, 224, 164, 161, 224, 164, 191, 224, 164, 175, 224,
    164, 190, ' ', '(', 'I', 'n', 'd', 'i', 'a', ')', 224, 165,
    164, ' ', 224, 164, 135, 224, 164, 163, 224, 165, 141, 224,
    164, 161, 224, 164, 191, 224, 164, 175, 224, 164, 190, ' ',
    224, 164, 168, 224, 164, 190, 224, 164, 174, ' ', 224, 164,
    149, 224, 165, 128, ' ', 224, 164, 137, 224, 164, 164, 224,
    165, 141, 224, 164, 170, 224, 164, 164, 224, 165, 141, 224,
    164, 164, 224, 164, 191, ' ', 224, 164, 184, 224, 164, 191,
    224, 164, 168, 224, 165, 141, 224, 164, 167, 224, 165, 129,
    ' ', 224, 164, 168, 224, 164, 166, 224, 165, 128, ' ', 224,
    164, 149, 224, 165, 135, ' ', 224, 164, 133, 224, 164, 130,
    224, 164, 151, 224, 165, 141, 224, 164, 176, 224, 165, 135,
    224, 164, 156, 224, 165, 128, ' ', 224, 164, 168, 224, 164,
    190, 224, 164, 174, ' ', '"', 224, 164, 135, 224, 164, 163,
    224, 165, 141, 224, 164, 161, 224, 164, 184, '"', ' ', 224,
    164, 184, 224, 165, 135, ' ', 224, 164, 185, 224, 165, 129,
    224, 164, 136, ' ', 224, 164, 185, 224, 165, 136, 224, 165,
    164, ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224,
    164, 164, ' ', 224, 164, 168, 224, 164, 190, 224, 164, 174,
    ',', ' ', 224, 164, 143, 224, 164, 149, ' ', 224, 164, 170,
    224, 165, 141, 224, 164, 176, 224, 164, 190, 224, 164, 154,
    224, 165, 128, 224, 164, 168, ' ', 224, 164, 185, 224, 164,
    191, 224, 164, 168, 224, 165, 141, 224, 164, 166, 224, 165,
    130, ' ', 224, 164, 184, 224, 164, 174, 224, 165, 141, 224,
    164, 176, 224, 164, 190, 224, 164, 159, ' ', 224, 164, 173,
    224, 164, 176, 224, 164, 164, ' ', 224, 164, 156, 224, 165,
    139, ' ', 224, 164, 149, 224, 164, 191, ' ', 224, 164, 174,
    224, 164, 168, 224, 165, 129, ' ', 224, 164, 149, 224, 165,
    135, ' ', 224, 164, 181, 224, 164, 130, 224, 164, 182, 224,
    164, 156, ' ', 224, 164, 139, 224, 164, 183, 224, 164, 173,
    224, 164, 166, 224, 165, 135, 224, 164, 181, ' ', 224, 164,
    149, 224, 165, 135, ' ', 224, 164, 156, 224, 165, 141, 224,
    164, 175, 224, 165, 135, 224, 164, 183, 224, 165, 141, 224,
    164, 160, ' ', 224, 164, 170, 224, 165, 129, 224, 164, 164,
    224, 165, 141, 224, 164, 176, ' ', 224, 164, 165, 224, 165,
    135, ' ', 224, 164, 164, 224, 164, 165, 224, 164, 190, ' ',
    224, 164, 156, 224, 164, 191, 224, 164, 168, 224, 164, 149,
    224, 165, 128, ' ', 224, 164, 149, 224, 164, 165, 224, 164,
    190, ' ', 224, 164, 182, 224, 165, 141, 224, 164, 176, 224,
    165, 128, 224, 164, 174, 224, 164, 166, 224, 165, 141, 224,
    164, 173, 224, 164, 190, 224, 164, 151, 224, 164, 181, 224,
    164, 164, ' ', 224, 164, 174, 224, 164, 185, 224, 164, 190,
    224, 164, 170, 224, 165, 129, 224, 164, 176, 224, 164, 190,
    224, 164, 163, ' ', 224, 164, 174, 224, 165, 135, 224, 164,
    130, ' ', 224, 164, 185, 224, 165, 136, ',', ' ', 224, 164,
    149, 224, 165, 135, ' ', 224, 164, 168, 224, 164, 190, 224,
    164, 174, ' ', 224, 164, 184, 224, 165, 135, ' ', 224, 164,
    178, 224, 164, 191, 224, 164, 175, 224, 164, 190, ' ', 224,
    164, 151, 224, 164, 175, 224, 164, 190, ' ', 224, 164, 185,
    224, 165, 136, 224, 165, 164, ' ', 224, 164, 173, 224, 164,
    190, 224, 164, 176, 224, 164, 164, ' ', '(', 224, 164, 173,
    224, 164, 190, ' ', '+', ' ', 224, 164, 176, 224, 164, 164,
    ')', ' ', 224, 164, 182, 224, 164, 172, 224, 165, 141, 224,
    164, 166, ' ', 224, 164, 149, 224, 164, 190, ' ', 224, 164,
    174, 224, 164, 164, 224, 164, 178, 224, 164, 172, ' ', 224,
    164, 185, 224, 165, 136, ' ', 224, 164, 134, 224, 164, 168,
    224, 165, 141, 224, 164, 164, 224, 164, 176, 224, 164, 191,
    224, 164, 149, ' ', 224, 164, 170, 224, 165, 141, 224, 164,
    176, 224, 164, 149, 224, 164, 190, 224, 164, 182, ' ', 224,
    164, 175, 224, 164, 190, ' ', 224, 164, 181, 224, 164, 191,
    224, 164, 166, 224, 165, 135, 224, 164, 149, '-', 224, 164,
    176, 224, 165, 130, 224, 164, 170, 224, 165, 128, ' ', 224,
    164, 170, 224, 165, 141, 224, 164, 176, 224, 164, 149, 224,
    164, 190, 224, 164, 182, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 178, 224, 165, 128, 224, 164,
    168, 224, 165, 164, ' ', 224, 164, 143, 224, 164, 149, ' ',
    224, 164, 164, 224, 165, 128, 224, 164, 184, 224, 164, 176,
    224, 164, 190, ' ', 224, 164, 168, 224, 164, 190, 224, 164,
    174, ' ', 224, 164, 185, 224, 164, 191, 224, 164, 168, 224,
    165, 141, 224, 164, 166, 224, 165, 129, 224, 164, 184, 224,
    165, 141, 224, 164, 164, 224, 164, 190, 224, 164, 168, ' ',
    224, 164, 173, 224, 165, 128, ' ', 224, 164, 185, 224, 165,
    136, ' ', 224, 164, 156, 224, 164, 191, 224, 164, 184, 224,
    164, 149, 224, 164, 190, ' ', 224, 164, 133, 224, 164, 176,
    224, 165, 141, 224, 164, 165, ' ', 224, 164, 185, 224, 164,
    191, 224, 164, 168, 224, 165, 141, 224, 164, 166, '(', 224,
    164, 185, 224, 164, 191, 224, 164, 168, 224, 165, 141, 224,
    164, 166, 224, 165, 130, ')', ' ', 224, 164, 149, 224, 165,
    128, ' ', 224, 164, 173, 224, 165, 130, 224, 164, 174, 224,
    164, 191, ' ', 224, 164, 185, 224, 165, 139, 224, 164, 164,
    224, 164, 190, ' ', 224, 164, 185, 224, 165, 136, ' ', 224,
    164, 156, 224, 165, 139, ' ', 224, 164, 149, 224, 164, 191,
    ' ', 224, 164, 170, 224, 165, 141, 224, 164, 176, 224, 164,
    190, 224, 164, 154, 224, 165, 128, 224, 164, 168, ' ', 224,
    164, 149, 224, 164, 190, 224, 164, 178, ' ', 224, 164, 139,
    224, 164, 183, 224, 164, 191, 224, 164, 175, 224, 165, 139,
    224, 164, 130, ' ', 224, 164, 166, 224, 165, 141, 224, 164,
    181, 224, 164, 190, 224, 164, 176, 224, 164, 190, ' ', 224,
    164, 166, 224, 164, 191, 224, 164, 175, 224, 164, 190, ' ',
    224, 164, 151, 224, 164, 175, 224, 164, 190, ' ', 224, 164,
    165, 224, 164, 190, 224, 165, 164, ' ', 224, 164, 170, 224,
    165, 141, 224, 164, 176, 224, 164, 190, 224, 164, 154, 224,
    165, 128, 224, 164, 168, ' ', 224, 164, 149, 224, 164, 190,
    224, 164, 178, ' ', 224, 164, 174, 224, 165, 135, 224, 164,
    130, ' ', 224, 164, 175, 224, 164, 185, ' ', 224, 164, 149,
    224, 164, 174, ' ', 224, 164, 170, 224, 165, 141, 224, 164,
    176, 224, 164, 175, 224, 165, 129, 224, 164, 149, 224, 165,
    141, 224, 164, 164, ' ', 224, 164, 185, 224, 165, 139, 224,
    164, 164, 224, 164, 190, ' ', 224, 164, 165, 224, 164, 190,
    ' ', 224, 164, 164, 224, 164, 165, 224, 164, 190, ' ', 224,
    164, 149, 224, 164, 190, 224, 164, 178, 224, 164, 190, 224,
    164, 168, 224, 165, 141, 224, 164, 164, 224, 164, 176, ' ',
    224, 164, 174, 224, 165, 135, 224, 164, 130, ' ', 224, 164,
    133, 224, 164, 167, 224, 164, 191, 224, 164, 149, ' ', 224,
    164, 170, 224, 165, 141, 224, 164, 176, 224, 164, 154, 224,
    164, 178, 224, 164, 191, 224, 164, 164, ' ', 224, 164, 185,
    224, 165, 129, 224, 164, 134, ' ', 224, 164, 181, 224, 164,
    191, 224, 164, 182, 224, 165, 135, 224, 164, 183, 224, 164,
    149, 224, 164, 176, ' ', 224, 164, 133, 224, 164, 176, 224,
    164, 172, '/', 224, 164, 136, 224, 164, 176, 224, 164, 190,
    224, 164, 168, ' ', 224, 164, 174, 224, 165, 135, 224, 164,
    130, 224, 165, 164, ' ', 224, 164, 173, 224, 164, 190, 224,
    164, 176, 224, 164, 164, ' ', 224, 164, 174, 224, 165, 135,
    224, 164, 130, ' ', 224, 164, 175, 224, 164, 185, ' ', 224,
    164, 168, 224, 164, 190, 224, 164, 174, ' ', 224, 164, 174,
    224, 165, 129, 224, 164, 151, 224, 164, 178, ' ', 224, 164,
    149, 224, 164, 190, 224, 164, 178, ' ', 224, 164, 184, 224,
    165, 135, ' ', 224, 164, 133, 224, 164, 167, 224, 164, 191,
    224, 164, 149, ' ', 224, 164, 170, 224, 165, 141, 224, 164,
    176, 224, 164, 154, 224, 164, 178, 224, 164, 191, 224, 164,
    164, ' ', 224, 164, 185, 224, 165, 129, 224, 164, 134, ' ',
    224, 164, 175, 224, 164, 166, 224, 165, 141, 224, 164, 175,
    224, 164, 170, 224, 164, 191, ' ', 224, 164, 135, 224, 164,
    184, 224, 164, 149, 224, 164, 190, ' ', 224, 164, 184, 224,
    164, 174, 224, 164, 149, 224, 164, 190, 224, 164, 178, 224,
    165, 128, 224, 164, 168, ' ', 224, 164, 137, 224, 164, 170,
    224, 164, 175, 224, 165, 139, 224, 164, 151, ' ', 224, 164,
    149, 224, 164, 174, ' ', 224, 164, 148, 224, 164, 176, ' ',
    224, 164, 170, 224, 165, 141, 224, 164, 176, 224, 164, 190,
    224, 164, 175, 224, 164, 131, ' ', 224, 164, 137, 224, 164,
    164, 224, 165, 141, 224, 164, 164, 224, 164, 176, 224, 165,
    128, ' ', 224, 164, 173, 224, 164, 190, 224, 164, 176, 224,
    164, 164, ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164,
    178, 224, 164, 191, 224, 164, 143, ' ', 224, 164, 185, 224,
    165, 139, 224, 164, 164, 224, 164, 190, ' ', 224, 164, 185,
    224, 165, 136, 224, 165, 164, ' ', 224, 164, 135, 224, 164,
    184, 224, 164, 149, 224, 165, 135, ' ', 224, 164, 133, 224,
    164, 164, 224, 164, 191, 224, 164, 176, 224, 164, 191, 224,
    164, 149, 224, 165, 141, 224, 164, 164, ' ', 224, 164, 173,
    224, 164, 190, 224, 164, 176, 224, 164, 164, 224, 164, 181,
    224, 164, 176, 224, 165, 141, 224, 164, 183, ' ', 224, 164,
    149, 224, 165, 139, ' ', 224, 164, 181, 224, 165, 136, 224,
    164, 166, 224, 164, 191, 224, 164, 149, ' ', 224, 164, 149,
    224, 164, 190, 224, 164, 178, ' ', 224, 164, 184, 224, 165,
    135, ' ', 224, 164, 134, 224, 164, 176, 224, 165, 141, 224,
    164, 175, 224, 164, 190, 224, 164, 181, 224, 164, 176, 224,
    165, 141, 224, 164, 164, ' ', '"', 224, 164, 156, 224, 164,
    174, 224, 165, 141, 224, 164, 172, 224, 165, 130, 224, 164,
    166, 224, 165, 141, 224, 164, 181, 224, 165, 128, 224, 164,
    170, '"', ' ', 224, 164, 148, 224, 164, 176, ' ', '"', 224,
    164, 133, 224, 164, 156, 224, 164, 168, 224, 164, 190, 224,
    164, 173, 224, 164, 166, 224, 165, 135, 224, 164, 182, '"',
    ' ', 224, 164, 149, 224, 165, 135, ' ', 224, 164, 168, 224,
    164, 190, 224, 164, 174, ' ', 224, 164, 184, 224, 165, 135,
    ' ', 224, 164, 173, 224, 165, 128, ' ', 224, 164, 156, 224,
    164, 190, 224, 164, 168, 224, 164, 190, ' ', 224, 164, 156,
    224, 164, 190, 224, 164, 164, 224, 164, 190, ' ', 224, 164,
    176, 224, 164, 185, 224, 164, 190, ' ', 224, 164, 185, 224,
    165, 136, 224, 165, 164, ' ', 224, 164, 172, 224, 164, 185,
    224, 165, 129, 224, 164, 164, ' ', 224, 164, 170, 224, 164,
    185, 224, 164, 178, 224, 165, 135, ' ', 224, 164, 175, 224,
    164, 185, ' ', 224, 164, 166, 224, 165, 135, 224, 164, 182,
    ' ','\'', 224, 164, 184, 224, 165, 139, 224, 164, 168, 224,
    165, 135, ' ', 224, 164, 149, 224, 165, 128, ' ', 224, 164,
    154, 224, 164, 191, 224, 164, 161, 224, 164, 188, 224, 164,
    191, 224, 164, 175, 224, 164, 190,'\'', ' ', 224, 164, 149,
    224, 165, 135, ' ', 224, 164, 176, 224, 165, 130, 224, 164,
    170, ' ', 224, 164, 174, 224, 165, 135, 224, 164, 130, ' ',
    224, 164, 156, 224, 164, 190, 224, 164, 168, 224, 164, 190,
    ' ', 224, 164, 156, 224, 164, 190, 224, 164, 164, 224, 164,
    190, ' ', 224, 164, 165, 224, 164, 190, 224, 165, 164, '[',
    '2', ']',  13,  10,  13,  10, 'F', 'r', 'e', 'n', 'c', 'h',
    ':',  13,  10,  13,  10, 'L', 'a', ' ', 'F', 'r', 'a', 'n',
    'c', 'e', ',', ' ', 'e', 'n', ' ', 'f', 'o', 'r', 'm', 'e',
    ' ', 'l', 'o', 'n', 'g', 'u', 'e', ' ', 'l', 'a', ' ', 'R',
    195, 169, 'p', 'u', 'b', 'l', 'i', 'q', 'u', 'e', ' ', 'f',
    'r', 'a', 'n', 195, 167, 'a', 'i', 's', 'e', ',', ' ', 'e',
    's', 't', ' ', 'u', 'n', 'e', ' ', 'r', 195, 169, 'p', 'u',
    'b', 'l', 'i', 'q', 'u', 'e', ' ', 'c', 'o', 'n', 's', 't',
    'i', 't', 'u', 't', 'i', 'o', 'n', 'n', 'e', 'l', 'l', 'e',
    ' ', 'u', 'n', 'i', 't', 'a', 'i', 'r', 'e', ' ', 'd', 'o',
    'n', 't', ' ', 'l', 'a', ' ', 'm', 'a', 'j', 'e', 'u', 'r',
    'e', ' ', 'p', 'a', 'r', 't', 'i', 'e', ' ', 'd', 'u', ' ',
    't', 'e', 'r', 'r', 'i', 't', 'o', 'i', 'r', 'e', ' ', 'e',
    't', ' ', 'd', 'e', ' ', 'l', 'a', ' ', 'p', 'o', 'p', 'u',
    'l', 'a', 't', 'i', 'o', 'n', ' ', 's', 'o', 'n', 't', ' ',
    's', 'i', 't', 'u', 195, 169, 's', ' ', 'e', 'n', ' ', 'E',
    'u', 'r', 'o', 'p', 'e', ' ', 'o', 'c', 'c', 'i', 'd', 'e',
    'n', 't', 'a', 'l', 'e', ',', ' ', 'm', 'a', 'i', 's', ' ',
    'q', 'u', 'i', ' ', 'c', 'o', 'm', 'p', 'r', 'e', 'n', 'd',
    ' ', 195, 169, 'g', 'a', 'l', 'e', 'm', 'e', 'n', 't', ' ',
    'p', 'l', 'u', 's', 'i', 'e', 'u', 'r', 's', ' ', 'r', 195,
    169, 'g', 'i', 'o', 'n', 's', ' ', 'e', 't', ' ', 't', 'e',
    'r', 'r', 'i', 't', 'o', 'i', 'r', 'e', 's', ' ', 'r', 195,
    169, 'p', 'a', 'r', 't', 'i', 's', ' ', 'd', 'a', 'n', 's',
    ' ', 'l', 'e', 's', ' ', 'A', 'm', 195, 169, 'r', 'i', 'q',
    'u', 'e', 's', ',', ' ', 'l', 226, 128, 153, 'o', 'c', 195,
    169, 'a', 'n', ' ', 'I', 'n', 'd', 'i', 'e', 'n', ' ', 'e',
    't', ' ', 'l','\'', 'o', 'c', 195, 169, 'a', 'n', ' ', 'P',
    'a', 'c', 'i', 'f', 'i', 'q', 'u', 'e', '.', ' ', 'E', 'l',
    'l', 'e', ' ', 'a', ' ', 'p', 'o', 'u', 'r', ' ', 'c', 'a',
    'p', 'i', 't', 'a', 'l', 'e', ' ', 'P', 'a', 'r', 'i', 's',
    ',', ' ', 'p', 'o', 'u', 'r', ' ', 'l', 'a', 'n', 'g', 'u',
    'e', ' ', 'o', 'f', 'f', 'i', 'c', 'i', 'e', 'l', 'l', 'e',
    ' ', 'l', 'e', ' ', 'f', 'r', 'a', 'n', 195, 167, 'a', 'i',
    's', ' ', 'e', 't', ' ', 'p', 'o', 'u', 'r', ' ', 'm', 'o',
    'n', 'n', 'a', 'i', 'e', ' ', 'l', 226, 128, 153, 'e', 'u',
    'r', 'o', '.', ' ', 'S', 'a', ' ', 'd', 'e', 'v', 'i', 's',
    'e', ' ', 'e', 's', 't', ' ', 194, 171, ' ', 'L', 'i', 'b',
    'e', 'r', 't', 195, 169, ',', ' ', 195, 137, 'g', 'a', 'l',
    'i', 't', 195, 169, ',', ' ', 'F', 'r', 'a', 't', 'e', 'r',
    'n', 'i', 't', 195, 169, ' ', 194, 187, ',', ' ', 'e', 't',
    ' ', 's', 'o', 'n', ' ', 'd', 'r', 'a', 'p', 'e', 'a', 'u',
    ' ', 'e', 's', 't', ' ', 'c', 'o', 'n', 's', 't', 'i', 't',
    'u', 195, 169, ' ', 'd', 'e', ' ', 't', 'r', 'o', 'i', 's',
    ' ', 'b', 'a', 'n', 'd', 'e', 's', ' ', 'v', 'e', 'r', 't',
    'i', 'c', 'a', 'l', 'e', 's', ' ', 'r', 'e', 's', 'p', 'e',
    'c', 't', 'i', 'v', 'e', 'm', 'e', 'n', 't', ' ', 'b', 'l',
    'e', 'u', 'e', ',', ' ', 'b', 'l', 'a', 'n', 'c', 'h', 'e',
    ' ', 'e', 't', ' ', 'r', 'o', 'u', 'g', 'e', '.', ' ', 'S',
    'o', 'n', ' ', 'h', 'y', 'm', 'n', 'e', ' ', 'e', 's', 't',
    ' ', 'L', 'a', ' ', 'M', 'a', 'r', 's', 'e', 'i', 'l', 'l',
    'a', 'i', 's', 'e', '.', ' ', 'S', 'o', 'n', ' ', 'p', 'r',
    'i', 'n', 'c', 'i', 'p', 'e', ' ', 'e', 's', 't', ' ', 'g',
    'o', 'u', 'v', 'e', 'r', 'n', 'e', 'm', 'e', 'n', 't', ' ',
    'd', 'u', ' ', 'p', 'e', 'u', 'p', 'l', 'e', ',', ' ', 'p',
    'a', 'r', ' ', 'l', 'e', ' ', 'p', 'e', 'u', 'p', 'l', 'e',
    ' ', 'e', 't', ' ', 'p', 'o', 'u', 'r', ' ', 'l', 'e', ' ',
    'p', 'e', 'u', 'p', 'l', 'e', '[', '3', ']', '.',  13,  10,
     13,  10, 'L', 'a', ' ', 'F', 'r', 'a', 'n', 'c', 'e', ' ',
    'e', 's', 't', ' ', 'u', 'n', ' ', 'p', 'a', 'y', 's', ' ',
    'a', 'n', 'c', 'i', 'e', 'n', ',', ' ', 'f', 'o', 'r', 'm',
    195, 169, ' ', 'a', 'u', ' ', 'H', 'a', 'u', 't', ' ', 'M',
    'o', 'y', 'e', 'n', ' ', 195, 130, 'g', 'e', '.', ' ', 'A',
    'u', ' ', 'X', 'I', 'X', 'e', ' ', 's', 'i', 195, 168, 'c',
    'l', 'e', ' ', 'e', 't', ' ', 'd', 'a', 'n', 's', ' ', 'l',
    'a', ' ', 'p', 'r', 'e', 'm', 'i', 195, 168, 'r', 'e', ' ',
    'm', 'o', 'i', 't', 'i', 195, 169, ' ', 'd', 'u', ' ', 'X',
    'X', 'e', ' ', 's', 'i', 195, 168, 'c', 'l', 'e', ',', ' ',
    'e', 'l', 'l', 'e', ' ', 'p', 'o', 's', 's', 195, 168, 'd',
    'e', ' ', 'u', 'n', ' ', 'v', 'a', 's', 't', 'e', ' ', 'e',
    'm', 'p', 'i', 'r', 'e', ' ', 'c', 'o', 'l', 'o', 'n', 'i',
    'a', 'l', '.', ' ', 195, 128, ' ', 'p', 'a', 'r', 't', 'i',
    'r', ' ', 'd', 'e', 's', ' ', 'a', 'n', 'n', 195, 169, 'e',
    's', ' ', '1', '9', '5', '0', ',', ' ', 'e', 'l', 'l', 'e',
    ' ', 'e', 's', 't', ' ', 'l', 226, 128, 153, 'u', 'n', ' ',
    'd', 'e', 's', ' ', 'a', 'c', 't', 'e', 'u', 'r', 's', ' ',
    'd', 'e', ' ', 'l', 'a', ' ', 'c', 'o', 'n', 's', 't', 'r',
    'u', 'c', 't', 'i', 'o', 'n', ' ', 'd', 'e', ' ', 'l', 226,
    128, 153, 'U', 'n', 'i', 'o', 'n', ' ', 'e', 'u', 'r', 'o',
    'p', 195, 169, 'e', 'n', 'n', 'e', '.', ' ', 'E', 'l', 'l',
    'e', ' ', 'e', 's', 't', ' ', 'u', 'n', 'e', ' ', 'p', 'u',
    'i', 's', 's', 'a', 'n', 'c', 'e', ' ', 'n', 'u', 'c', 'l',
    195, 169, 'a', 'i', 'r', 'e', ',', ' ', 'e', 't', ' ', 'l',
    226, 128, 153, 'u', 'n', ' ', 'd', 'e', 's', ' ', 'c', 'i',
    'n', 'q', ' ', 'm', 'e', 'm', 'b', 'r', 'e', 's', ' ', 'p',
    'e', 'r', 'm', 'a', 'n', 'e', 'n', 't', 's', ' ', 'd', 'u',
    ' ', 'C', 'o', 'n', 's', 'e', 'i', 'l', ' ', 'd', 'e', ' ',
    's', 195, 169, 'c', 'u', 'r', 'i', 't', 195, 169, ' ', 'd',
    'e', 's', ' ', 'N', 'a', 't', 'i', 'o', 'n', 's', ' ', 'u',
    'n', 'i', 'e', 's', '.', ' ', 'L', 'a', ' ', 'F', 'r', 'a',
    'n', 'c', 'e', ' ', 'j', 'o', 'u', 'e', ' ', 'u', 'n', ' ',
    'r', 195, 180, 'l', 'e', ' ', 'i', 'm', 'p', 'o', 'r', 't',
    'a', 'n', 't', ' ', 'd', 'a', 'n', 's', ' ', 'l', 226, 128,
    153, 'h', 'i', 's', 't', 'o', 'i', 'r', 'e', ' ', 'm', 'o',
    'n', 'd', 'i', 'a', 'l', 'e', ' ', 'p', 'a', 'r', ' ', 'l',
    226, 128, 153, 'i', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e',
    ' ', 'd', 'e', ' ', 's', 'a', ' ', 'c', 'u', 'l', 't', 'u',
    'r', 'e', ' ', 'e', 't', ' ', 'd', 'e', ' ', 's', 'e', 's',
    ' ', 'v', 'a', 'l', 'e', 'u', 'r', 's', ' ', 'd', 195, 169,
    'm', 'o', 'c', 'r', 'a', 't', 'i', 'q', 'u', 'e', 's', ',',
    ' ', 'l', 'a', 195, 175, 'q', 'u', 'e', 's', ' ', 'e', 't',
    ' ', 'r', 195, 169, 'p', 'u', 'b', 'l', 'i', 'c', 'a', 'i',
    'n', 'e', 's', '.',  13,  10,  13,  10, 'L', 'a', ' ', 'F',
    'r', 'a', 'n', 'c', 'e', ' ', 'a', ',', ' ', 'e', 'n', ' ',
    '2', '0', '1', '0', ',', ' ', 'l', 'e', ' ', 'c', 'i', 'n',
    'q', 'u', 'i', 195, 168, 'm', 'e', ' ', 'p', 'l', 'u', 's',
    ' ', 'i', 'm', 'p', 'o', 'r', 't', 'a', 'n', 't', ' ', 'p',
    'r', 'o', 'd', 'u', 'i', 't', ' ', 'i', 'n', 't', 195, 169,
    'r', 'i', 'e', 'u', 'r', ' ', 'b', 'r', 'u', 't', ' ', 'a',
    'u', ' ', 'm', 'o', 'n', 'd', 'e', '.', ' ', 'S', 'o', 'n',
    ' ', 195, 169, 'c', 'o', 'n', 'o', 'm', 'i', 'e', ',', ' ',
    'd', 'e', ' ', 't', 'y', 'p', 'e', ' ', 'c', 'a', 'p', 'i',
    't', 'a', 'l', 'i', 's', 't', 'e', ' ', 'a', 'v', 'e', 'c',
    ' ', 'u', 'n', 'e', ' ', 'i', 'n', 't', 'e', 'r', 'v', 'e',
    'n', 't', 'i', 'o', 'n', ' ', 195, 169, 't', 'a', 't', 'i',
    'q', 'u', 'e', ' ', 'a', 's', 's', 'e', 'z', ' ', 'f', 'o',
    'r', 't', 'e', ',', ' ', 'f', 'a', 'i', 't', ' ', 'd', 226,
    128, 153, 'e', 'l', 'l', 'e', ' ', 'u', 'n', ' ', 'd', 'e',
    's', ' ', 'l', 'e', 'a', 'd', 'e', 'r', 's', ' ', 'm', 'o',
    'n', 'd', 'i', 'a', 'u', 'x', ' ', 'd', 'a', 'n', 's', ' ',
    'l', 'e', 's', ' ', 's', 'e', 'c', 't', 'e', 'u', 'r', 's',
    ' ', 'd', 'e', ' ', 'l', 226, 128, 153, 'a', 'g', 'r', 'o',
    'a', 'l', 'i', 'm', 'e', 'n', 't', 'a', 'i', 'r', 'e', ',',
    ' ', 'd', 'e', ' ', 'l', 226, 128, 153, 'a', 195, 169, 'r',
    'o', 'n', 'a', 'u', 't', 'i', 'q', 'u', 'e', ',', ' ', 'd',
    'e', ' ', 'l', 226, 128, 153, 'a', 'u', 't', 'o', 'm', 'o',
    'b', 'i', 'l', 'e', ',', ' ', 'd', 'e', 's', ' ', 'p', 'r',
    'o', 'd', 'u', 'i', 't', 's', ' ', 'd', 'e', ' ', 'l', 'u',
    'x', 'e', ',', ' ', 'd', 'u', ' ', 't', 'o', 'u', 'r', 'i',
    's', 'm', 'e', ' ', 'e', 't', ' ', 'd', 'u', ' ', 'n', 'u',
    'c', 'l', 195, 169, 'a', 'i', 'r', 'e', '.',  13,  10,  13,
     10, 'P', 'e', 'u', 'p', 'l', 195, 169, 'e', ' ', 'd', 'e',
    ' ', '6', '5', ',', '3', ' ', 'm', 'i', 'l', 'l', 'i', 'o',
    'n', 's', ' ', 'd', 226, 128, 153, 'h', 'a', 'b', 'i', 't',
    'a', 'n', 't', 's', ' ', 'a', 'u', ' ', '1', 'e', 'r', ' ',
    'j', 'a', 'n', 'v', 'i', 'e', 'r', ' ', '2', '0', '1', '2',
    '[', '4', ']', ',', ' ', 'l', 'a', ' ', 'F', 'r', 'a', 'n',
    'c', 'e', ' ', 'e', 's', 't', ' ', 'u', 'n', ' ', 'p', 'a',
    'y', 's', ' ', 'd', 195, 169, 'v', 'e', 'l', 'o', 'p', 'p',
    195, 169, ',', ' ', 'a', 'v', 'e', 'c', ' ', 'u', 'n', ' ',
    'i', 'n', 'd', 'i', 'c', 'e', ' ', 'd', 'e', ' ', 'd', 195,
    169, 'v', 'e', 'l', 'o', 'p', 'p', 'e', 'm', 'e', 'n', 't',
    ' ', 'h', 'u', 'm', 'a', 'i', 'n', ' ', 't', 'r', 195, 168,
    's', ' ', 195, 169, 'l', 'e', 'v', 195, 169, '[', '5', ']',
    '.',  13,  10,  13,  10, 'L', 'a', ' ', 'F', 'r', 'a', 'n',
    'c', 'e', ' ', 'm', 195, 169, 't', 'r', 'o', 'p', 'o', 'l',
    'i', 't', 'a', 'i', 'n', 'e', ' ', 'e', 's', 't', ' ', 's',
    'i', 't', 'u', 195, 169, 'e', ' ', 195, 160, ' ', 'l', 226,
    128, 153, 'u', 'n', 'e', ' ', 'd', 'e', 's', ' ', 'e', 'x',
    't', 'r', 195, 169, 'm', 'i', 't', 195, 169, 's', ' ', 'o',
    'c', 'c', 'i', 'd', 'e', 'n', 't', 'a', 'l', 'e', 's', ' ',
    'd', 'e', ' ', 'l', 226, 128, 153, 'E', 'u', 'r', 'o', 'p',
    'e', '.', ' ', 'E', 'l', 'l', 'e', ' ', 'e', 's', 't', ' ',
    'b', 'o', 'r', 'd', 195, 169, 'e', ' ', 'p', 'a', 'r', ' ',
    'l', 'a', ' ', 'm', 'e', 'r', ' ', 'd', 'u', ' ', 'N', 'o',
    'r', 'd', ' ', 'a', 'u', ' ', 'n', 'o', 'r', 'd', ',', ' ',
    'l', 'a', ' ', 'M', 'a', 'n', 'c', 'h', 'e', ' ', 'a', 'u',
    ' ', 'n', 'o', 'r', 'd', '-', 'o', 'u', 'e', 's', 't', ',',
    ' ', 'l', 226, 128, 153, 'o', 'c', 195, 169, 'a', 'n', ' ',
    'A', 't', 'l', 'a', 'n', 't', 'i', 'q', 'u', 'e', ' ', 195,
    160, ' ', 'l', 226, 128, 153, 'o', 'u', 'e', 's', 't', ' ',
    'e', 't', ' ', 'l', 'a', ' ', 'm', 'e', 'r', ' ', 'M', 195,
    169, 'd', 'i', 't', 'e', 'r', 'r', 'a', 'n', 195, 169, 'e',
    ' ', 'a', 'u', ' ', 's', 'u', 'd', '-', 'e', 's', 't', '.',
    ' ', 'E', 'l', 'l', 'e', ' ', 'e', 's', 't', ' ', 'f', 'r',
    'o', 'n', 't', 'a', 'l', 'i', 195, 168, 'r', 'e', ' ', 'd',
    'e', ' ', 'l', 'a', ' ', 'B', 'e', 'l', 'g', 'i', 'q', 'u',
    'e', ' ', 'e', 't', ' ', 'd', 'u', ' ', 'L', 'u', 'x', 'e',
    'm', 'b', 'o', 'u', 'r', 'g', ' ', 'a', 'u', ' ', 'n', 'o',
    'r', 'd', '-', 'e', 's', 't', ',', ' ', 'd', 'e', ' ', 'l',
    226, 128, 153, 'A', 'l', 'l', 'e', 'm', 'a', 'g', 'n', 'e',
    ' ', 'e', 't', ' ', 'd', 'e', ' ', 'l', 'a', ' ', 'S', 'u',
    'i', 's', 's', 'e', ' ', 195, 160, ' ', 'l', 226, 128, 153,
    'e', 's', 't', ',', ' ', 'd', 'e', ' ', 'l', 226, 128, 153,
    'I', 't', 'a', 'l', 'i', 'e', ' ', 'e', 't', ' ', 'd', 'e',
    ' ', 'M', 'o', 'n', 'a', 'c', 'o', ' ', 'a', 'u', ' ', 's',
    'u', 'd', '-', 'e', 's', 't', ',', ' ', 'd', 'e', ' ', 'l',
    226, 128, 153, 'E', 's', 'p', 'a', 'g', 'n', 'e', ' ', 'e',
    't', ' ', 'd', 226, 128, 153, 'A', 'n', 'd', 'o', 'r', 'r',
    'e', ' ', 'a', 'u', ' ', 's', 'u', 'd', '-', 'o', 'u', 'e',
    's', 't', '.', ' ', 'S', 'i', ' ', 'l', 'e', 's', ' ', 'f',
    'r', 'o', 'n', 't', 'i', 195, 168, 'r', 'e', 's', ' ', 'd',
    'u', ' ', 's', 'u', 'd', ' ', 'd', 'u', ' ', 'p', 'a', 'y',
    's', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd',
    'e', 'n', 't', ' ', 195, 160, ' ', 'd', 'e', 's', ' ', 'm',
    'a', 's', 's', 'i', 'f', 's', ' ', 'm', 'o', 'n', 't', 'a',
    'g', 'n', 'e', 'u', 'x', ',', ' ', 'l', 'e', 's', ' ', 'f',
    'r', 'o', 'n', 't', 'i', 195, 168, 'r', 'e', 's', ' ', 'd',
    'u', ' ', 'n', 'o', 'r', 'd', '-', 'e', 's', 't', ' ', 'n',
    'e', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd',
    'e', 'n', 't', ' ', 195, 160, ' ', 'a', 'u', 'c', 'u', 'n',
    'e', ' ', 'l', 'i', 'm', 'i', 't', 'e', ' ', 'g', 195, 169,
    'o', 'g', 'r', 'a', 'p', 'h', 'i', 'q', 'u', 'e', '[', 'n',
    'o', 't', 'e', ' ', '6', ']', ' ', 'n', 'i', ' ', 'l', 'i',
    'n', 'g', 'u', 'i', 's', 't', 'i', 'q', 'u', 'e', '[', 'n',
    'o', 't', 'e', ' ', '7', ']', '.', ' ', 'L', 'a', ' ', 'F',
    'r', 'a', 'n', 'c', 'e', ' ', 'm', 195, 169, 't', 'r', 'o',
    'p', 'o', 'l', 'i', 't', 'a', 'i', 'n', 'e', ' ', 'c', 'o',
    'm', 'p', 'r', 'e', 'n', 'd', ' ', 'p', 'l', 'u', 's', 'i',
    'e', 'u', 'r', 's', ' ', 195, 174, 'l', 'e', 's', ',', ' ',
    'n', 'o', 't', 'a', 'm', 'm', 'e', 'n', 't', ' ', 'l', 'a',
    ' ', 'C', 'o', 'r', 's', 'e', ' ', 'e', 't', ' ', 'd', 'e',
    's', ' ', 195, 174, 'l', 'e', 's', ' ', 'c', 195, 180, 't',
    'i', 195, 168, 'r', 'e', 's', '.', ' ', 'L', 'a', ' ', 'm',
    195, 169, 't', 'r', 'o', 'p', 'o', 'l', 'e', ' ', 'e', 's',
    't', ' ', 'c', 'o', 'm', 'p', 'r', 'i', 's', 'e', ' ', 'e',
    'n', 't', 'r', 'e', ' ', 'l', 'e', 's', ' ', 'l', 'a', 't',
    'i', 't', 'u', 'd', 'e', 's', ' ', '4', '2', 194, 176, '1',
    '9','\'', '4', '6', '"', ' ', 'N', ' ', 'e', 't', ' ', '5',
    '1', 194, 176, '5','\'', '4', '7', '"', ' ', 'N', ',', ' ',
    'a', 'i', 'n', 's', 'i', ' ', 'q', 'u', 'e', ' ', 'l', 'e',
    's', ' ', 'l', 'o', 'n', 'g', 'i', 't', 'u', 'd', 'e', 's',
    ' ', '4', 194, 176, '4', '6','\'', ' ', 'O', ' ', 'e', 't',
    ' ', '8', 194, 176, '1', '4','\'', '4', '2', '"', ' ', 'E',
    '.',  13,  10,  13,  10, 'L', 'a', ' ', 'F', 'r', 'a', 'n',
    'c', 'e', ' ', 'c', 'o', 'm', 'p', 'r', 'e', 'n', 'd', ' ',
    195, 169, 'g', 'a', 'l', 'e', 'm', 'e', 'n', 't', ' ', 'd',
    'e', ' ', 'n', 'o', 'm', 'b', 'r', 'e', 'u', 'x', ' ', 't',
    'e', 'r', 'r', 'i', 't', 'o', 'i', 'r', 'e', 's', ' ', 's',
    'i', 't', 'u', 195, 169, 's', ' ', 'e', 'n', '-', 'd', 'e',
    'h', 'o', 'r', 's', ' ', 'd', 'u', ' ', 'c', 'o', 'n', 't',
    'i', 'n', 'e', 'n', 't', ' ', 'e', 'u', 'r', 'o', 'p', 195,
    169, 'e', 'n', ',', ' ', 'c', 'o', 'u', 'r', 'a', 'm', 'm',
    'e', 'n', 't', ' ', 'a', 'p', 'p', 'e', 'l', 195, 169, 's',
    ' ', 't', 'e', 'r', 'r', 'i', 't', 'o', 'i', 'r', 'e', 's',
    ' ', 'd', 226, 128, 153, 'o', 'u', 't', 'r', 'e', '-', 'm',
    'e', 'r', ',', ' ', 'n', 'a', 'g', 'u', 195, 168, 'r', 'e',
    ' ', 'D', 'O', 'M', '-', 'T', 'O', 'M', ',', ' ', 'q', 'u',
    'i', ' ', 'l', 'u', 'i', ' ', 'p', 'e', 'r', 'm', 'e', 't',
    't', 'e', 'n', 't', ' ', 'd', 226, 128, 153, 195, 170, 't',
    'r', 'e', ' ', 'p', 'r', 195, 169, 's', 'e', 'n', 't', 'e',
    ' ', 'd', 'a', 'n', 's', ' ', 't', 'o', 'u', 's', ' ', 'l',
    'e', 's', ' ', 'o', 'c', 195, 169, 'a', 'n', 's', '.', ' ',
    'C', 'e', 's', ' ', 't', 'e', 'r', 'r', 'i', 't', 'o', 'i',
    'r', 'e', 's', ' ', 'a', 'u', 'x', ' ', 's', 't', 'a', 't',
    'u', 't', 's', ' ', 'v', 'a', 'r', 'i', 195, 169, 's', ' ',
    's', 'o', 'n', 't', '[', '6', ']', ' ', ':',  13,  10,  13,
     10, 's', 'u', 'r', ' ', 'l', 'e', ' ', 'c', 'o', 'n', 't',
    'i', 'n', 'e', 'n', 't', ' ', 's', 'u', 'd', '-', 'a', 'm',
    195, 169, 'r', 'i', 'c', 'a', 'i', 'n', ' ', ':', ' ', 'l',
    'a', ' ', 'G', 'u', 'y', 'a', 'n', 'e', ' ', ';',  13,  10,
    'd', 'a', 'n', 's', ' ', 'l', 226, 128, 153, 'o', 'c', 195,
    169, 'a', 'n', ' ', 'A', 't', 'l', 'a', 'n', 't', 'i', 'q',
    'u', 'e', ' ', '(', 'A', 'n', 't', 'i', 'l', 'l', 'e', 's',
    ')', ' ', ':', ' ', 'l', 'a', ' ', 'G', 'u', 'a', 'd', 'e',
    'l', 'o', 'u', 'p', 'e', ',', ' ', 'l', 'a', ' ', 'M', 'a',
    'r', 't', 'i', 'n', 'i', 'q', 'u', 'e', ',', ' ', 'S', 'a',
    'i', 'n', 't', '-', 'P', 'i', 'e', 'r', 'r', 'e', '-', 'e',
    't', '-', 'M', 'i', 'q', 'u', 'e', 'l', 'o', 'n', ',', ' ',
    'S', 'a', 'i', 'n', 't', '-', 'M', 'a', 'r', 't', 'i', 'n',
    ' ', 'e', 't', ' ', 'S', 'a', 'i', 'n', 't', '-', 'B', 'a',
    'r', 't', 'h', 195, 169, 'l', 'e', 'm', 'y', ' ', ';',  13,
     10, 'd', 'a', 'n', 's', ' ', 'l', 226, 128, 153, 'o', 'c',
    195, 169, 'a', 'n', ' ', 'P', 'a', 'c', 'i', 'f', 'i', 'q',
    'u', 'e', ' ', ':', ' ', 'l', 'a', ' ', 'P', 'o', 'l', 'y',
    'n', 195, 169, 's', 'i', 'e', ' ', 'f', 'r', 'a', 'n', 195,
    167, 'a', 'i', 's', 'e', ',', ' ', 'l', 'a', ' ', 'N', 'o',
    'u', 'v', 'e', 'l', 'l', 'e', '-', 'C', 'a', 'l', 195, 169,
    'd', 'o', 'n', 'i', 'e', ',', ' ', 'W', 'a', 'l', 'l', 'i',
    's', '-', 'e', 't', '-', 'F', 'u', 't', 'u', 'n', 'a', ' ',
    'e', 't', ' ', 'C', 'l', 'i', 'p', 'p', 'e', 'r', 't', 'o',
    'n', ' ', ';',  13,  10, 'd', 'a', 'n', 's', ' ', 'l', 226,
    128, 153, 'o', 'c', 195, 169, 'a', 'n', ' ', 'I', 'n', 'd',
    'i', 'e', 'n', ' ', ':', ' ', 'L', 'a', ' ', 'R', 195, 169,
    'u', 'n', 'i', 'o', 'n', ',', ' ', 'M', 'a', 'y', 'o', 't',
    't', 'e', ',', ' ', 'l', 'e', 's', ' ', 195, 142, 'l', 'e',
    's', ' ', 195, 137, 'p', 'a', 'r', 's', 'e', 's', ',', ' ',
    'l', 'e', 's', ' ', 195, 142, 'l', 'e', 's', ' ', 'C', 'r',
    'o', 'z', 'e', 't', ',', ' ', 'l', 'e', 's', ' ', 195, 142,
    'l', 'e', 's', ' ', 'K', 'e', 'r', 'g', 'u', 'e', 'l', 'e',
    'n', ' ', 'e', 't', ' ', 'S', 'a', 'i', 'n', 't', '-', 'P',
    'a', 'u', 'l', '-', 'e', 't', '-', 'A', 'm', 's', 't', 'e',
    'r', 'd', 'a', 'm', ' ', ';',  13,  10, 'e', 'n', ' ', 'A',
    'n', 't', 'a', 'r', 'c', 't', 'i', 'q', 'u', 'e', ' ', ':',
    ' ', 'l', 'a', ' ', 'T', 'e', 'r', 'r', 'e', ' ', 'A', 'd',
    195, 169, 'l', 'i', 'e', '[', 'n', 'o', 't', 'e', ' ', '8',
    ']', '.',  13,  10, 195, 128, ' ', 't', 'r', 'a', 'v', 'e',
    'r', 's', ' ', 's', 'e', 's', ' ', 'c', 'o', 'l', 'l', 'e',
    'c', 't', 'i', 'v', 'i', 't', 195, 169, 's', ' ', 'u', 'l',
    't', 'r', 'a', '-', 'm', 'a', 'r', 'i', 'n', 'e', 's', ',',
    ' ', 'l', 'a', ' ', 'F', 'r', 'a', 'n', 'c', 'e', ' ', 'p',
    'o', 's', 's', 195, 168, 'd', 'e', ' ', 195, 169, 'g', 'a',
    'l', 'e', 'm', 'e', 'n', 't', ' ', 'd', 'e', 's', ' ', 'f',
    'r', 'o', 'n', 't', 'i', 195, 168, 'r', 'e', 's', ' ', 't',
    'e', 'r', 'r', 'e', 's', 't', 'r', 'e', 's', ' ', 'a', 'v',
    'e', 'c', ' ', 'l', 'e', ' ', 'B', 'r', 195, 169, 's', 'i',
    'l', ' ', 'e', 't', ' ', 'l', 'e', ' ', 'S', 'u', 'r', 'i',
    'n', 'a', 'm', 'e', ',', ' ', 'a', 'i', 'n', 's', 'i', ' ',
    'q', 'u', 226, 128, 153, 'a', 'v', 'e', 'c', ' ', 'l', 'e',
    's', ' ', 'P', 'a', 'y', 's', '-', 'B', 'a', 's', ' ', 'v',
    'i', 'a', ' ', 'l', 'a', ' ', 'p', 'a', 'r', 't', 'i', 'e',
    ' ', 'f', 'r', 'a', 'n', 195, 167, 'a', 'i', 's', 'e', ' ',
    'd', 'e', ' ', 'S', 'a', 'i', 'n', 't', '-', 'M', 'a', 'r',
    't', 'i', 'n', '.',  13,  10,  13,  10, 'L', 'a', ' ', 's',
    'u', 'p', 'e', 'r', 'f', 'i', 'c', 'i', 'e', ' ', 'd', 'e',
    ' ', 'l', 'a', ' ', 'F', 'r', 'a', 'n', 'c', 'e', ' ', 'e',
    's', 't', ' ', 'd', 'e', ' ', '6', '7', '0', ' ', '9', '2',
    '2', ' ', 'k', 'm', 194, 178, ',', ' ', 'o', 'u', ' ', '5',
    '4', '7', ' ', '0', '3', '0', ' ', 's', 'a', 'n', 's', ' ',
    'c', 'o', 'm', 'p', 't', 'a', 'b', 'i', 'l', 'i', 's', 'e',
    'r', ' ', 'l', 226, 128, 153, 'o', 'u', 't', 'r', 'e', '-',
    'm', 'e', 'r', '[', '7', ']', '.', ' ', 'E', 'l', 'l', 'e',
    ' ', 'e', 's', 't', ' ', 'l', 'e', ' ', '4', '1', 'e', ' ',
    'p', 'l', 'u', 's', ' ', 'g', 'r', 'a', 'n', 'd', ' ', 195,
    137, 't', 'a', 't', ' ', 'd', 'u', ' ', 'm', 'o', 'n', 'd',
    'e', ' ', 'p', 'a', 'r', ' ', 's', 'a', ' ', 's', 'u', 'r',
    'f', 'a', 'c', 'e', ' ', 't', 'e', 'r', 'r', 'e', 's', 't',
    'r', 'e', '[', '7', ']', ' ', 'e', 't', ' ', 'l', 'e', ' ',
    'd', 'e', 'u', 'x', 'i', 195, 168, 'm', 'e', ' ', 'p', 'a',
    'r', ' ', 's', 'a', ' ', 'z', 'o', 'n', 'e', ' ', 195, 169,
    'c', 'o', 'n', 'o', 'm', 'i', 'q', 'u', 'e', ' ', 'e', 'x',
    'c', 'l', 'u', 's', 'i', 'v', 'e', '[', '8', ']', '.', ' ',
    'E', 'l', 'l', 'e', ' ', 'e', 's', 't', ' ', 'e', 'n', ' ',
    'o', 'u', 't', 'r', 'e', ' ', 'l', 'e', ' ', 't', 'r', 'o',
    'i', 's', 'i', 195, 168, 'm', 'e', ' ', 'p', 'l', 'u', 's',
    ' ', 'g', 'r', 'a', 'n', 'd', ' ', 'p', 'a', 'y', 's', ' ',
    'd', 226, 128, 153, 'E', 'u', 'r', 'o', 'p', 'e', ',', ' ',
    'a', 'p', 'r', 195, 168, 's', ' ', 'l', 'a', ' ', 'R', 'u',
    's', 's', 'i', 'e', ' ', 'e', 't', ' ', 'l', 226, 128, 153,
    'U', 'k', 'r', 'a', 'i', 'n', 'e', ',', ' ', 'd', 'e', 'u',
    'x', 'i', 195, 168, 'm', 'e', ' ', 's', 'i', ' ', 'o', 'n',
    ' ', 'i', 'n', 'c', 'l', 'u', 't', ' ', 'l', 'e', 's', ' ',
    'd', 195, 169, 'p', 'a', 'r', 't', 'e', 'm', 'e', 'n', 't',
    's', ' ', 'u', 'l', 't', 'r', 'a', '-', 'm', 'a', 'r', 'i',
    'n', 's', ',', ' ', 'e', 't', ' ', 'l', 'e', ' ', 'p', 'l',
    'u', 's', ' ', 'g', 'r', 'a', 'n', 'd', ' ', 'd', 'e', ' ',
    'l', 226, 128, 153, 'U', 'n', 'i', 'o', 'n', ' ', 'e', 'u',
    'r', 'o', 'p', 195, 169, 'e', 'n', 'n', 'e', '[', '7', ']',
    '.', ' ', 'S', 'o', 'n', ' ', 't', 'e', 'r', 'r', 'i', 't',
    'o', 'i', 'r', 'e', ' ', 'm', 195, 169, 't', 'r', 'o', 'p',
    'o', 'l', 'i', 't', 'a', 'i', 'n', ' ', 'c', 'o', 'n', 't',
    'i', 'n', 'e', 'n', 't', 'a', 'l', ' ', 's', 226, 128, 153,
    195, 169, 't', 'e', 'n', 'd', ' ', 's', 'u', 'r', ' ', 'e',
    'n', 'v', 'i', 'r', 'o', 'n', ' ', '1', ' ', '0', '0', '0',
    ' ', 'k', 'm', ' ', 'd', 'u', ' ', 'n', 'o', 'r', 'd', ' ',
    'a', 'u', ' ', 's', 'u', 'd', ' ', 'e', 't', ' ', 'd', 226,
    128, 153, 'e', 's', 't', ' ', 'e', 'n', ' ', 'o', 'u', 'e',
    's', 't', '.', ' ', 'L', 226, 128, 153, 195, 169, 't', 'e',
    'n', 'd', 'u', 'e', ' ', 'd', 'e', ' ', 's', 'o', 'n', ' ',
    'l', 'i', 't', 't', 'o', 'r', 'a', 'l', ',', ' ', 'o', 'u',
    't', 'r', 'e', '-', 'm', 'e', 'r', ' ', 'i', 'n', 'c', 'l',
    'u', 's', ',', ' ', 'e', 's', 't', ' ', 'd', 'e', ' ', '8',
    ' ', '2', '4', '5', ' ', 'k', 'm', '[', '9', ']', '.',  13,
     10,  13,  10, 'G', 'r', 'e', 'e', 'k', ':',  13,  10,  13,
     10, 206, 151, ' ', 206, 149, 206, 187, 206, 187, 206, 172,
    206, 180, 206, 177, ' ', '(', 207, 128, 206, 177, 206, 187,
    206, 177, 206, 185, 207, 140, 207, 132, 206, 181, 207, 129,
    206, 177, ':', ' ', 225, 188, 153, 206, 187, 206, 187, 206,
    172, 207, 130, ',', ' ', 206, 181, 207, 128, 206, 175, 207,
    131, 206, 183, 206, 188, 206, 177, ':', ' ', 206, 149, 206,
    187, 206, 187, 206, 183, 206, 189, 206, 185, 206, 186, 206,
    174, ' ', 206, 148, 206, 183, 206, 188, 206, 191, 206, 186,
    207, 129, 206, 177, 207, 132, 206, 175, 206, 177, ')', ' ',
    206, 181, 206, 175, 206, 189, 206, 177, 206, 185, ' ', 207,
    135, 207, 142, 207, 129, 206, 177, ' ', 207, 128, 206, 191,
    207, 133, ' ', 206, 178, 207, 129, 206, 175, 207, 131, 206,
    186, 206, 181, 207, 132, 206, 177, 206, 185, ' ', 207, 131,
    207, 132, 206, 183, ' ', 206, 189, 206, 191, 207, 132, 206,
    185, 206, 191, 206, 177, 206, 189, 206, 177, 207, 132, 206,
    191, 206, 187, 206, 185, 206, 186, 206, 174, ' ', 206, 149,
    207, 133, 207, 129, 207, 142, 207, 128, 206, 183, ',', ' ',
    207, 131, 207, 132, 206, 191, ' ', 206, 189, 206, 191, 207,
    132, 206, 185, 207, 140, 207, 132, 206, 181, 207, 129, 206,
    191, ' ', 206, 172, 206, 186, 207, 129, 206, 191, ' ', 207,
    132, 206, 183, 207, 130, ' ', 206, 146, 206, 177, 206, 187,
    206, 186, 206, 177, 206, 189, 206, 185, 206, 186, 206, 174,
    207, 130, ' ', 207, 135, 206, 181, 207, 129, 207, 131, 206,
    191, 206, 189, 206, 174, 207, 131, 206, 191, 207, 133, ',',
    ' ', 207, 131, 207, 132, 206, 183, 206, 189, ' ', 206, 145,
    206, 189, 206, 177, 207, 132, 206, 191, 206, 187, 206, 185,
    206, 186, 206, 174, ' ', 206, 156, 206, 181, 207, 131, 207,
    140, 206, 179, 206, 181, 206, 185, 206, 191, '.', 206, 160,
    207, 129, 207, 137, 207, 132, 206, 181, 207, 141, 206, 191,
    207, 133, 207, 131, 206, 177, ' ', 207, 132, 206, 183, 207,
    130, ' ', 206, 149, 206, 187, 206, 187, 206, 172, 206, 180,
    206, 191, 207, 130, ' ', 206, 186, 206, 177, 206, 185, ' ',
    206, 188, 206, 181, 206, 179, 206, 177, 206, 187, 207, 141,
    207, 132, 206, 181, 207, 129, 206, 183, ' ', 207, 128, 207,
    140, 206, 187, 206, 183, ' ', 206, 181, 206, 175, 206, 189,
    206, 177, 206, 185, ' ', 206, 183, ' ', 206, 145, 206, 184,
    206, 174, 206, 189, 206, 177, '.',  13,  10,  13,  10, 206,
    163, 207, 133, 206, 189, 206, 191, 207, 129, 206, 181, 207,
    141, 206, 181, 206, 185, ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 178, 206, 191, 207, 129, 206, 181, 206, 185, 206,
    191, 206, 180, 207, 133, 207, 132, 206, 185, 206, 186, 206,
    172, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, 206,
    189, ' ', 206, 145, 206, 187, 206, 178, 206, 177, 206, 189,
    206, 175, 206, 177, ',', ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 178, 207, 140, 207, 129, 206, 181, 206, 185, 206,
    177, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, ' ',
    206, 146, 206, 191, 207, 133, 206, 187, 206, 179, 206, 177,
    207, 129, 206, 175, 206, 177, ' ', 206, 186, 206, 177, 206,
    185, ' ', 207, 132, 206, 183, 206, 189, ' ', 207, 128, 207,
    129, 207, 142, 206, 183, 206, 189, ' ', 206, 147, 206, 185,
    206, 191, 207, 133, 206, 179, 206, 186, 206, 191, 207, 131,
    206, 187, 206, 177, 206, 178, 206, 185, 206, 186, 206, 174,
    ' ', 206, 148, 206, 183, 206, 188, 206, 191, 206, 186, 207,
    129, 206, 177, 207, 132, 206, 175, 206, 177, ' ', 207, 132,
    206, 183, 207, 130, ' ', 206, 156, 206, 177, 206, 186, 206,
    181, 206, 180, 206, 191, 206, 189, 206, 175, 206, 177, 207,
    130, ' ', '(', 207, 128, '.', 206, 147, '.', 206, 148, '.',
    206, 156, '.', ')', ' ', 206, 186, 206, 177, 206, 185, ' ',
    207, 131, 207, 132, 206, 177, ' ', 206, 178, 206, 191, 207,
    129, 206, 181, 206, 185, 206, 191, 206, 177, 206, 189, 206,
    177, 207, 132, 206, 191, 206, 187, 206, 185, 206, 186, 206,
    172, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, 206,
    189, ' ', 206, 164, 206, 191, 207, 133, 207, 129, 206, 186,
    206, 175, 206, 177, '.', ' ', 206, 146, 207, 129, 206, 173,
    207, 135, 206, 181, 207, 132, 206, 177, 206, 185, ' ', 207,
    131, 207, 132, 206, 177, ' ', 206, 177, 206, 189, 206, 177,
    207, 132, 206, 191, 206, 187, 206, 185, 206, 186, 206, 172,
    ' ', 206, 177, 207, 128, 207, 140, ' ', 207, 132, 206, 191,
    ' ', 206, 145, 206, 185, 206, 179, 206, 177, 206, 175, 206,
    191, ' ', 206, 160, 206, 173, 206, 187, 206, 177, 206, 179,
    206, 191, 207, 130, ',', ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 180, 207, 133, 207, 132, 206, 185, 206, 186, 206,
    172, ' ', 206, 177, 207, 128, 207, 140, ' ', 207, 132, 206,
    191, ' ', 206, 153, 207, 140, 206, 189, 206, 185, 206, 191,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 189, 207, 140,
    207, 132, 206, 185, 206, 177, ' ', 206, 177, 207, 128, 207,
    140, ' ', 207, 132, 206, 183, ' ', 206, 156, 206, 181, 207,
    131, 207, 140, 206, 179, 206, 181, 206, 185, 206, 191, ' ',
    206, 152, 206, 172, 206, 187, 206, 177, 207, 131, 207, 131,
    206, 177, '.', 206, 151, ' ', 206, 149, 206, 187, 206, 187,
    206, 172, 206, 180, 206, 177, ' ', 206, 186, 206, 177, 207,
    132, 206, 173, 207, 135, 206, 181, 206, 185, ' ', 207, 132,
    206, 183, 206, 189, ' ', '1', '1', 206, 183, ' ', 206, 184,
    206, 173, 207, 131, 206, 183, ' ', 207, 131, 207, 132, 206,
    185, 207, 130, ' ', 207, 135, 207, 142, 207, 129, 206, 181,
    207, 130, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183,
    ' ', 206, 188, 206, 181, 206, 179, 206, 177, 206, 187, 207,
    141, 207, 132, 206, 181, 207, 129, 206, 183, ' ', 206, 177,
    206, 186, 207, 132, 206, 191, 206, 179, 207, 129, 206, 177,
    206, 188, 206, 188, 206, 174, ' ', 207, 131, 207, 132, 206,
    177, ' ', '1', '3', '.', '6', '7', '6', ' ', 207, 135, 206,
    185, 206, 187, 206, 185, 207, 140, 206, 188, 206, 181, 207,
    132, 207, 129, 206, 177, ' ', 206, 186, 206, 177, 206, 184,
    207, 142, 207, 130, ' ', 206, 181, 207, 135, 206, 181, 206,
    185, ' ', 207, 128, 206, 191, 206, 187, 206, 187, 206, 172,
    ' ', 206, 189, 206, 183, 207, 131, 206, 185, 206, 172, ' ',
    '(', 207, 128, 206, 181, 207, 129, 206, 175, 207, 128, 206,
    191, 207, 133, ' ', '1', '.', '4', '0', '0', ',', ' ', 206,
    181, 206, 186, 207, 132, 207, 137, 206, 189, ' ', 206, 191,
    207, 128, 206, 191, 206, 175, 207, 137, 206, 189, ' ', 207,
    132, 206, 177, ' ', '2', '2', '7', ' ', 206, 186, 206, 177,
    207, 132, 206, 191, 206, 185, 206, 186, 206, 191, 207, 133,
    206, 189, 207, 132, 206, 177, 206, 185, ')', ',', ' ', 207,
    131, 207, 133, 206, 188, 207, 128, 206, 181, 207, 129, 206,
    185, 206, 187, 206, 177, 206, 188, 206, 178, 206, 177, 206,
    189, 206, 191, 206, 188, 206, 173, 206, 189, 207, 137, 206,
    189, ' ', 207, 132, 206, 183, 207, 130, ' ', 206, 154, 207,
    129, 206, 183, 207, 132, 206, 183, 207, 130, ',', ' ', 207,
    132, 207, 137, 206, 189, ' ', 206, 148, 207, 137, 206, 180,
    206, 181, 206, 186, 206, 177, 206, 189, 206, 174, 207, 131,
    207, 137, 206, 189, ',', ' ', 207, 132, 207, 137, 206, 189,
    ' ', 206, 154, 207, 133, 206, 186, 206, 187, 206, 172, 206,
    180, 207, 137, 206, 189, ',', ' ', 207, 132, 207, 137, 206,
    189, ' ', 206, 149, 207, 128, 207, 132, 206, 177, 206, 189,
    206, 174, 207, 131, 207, 137, 206, 189, ' ', 206, 186, 206,
    177, 206, 185, ' ', 207, 128, 206, 191, 206, 187, 206, 187,
    207, 142, 206, 189, ' ', 206, 172, 206, 187, 206, 187, 207,
    137, 206, 189, '.', 206, 164, 206, 191, ' ', 207, 136, 206,
    183, 206, 187, 207, 140, 207, 132, 206, 181, 207, 129, 206,
    191, ' ', 206, 178, 206, 191, 207, 133, 206, 189, 207, 140,
    ' ', 206, 181, 206, 175, 206, 189, 206, 177, 206, 185, ' ',
    206, 191, ' ', 206, 140, 206, 187, 207, 133, 206, 188, 207,
    128, 206, 191, 207, 130, ' ', 206, 186, 206, 177, 206, 185,
    ' ', 207, 132, 206, 191, ' ', 206, 188, 206, 181, 206, 179,
    206, 177, 206, 187, 207, 141, 207, 132, 206, 181, 207, 129,
    206, 191, ' ', 207, 128, 206, 191, 207, 132, 206, 172, 206,
    188, 206, 185, ' ', 206, 191, ' ', 206, 145, 206, 187, 206,
    185, 206, 172, 206, 186, 206, 188, 206, 191, 206, 189, 206,
    177, 207, 130, '.',  13,  10,  13,  10, 206, 136, 207, 135,
    206, 181, 206, 185, ' ', 206, 188, 206, 177, 206, 186, 207,
    129, 206, 172, ' ', 206, 186, 206, 177, 206, 185, ' ', 207,
    128, 206, 187, 206, 191, 207, 141, 207, 131, 206, 185, 206,
    177, ' ', 206, 185, 207, 131, 207, 132, 206, 191, 207, 129,
    206, 175, 206, 177, ' ', 206, 186, 206, 177, 207, 132, 206,
    172, ' ', 207, 132, 206, 183, 206, 189, ' ', 206, 191, 207,
    128, 206, 191, 206, 175, 206, 177, ' ', 206, 172, 207, 131,
    206, 186, 206, 183, 207, 131, 206, 181, ' ', 206, 188, 206,
    181, 206, 179, 206, 172, 206, 187, 206, 183, ' ', 207, 128,
    206, 191, 206, 187, 206, 185, 207, 132, 206, 185, 207, 131,
    206, 188, 206, 185, 206, 186, 206, 174, ' ', 206, 181, 207,
    128, 206, 175, 206, 180, 207, 129, 206, 177, 207, 131, 206,
    183, ' ', 207, 131, 206, 181, ' ', 207, 132, 207, 129, 206,
    181, 206, 185, 207, 130, ' ', 206, 183, 207, 128, 206, 181,
    206, 175, 207, 129, 206, 191, 207, 133, 207, 130, '.', 206,
    149, 206, 180, 207, 142, ' ', 206, 179, 206, 181, 206, 189,
    206, 189, 206, 174, 206, 184, 206, 183, 206, 186, 206, 181,
    ' ', 206, 183, ' ', 206, 180, 206, 183, 206, 188, 206, 191,
    206, 186, 207, 129, 206, 177, 207, 132, 206, 175, 206, 177,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 183, ' ', 207,
    134, 206, 185, 206, 187, 206, 191, 207, 131, 206, 191, 207,
    134, 206, 175, 206, 177, '.', 206, 145, 206, 186, 207, 140,
    206, 188, 206, 188, 206, 177, ' ', 206, 183, ' ', 206, 149,
    206, 187, 206, 187, 206, 172, 206, 180, 206, 177, ' ', 206,
    181, 206, 175, 206, 189, 206, 177, 206, 185, ' ', 206, 191,
    ' ', 207, 132, 207, 140, 207, 128, 206, 191, 207, 130, ' ',
    206, 179, 206, 173, 206, 189, 206, 189, 206, 183, 207, 131,
    206, 183, 207, 130, ' ', 207, 132, 207, 137, 206, 189, ' ',
    206, 159, 206, 187, 207, 133, 206, 188, 207, 128, 206, 185,
    206, 177, 206, 186, 207, 142, 206, 189, ' ', 206, 145, 206,
    179, 207, 142, 206, 189, 207, 137, 206, 189, ',', 207, 132,
    206, 191, 207, 133, ' ', 206, 180, 207, 129, 206, 172, 206,
    188, 206, 177, 207, 132, 206, 191, 207, 130, ',', ' ', 207,
    132, 206, 183, 207, 130, ' ', 207, 132, 207, 129, 206, 177,
    206, 179, 207, 137, 206, 180, 206, 175, 206, 177, 207, 130,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 207, 132, 206, 183,
    207, 130, ' ', 206, 186, 207, 137, 206, 188, 206, 188, 207,
    137, 206, 180, 206, 175, 206, 177, 207, 130, ' ', '.',  13,
     10,  13,  10, 206, 151, ' ', 206, 149, 206, 187, 206, 187,
    206, 172, 206, 180, 206, 177, ' ', 206, 181, 206, 175, 206,
    189, 206, 177, 206, 185, ' ', 206, 188, 206, 173, 206, 187,
    206, 191, 207, 130, ' ', 207, 132, 207, 137, 206, 189, ' ',
    206, 149, 207, 133, 207, 129, 207, 137, 207, 128, 206, 177,
    207, 138, 206, 186, 207, 142, 206, 189, ' ', 206, 154, 206,
    191, 206, 185, 206, 189, 206, 191, 207, 132, 206, 174, 207,
    132, 207, 137, 206, 189, '/', 206, 149, 207, 133, 207, 129,
    207, 137, 207, 128, 206, 177, 207, 138, 206, 186, 206, 174,
    207, 130, ' ', 206, 136, 206, 189, 207, 137, 207, 131, 206,
    183, 207, 130, ' ', 206, 177, 207, 128, 207, 140, ' ', 207,
    132, 206, 191, ' ', '1', '9', '8', '1', ',', ' ', 207, 132,
    206, 183, 207, 130, ' ', 206, 149, 207, 133, 207, 129, 207,
    137, 206, 182, 207, 142, 206, 189, 206, 183, 207, 130, ' ',
    206, 177, 207, 128, 207, 140, ' ', 207, 132, 206, 191, ' ',
    '2', '0', '0', '1', ',', ' ', 207, 132, 206, 191, 207, 133,
    ' ', 206, 157, 206, 145, 206, 164, 206, 159, ' ', 206, 177,
    207, 128, 207, 140, ' ', 207, 132, 206, 191, ' ', '1', '9',
    '5', '2', ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 185,
    206, 180, 207, 129, 207, 133, 207, 132, 206, 185, 206, 186,
    207, 140, ' ', 206, 188, 206, 173, 206, 187, 206, 191, 207,
    130, ' ', 207, 132, 206, 191, 207, 133, ' ', 206, 159, 206,
    151, 206, 149, ' ', '(', '1', '9', '4', '5', ')', '.', ' ',
    206, 151, ' ', 206, 149, 206, 187, 206, 187, 206, 172, 206,
    180, 206, 177, ' ', 206, 181, 206, 175, 206, 189, 206, 177,
    206, 185, ' ', 206, 188, 206, 185, 206, 177, ' ', 206, 177,
    206, 189, 206, 181, 207, 128, 207, 132, 207, 133, 206, 179,
    206, 188, 206, 173, 206, 189, 206, 183, ' ', 207, 135, 207,
    142, 207, 129, 206, 177, ' ', 206, 188, 206, 181, ' ', 207,
    133, 207, 136, 206, 183, 206, 187, 207, 140, ' ', 206, 186,
    206, 177, 207, 132, 206, 172, ' ', 206, 186, 206, 181, 207,
    134, 206, 177, 206, 187, 206, 174, 206, 189, ' ', 206, 181,
    206, 185, 207, 131, 207, 140, 206, 180, 206, 183, 206, 188,
    206, 177, ' ', 206, 186, 206, 177, 206, 185, ' ', 207, 128,
    206, 191, 206, 187, 207, 141, ' ', 207, 133, 207, 136, 206,
    183, 206, 187, 207, 140, ' ', 206, 180, 206, 181, 206, 175,
    206, 186, 207, 132, 206, 183, ' ', 206, 177, 206, 189, 206,
    184, 207, 129, 207, 142, 207, 128, 206, 185, 206, 189, 206,
    183, 207, 130, ' ', 206, 177, 206, 189, 206, 172, 207, 128,
    207, 132, 207, 133, 206, 190, 206, 183, 207, 130, '.', ' ',
    206, 154, 206, 177, 207, 132, 206, 173, 207, 135, 206, 181,
    206, 185, ' ', 207, 132, 206, 183, 206, 189, ' ', '2', '2',
    206, 183, ' ', 206, 186, 206, 177, 206, 187, 207, 141, 207,
    132, 206, 181, 207, 129, 206, 183, ' ', 207, 128, 206, 191,
    206, 185, 207, 140, 207, 132, 206, 183, 207, 132, 206, 177,
    ' ', 206, 182, 207, 137, 206, 174, 207, 130, ' ', 207, 131,
    207, 132, 206, 191, 206, 189, ' ', 206, 186, 207, 140, 207,
    131, 206, 188, 206, 191, '.', '[', '4', ']',  13,  10,  13,
     10, 206, 151, ' ', 206, 149, 206, 187, 206, 187, 206, 172,
    206, 180, 206, 177, ' ', '(', 207, 128, 206, 177, 206, 187,
    206, 177, 206, 185, 207, 140, 207, 132, 206, 181, 207, 129,
    206, 177, ':', ' ', 225, 188, 153, 206, 187, 206, 187, 206,
    172, 207, 130, ',', ' ', 206, 181, 207, 128, 206, 175, 207,
    131, 206, 183, 206, 188, 206, 177, ':', ' ', 206, 149, 206,
    187, 206, 187, 206, 183, 206, 189, 206, 185, 206, 186, 206,
    174, ' ', 206, 148, 206, 183, 206, 188, 206, 191, 206, 186,
    207, 129, 206, 177, 207, 132, 206, 175, 206, 177, ')', ' ',
    206, 181, 206, 175, 206, 189, 206, 177, 206, 185, ' ', 207,
    135, 207, 142, 207, 129, 206, 177, ' ', 207, 128, 206, 191,
    207, 133, ' ', 206, 178, 207, 129, 206, 175, 207, 131, 206,
    186, 206, 181, 207, 132, 206, 177, 206, 185, ' ', 207, 131,
    207, 132, 206, 183, ' ', 206, 189, 206, 191, 207, 132, 206,
    185, 206, 191, 206, 177, 206, 189, 206, 177, 207, 132, 206,
    191, 206, 187, 206, 185, 206, 186, 206, 174, ' ', 206, 149,
    207, 133, 207, 129, 207, 142, 207, 128, 206, 183, ',', ' ',
    207, 131, 207, 132, 206, 191, ' ', 206, 189, 206, 191, 207,
    132, 206, 185, 207, 140, 207, 132, 206, 181, 207, 129, 206,
    191, ' ', 206, 172, 206, 186, 207, 129, 206, 191, ' ', 207,
    132, 206, 183, 207, 130, ' ', 206, 146, 206, 177, 206, 187,
    206, 186, 206, 177, 206, 189, 206, 185, 206, 186, 206, 174,
    207, 130, ' ', 207, 135, 206, 181, 207, 129, 207, 131, 206,
    191, 206, 189, 206, 174, 207, 131, 206, 191, 207, 133, ',',
    ' ', 207, 131, 207, 132, 206, 183, 206, 189, ' ', 206, 145,
    206, 189, 206, 177, 207, 132, 206, 191, 206, 187, 206, 185,
    206, 186, 206, 174, ' ', 206, 156, 206, 181, 207, 131, 207,
    140, 206, 179, 206, 181, 206, 185, 206, 191, '.', 206, 160,
    207, 129, 207, 137, 207, 132, 206, 181, 207, 141, 206, 191,
    207, 133, 207, 131, 206, 177, ' ', 207, 132, 206, 183, 207,
    130, ' ', 206, 149, 206, 187, 206, 187, 206, 172, 206, 180,
    206, 191, 207, 130, ' ', 206, 186, 206, 177, 206, 185, ' ',
    206, 188, 206, 181, 206, 179, 206, 177, 206, 187, 207, 141,
    207, 132, 206, 181, 207, 129, 206, 183, ' ', 207, 128, 207,
    140, 206, 187, 206, 183, ' ', 206, 181, 206, 175, 206, 189,
    206, 177, 206, 185, ' ', 206, 183, ' ', 206, 145, 206, 184,
    206, 174, 206, 189, 206, 177, '.',  13,  10,  13,  10, 206,
    163, 207, 133, 206, 189, 206, 191, 207, 129, 206, 181, 207,
    141, 206, 181, 206, 185, ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 178, 206, 191, 207, 129, 206, 181, 206, 185, 206,
    191, 206, 180, 207, 133, 207, 132, 206, 185, 206, 186, 206,
    172, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, 206,
    189, ' ', 206, 145, 206, 187, 206, 178, 206, 177, 206, 189,
    206, 175, 206, 177, ',', ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 178, 207, 140, 207, 129, 206, 181, 206, 185, 206,
    177, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, ' ',
    206, 146, 206, 191, 207, 133, 206, 187, 206, 179, 206, 177,
    207, 129, 206, 175, 206, 177, ' ', 206, 186, 206, 177, 206,
    185, ' ', 207, 132, 206, 183, 206, 189, ' ', 207, 128, 207,
    129, 207, 142, 206, 183, 206, 189, ' ', 206, 147, 206, 185,
    206, 191, 207, 133, 206, 179, 206, 186, 206, 191, 207, 131,
    206, 187, 206, 177, 206, 178, 206, 185, 206, 186, 206, 174,
    ' ', 206, 148, 206, 183, 206, 188, 206, 191, 206, 186, 207,
    129, 206, 177, 207, 132, 206, 175, 206, 177, ' ', 207, 132,
    206, 183, 207, 130, ' ', 206, 156, 206, 177, 206, 186, 206,
    181, 206, 180, 206, 191, 206, 189, 206, 175, 206, 177, 207,
    130, ' ', '(', 207, 128, '.', 206, 147, '.', 206, 148, '.',
    206, 156, '.', ')', ' ', 206, 186, 206, 177, 206, 185, ' ',
    207, 131, 207, 132, 206, 177, ' ', 206, 178, 206, 191, 207,
    129, 206, 181, 206, 185, 206, 191, 206, 177, 206, 189, 206,
    177, 207, 132, 206, 191, 206, 187, 206, 185, 206, 186, 206,
    172, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183, 206,
    189, ' ', 206, 164, 206, 191, 207, 133, 207, 129, 206, 186,
    206, 175, 206, 177, '.', ' ', 206, 146, 207, 129, 206, 173,
    207, 135, 206, 181, 207, 132, 206, 177, 206, 185, ' ', 207,
    131, 207, 132, 206, 177, ' ', 206, 177, 206, 189, 206, 177,
    207, 132, 206, 191, 206, 187, 206, 185, 206, 186, 206, 172,
    ' ', 206, 177, 207, 128, 207, 140, ' ', 207, 132, 206, 191,
    ' ', 206, 145, 206, 185, 206, 179, 206, 177, 206, 175, 206,
    191, ' ', 206, 160, 206, 173, 206, 187, 206, 177, 206, 179,
    206, 191, 207, 130, ',', ' ', 207, 131, 207, 132, 206, 177,
    ' ', 206, 180, 207, 133, 207, 132, 206, 185, 206, 186, 206,
    172, ' ', 206, 177, 207, 128, 207, 140, ' ', 207, 132, 206,
    191, ' ', 206, 153, 207, 140, 206, 189, 206, 185, 206, 191,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 189, 207, 140,
    207, 132, 206, 185, 206, 177, ' ', 206, 177, 207, 128, 207,
    140, ' ', 207, 132, 206, 183, ' ', 206, 156, 206, 181, 207,
    131, 207, 140, 206, 179, 206, 181, 206, 185, 206, 191, ' ',
    206, 152, 206, 172, 206, 187, 206, 177, 207, 131, 207, 131,
    206, 177, '.', 206, 151, ' ', 206, 149, 206, 187, 206, 187,
    206, 172, 206, 180, 206, 177, ' ', 206, 186, 206, 177, 207,
    132, 206, 173, 207, 135, 206, 181, 206, 185, ' ', 207, 132,
    206, 183, 206, 189, ' ', '1', '1', 206, 183, ' ', 206, 184,
    206, 173, 207, 131, 206, 183, ' ', 207, 131, 207, 132, 206,
    185, 207, 130, ' ', 207, 135, 207, 142, 207, 129, 206, 181,
    207, 130, ' ', 206, 188, 206, 181, ' ', 207, 132, 206, 183,
    ' ', 206, 188, 206, 181, 206, 179, 206, 177, 206, 187, 207,
    141, 207, 132, 206, 181, 207, 129, 206, 183, ' ', 206, 177,
    206, 186, 207, 132, 206, 191, 206, 179, 207, 129, 206, 177,
    206, 188, 206, 188, 206, 174, ' ', 207, 131, 207, 132, 206,
    177, ' ', '1', '3', '.', '6', '7', '6', ' ', 207, 135, 206,
    185, 206, 187, 206, 185, 207, 140, 206, 188, 206, 181, 207,
    132, 207, 129, 206, 177, ' ', 206, 186, 206, 177, 206, 184,
    207, 142, 207, 130, ' ', 206, 181, 207, 135, 206, 181, 206,
    185, ' ', 207, 128, 206, 191, 206, 187, 206, 187, 206, 172,
    ' ', 206, 189, 206, 183, 207, 131, 206, 185, 206, 172, ' ',
    '(', 207, 128, 206, 181, 207, 129, 206, 175, 207, 128, 206,
    191, 207, 133, ' ', '1', '.', '4', '0', '0', ',', ' ', 206,
    181, 206, 186, 207, 132, 207, 137, 206, 189, ' ', 206, 191,
    207, 128, 206, 191, 206, 175, 207, 137, 206, 189, ' ', 207,
    132, 206, 177, ' ', '2', '2', '7', ' ', 206, 186, 206, 177,
    207, 132, 206, 191, 206, 185, 206, 186, 206, 191, 207, 133,
    206, 189, 207, 132, 206, 177, 206, 185, ')', ',', ' ', 207,
    131, 207, 133, 206, 188, 207, 128, 206, 181, 207, 129, 206,
    185, 206, 187, 206, 177, 206, 188, 206, 178, 206, 177, 206,
    189, 206, 191, 206, 188, 206, 173, 206, 189, 207, 137, 206,
    189, ' ', 207, 132, 206, 183, 207, 130, ' ', 206, 154, 207,
    129, 206, 183, 207, 132, 206, 183, 207, 130, ',', ' ', 207,
    132, 207, 137, 206, 189, ' ', 206, 148, 207, 137, 206, 180,
    206, 181, 206, 186, 206, 177, 206, 189, 206, 174, 207, 131,
    207, 137, 206, 189, ',', ' ', 207, 132, 207, 137, 206, 189,
    ' ', 206, 154, 207, 133, 206, 186, 206, 187, 206, 172, 206,
    180, 207, 137, 206, 189, ',', ' ', 207, 132, 207, 137, 206,
    189, ' ', 206, 149, 207, 128, 207, 132, 206, 177, 206, 189,
    206, 174, 207, 131, 207, 137, 206, 189, ' ', 206, 186, 206,
    177, 206, 185, ' ', 207, 128, 206, 191, 206, 187, 206, 187,
    207, 142, 206, 189, ' ', 206, 172, 206, 187, 206, 187, 207,
    137, 206, 189, '.', 206, 164, 206, 191, ' ', 207, 136, 206,
    183, 206, 187, 207, 140, 207, 132, 206, 181, 207, 129, 206,
    191, ' ', 206, 178, 206, 191, 207, 133, 206, 189, 207, 140,
    ' ', 206, 181, 206, 175, 206, 189, 206, 177, 206, 185, ' ',
    206, 191, ' ', 206, 140, 206, 187, 207, 133, 206, 188, 207,
    128, 206, 191, 207, 130, ' ', 206, 186, 206, 177, 206, 185,
    ' ', 207, 132, 206, 191, ' ', 206, 188, 206, 181, 206, 179,
    206, 177, 206, 187, 207, 141, 207, 132, 206, 181, 207, 129,
    206, 191, ' ', 207, 128, 206, 191, 207, 132, 206, 172, 206,
    188, 206, 185, ' ', 206, 191, ' ', 206, 145, 206, 187, 206,
    185, 206, 172, 206, 186, 206, 188, 206, 191, 206, 189, 206,
    177, 207, 130, '.',  13,  10,  13,  10, 206, 136, 207, 135,
    206, 181, 206, 185, ' ', 206, 188, 206, 177, 206, 186, 207,
    129, 206, 172, ' ', 206, 186, 206, 177, 206, 185, ' ', 207,
    128, 206, 187, 206, 191, 207, 141, 207, 131, 206, 185, 206,
    177, ' ', 206, 185, 207, 131, 207, 132, 206, 191, 207, 129,
    206, 175, 206, 177, ' ', 206, 186, 206, 177, 207, 132, 206,
    172, ' ', 207, 132, 206, 183, 206, 189, ' ', 206, 191, 207,
    128, 206, 191, 206, 175, 206, 177, ' ', 206, 172, 207, 131,
    206, 186, 206, 183, 207, 131, 206, 181, ' ', 206, 188, 206,
    181, 206, 179, 206, 172, 206, 187, 206, 183, ' ', 207, 128,
    206, 191, 206, 187, 206, 185, 207, 132, 206, 185, 207, 131,
    206, 188, 206, 185, 206, 186, 206, 174, ' ', 206, 181, 207,
    128, 206, 175, 206, 180, 207, 129, 206, 177, 207, 131, 206,
    183, ' ', 207, 131, 206, 181, ' ', 207, 132, 207, 129, 206,
    181, 206, 185, 207, 130, ' ', 206, 183, 207, 128, 206, 181,
    206, 175, 207, 129, 206, 191, 207, 133, 207, 130, '.', 206,
    149, 206, 180, 207, 142, ' ', 206, 179, 206, 181, 206, 189,
    206, 189, 206, 174, 206, 184, 206, 183, 206, 186, 206, 181,
    ' ', 206, 183, ' ', 206, 180, 206, 183, 206, 188, 206, 191,
    206, 186, 207, 129, 206, 177, 207, 132, 206, 175, 206, 177,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 183, ' ', 207,
    134, 206, 185, 206, 187, 206, 191, 207, 131, 206, 191, 207,
    134, 206, 175, 206, 177, '.', 206, 145, 206, 186, 207, 140,
    206, 188, 206, 188, 206, 177, ' ', 206, 183, ' ', 206, 149,
    206, 187, 206, 187, 206, 172, 206, 180, 206, 177, ' ', 206,
    181, 206, 175, 206, 189, 206, 177, 206, 185, ' ', 206, 191,
    ' ', 207, 132, 207, 140, 207, 128, 206, 191, 207, 130, ' ',
    206, 179, 206, 173, 206, 189, 206, 189, 206, 183, 207, 131,
    206, 183, 207, 130, ' ', 207, 132, 207, 137, 206, 189, ' ',
    206, 159, 206, 187, 207, 133, 206, 188, 207, 128, 206, 185,
    206, 177, 206, 186, 207, 142, 206, 189, ' ', 206, 145, 206,
    179, 207, 142, 206, 189, 207, 137, 206, 189, ',', 207, 132,
    206, 191, 207, 133, ' ', 206, 180, 207, 129, 206, 172, 206,
    188, 206, 177, 207, 132, 206, 191, 207, 130, ',', ' ', 207,
    132, 206, 183, 207, 130, ' ', 207, 132, 207, 129, 206, 177,
    206, 179, 207, 137, 206, 180, 206, 175, 206, 177, 207, 130,
    ' ', 206, 186, 206, 177, 206, 185, ' ', 207, 132, 206, 183,
    207, 130, ' ', 206, 186, 207, 137, 206, 188, 206, 188, 207,
    137, 206, 180, 206, 175, 206, 177, 207, 130, ' ', '.',  13,
     10,  13,  10, 206, 151, ' ', 206, 149, 206, 187, 206, 187,
    206, 172, 206, 180, 206, 177, ' ', 206, 181, 206, 175, 206,
    189, 206, 177, 206, 185, ' ', 206, 188, 206, 173, 206, 187,
    206, 191, 207, 130, ' ', 207, 132, 207, 137, 206, 189, ' ',
    206, 149, 207, 133, 207, 129, 207, 137, 207, 128, 206, 177,
    207, 138, 206, 186, 207, 142, 206, 189, ' ', 206, 154, 206,
    191, 206, 185, 206, 189, 206, 191, 207, 132, 206, 174, 207,
    132, 207, 137, 206, 189, '/', 206, 149, 207, 133, 207, 129,
    207, 137, 207, 128, 206, 177, 207, 138, 206, 186, 206, 174,
    207, 130, ' ', 206, 136, 206, 189, 207, 137, 207, 131, 206,
    183, 207, 130, ' ', 206, 177, 207, 128, 207, 140, ' ', 207,
    132, 206, 191, ' ', '1', '9', '8', '1', ',', ' ', 207, 132,
    206, 183, 207, 130, ' ', 206, 149, 207, 133, 207, 129, 207,
    137, 206, 182, 207, 142, 206, 189, 206, 183, 207, 130, ' ',
    206, 177, 207, 128, 207, 140, ' ', 207, 132, 206, 191, ' ',
    '2', '0', '0', '1', ',', ' ', 207, 132, 206, 191, 207, 133,
    ' ', 206, 157, 206, 145, 206, 164, 206, 159, ' ', 206, 177,
    207, 128, 207, 140, ' ', 207, 132, 206, 191, ' ', '1', '9',
    '5', '2', ' ', 206, 186, 206, 177, 206, 185, ' ', 206, 185,
    206, 180, 207, 129, 207, 133, 207, 132, 206, 185, 206, 186,
    207, 140, ' ', 206, 188, 206, 173, 206, 187, 206, 191, 207,
    130, ' ', 207, 132, 206, 191, 207, 133, ' ', 206, 159, 206,
    151, 206, 149, ' ', '(', '1', '9', '4', '5', ')', '.', ' ',
    206, 151, ' ', 206, 149, 206, 187, 206, 187, 206, 172, 206,
    180, 206, 177, ' ', 206, 181, 206, 175, 206, 189, 206, 177,
    206, 185, ' ', 206, 188, 206, 185, 206, 177, ' ', 206, 177,
    206, 189, 206, 181, 207, 128, 207, 132, 207, 133, 206, 179,
    206, 188, 206, 173, 206, 189, 206, 183, ' ', 207, 135, 207,
    142, 207, 129, 206, 177, ' ', 206, 188, 206, 181, ' ', 207,
    133, 207, 136, 206, 183, 206, 187, 207, 140, ' ', 206, 186,
    206, 177, 207, 132, 206, 172, ' ', 206, 186, 206, 181, 207,
    134, 206, 177, 206, 187, 206, 174, 206, 189, ' ', 206, 181,
    206, 185, 207, 131, 207, 140, 206, 180, 206, 183, 206, 188,
    206, 177, ' ', 206, 186, 206, 177, 206, 185, ' ', 207, 128,
    206, 191, 206, 187, 207, 141, ' ', 207, 133, 207, 136, 206,
    183, 206, 187, 207, 140, ' ', 206, 180, 206, 181, 206, 175,
    206, 186, 207, 132, 206, 183, ' ', 206, 177, 206, 189, 206,
    184, 207, 129, 207, 142, 207, 128, 206, 185, 206, 189, 206,
    183, 207, 130, ' ', 206, 177, 206, 189, 206, 172, 207, 128,
    207, 132, 207, 133, 206, 190, 206, 183, 207, 130, '.', ' ',
    206, 154, 206, 177, 207, 132, 206, 173, 207, 135, 206, 181,
    206, 185, ' ', 207, 132, 206, 183, 206, 189, ' ', '2', '2',
    206, 183, ' ', 206, 186, 206, 177, 206, 187, 207, 141, 207,
    132, 206, 181, 207, 129, 206, 183, ' ', 207, 128, 206, 191,
    206, 185, 207, 140, 207, 132, 206, 183, 207, 132, 206, 177,
    ' ', 206, 182, 207, 137, 206, 174, 207, 130, ' ', 207, 131,
    207, 132, 206, 191, 206, 189, ' ', 206, 186, 207, 140, 207,
    131, 206, 188, 206, 191, '.', '[', '4', ']',  13,  10,  13,
     10, 'R', 'a', 'n', 'd', 'o', 'm', ' ', 'Q', 'u', 'a', 'd',
    ' ', 'V', 'a', 'l', 'u', 'e', 's',  13,  10, 240, 144, 128,
    128, 240, 152, 166, 171, 240, 158, 187, 174, 240, 154, 170,
    170, 240, 154, 132, 163, 240, 155, 132, 163, 243, 187, 174,
    187, 244, 128, 128, 128, 243, 174, 187, 174, 242, 187, 174,
    187,  13,  10,   0
};
const char * const charUtf8MultiLang = (const char *) utf8MultiLang;

//-----------------------------------------------------------------------------
// Encode a 4-byte UTF-8 value, print as a sequence of deimal ints.
//-----------------------------------------------------------------------------

char *decodeFourByteUtf8String(char *outBuf, unsigned val)
{
    ASSERT(0 == (val & ~((1 << 21) - 1)));
    ASSERT(0 != (val & ~((1 << 16) - 1)));

    outBuf[0] = (char) (((val &  (7 << 18)) >> 18) | 0xf0);
    outBuf[1] = (char) (((val & (63 << 12)) >> 12) | 0x80);
    outBuf[2] = (char) (((val & (63 <<  6)) >>  6) | 0x80);
    outBuf[3] = (char) (((val &  63       )      ) | 0x80);

    return outBuf + 4;
}

char *decodeThreeByteUtf8String(char *outBuf, unsigned val)
{
    ASSERT(0 == (val & ~((1 << 16) - 1)));
    ASSERT(0 != (val & ~((1 << 11) - 1)));

    outBuf[0] = (char) (((val & (15 << 12)) >> 12) | 0xe0);
    outBuf[1] = (char) (((val & (63 <<  6)) >>  6) | 0x80);
    outBuf[2] = (char) (((val &  63       )      ) | 0x80);

    return outBuf + 3;
}

char *decodeTwoByteUtf8String(char *outBuf, unsigned val)
{
    ASSERT(0 == (val & ~((1 << 11) - 1)));
    ASSERT(0 != (val & ~((1 <<  7) - 1)));

    outBuf[0] = (char) (((val & (31 <<  6)) >>  6) | 0xc0);
    outBuf[1] = (char) (((val &  63       )      ) | 0x80);

    return outBuf + 2;
}

char *decodeOneByteUtf8String(char *outBuf, unsigned val)
{
    ASSERT(0 == (val & ~((1 << 7) - 1)));
    ASSERT(0 !=  val);

    *outBuf = (char) val;

    return outBuf + 1;
}

char *decodeUtf32(char *outBuf, unsigned val)
{
    if      (val < 0x80) {
        return decodeOneByteUtf8String(  outBuf, val);                // RETURN
    }
    else if (val < (1 << 11)) {
        return decodeTwoByteUtf8String(  outBuf, val);                // RETURN
    }
    else if (val < (1 << 16)) {
        return decodeThreeByteUtf8String(outBuf, val);                // RETURN
    }
    else if (val <= 0x10ffff) {
        return decodeFourByteUtf8String( outBuf, val);                // RETURN
    }
    else {
        LOOP_ASSERT(val, 0 && "value above 0x10ffff");
        return outBuf;                                                // RETURN
    }
}

                                // -------
                                // Case -1
                                // -------

namespace CASE_MINUS_1_NAMESPACE {

bsl::ostream& fourByteUtf8String(bsl::ostream& stream, unsigned val)
{
    unsigned bs[4];
    const char *hx = "\\x";

    ASSERT(0 == (val & ~((1 << 21) - 1)));
    ASSERT(0 != (val & ~((1 << 16) - 1)));

    bs[0] = ((val &  (7 << 18)) >> 18) | 0xf0;
    bs[1] = ((val & (63 << 12)) >> 12) | 0x80;
    bs[2] = ((val & (63 <<  6)) >>  6) | 0x80;
    bs[3] = ((val &  63       )      ) | 0x80;

    stream << bsl::hex << '"' << hx << bs[0] <<
                  hx << bs[1] << hx << bs[2] << hx << bs[3] << '"' << bsl::dec;

    return stream;
}

bsl::ostream& threeByteUtf8String(bsl::ostream& stream, unsigned val)
{
    unsigned bs[3];
    const char *hx = "\\x";

    ASSERT(0 == (val & ~((1 << 16) - 1)));
    ASSERT(0 != (val & ~((1 << 11) - 1)));

    bs[0] = ((val & (15 << 12)) >> 12) | 0xe0;
    bs[1] = ((val & (63 <<  6)) >>  6) | 0x80;
    bs[2] = ((val &  63       )      ) | 0x80;

    stream << bsl::hex << '"' << hx << bs[0] <<
                                 hx << bs[1] << hx << bs[2] << '"' << bsl::dec;

    return stream;
}

bsl::ostream& twoByteUtf8String(bsl::ostream& stream, unsigned val)
{
    unsigned bs[2];
    const char *hx = "\\x";

    ASSERT(0 == (val & ~((1 << 11) - 1)));
    ASSERT(0 != (val & ~((1 <<  7) - 1)));

    bs[0] = ((val & (31 <<  6)) >>  6) | 0xc0;
    bs[1] = ((val &  63       )      ) | 0x80;

    stream << bsl::hex << '"' << hx << bs[0] << hx << bs[1] <<'"' << bsl::dec;

    return stream;
}

bsl::ostream& oneByteUtf8String(bsl::ostream& stream, unsigned val)
{
    const char *hx = "\\x";

    ASSERT(0 == (val & ~((1 << 7) - 1)));
    ASSERT(0 !=  val);

    stream << '"';
    switch (val) {
      case '\n': {
        stream << "\\n";
      } break;
      case '\t': {
        stream << "\\t";
      } break;
      case '\\': {
        stream << "\\\\";
      } break;
      default: {
        if (bsl::isprint(val)) {
            stream << (char) val;
        }
        else {
            stream << bsl::hex << hx << val << bsl::dec;
        }
      }
    }
    stream << '"';

    return stream;
}

bsl::ostream& outputSequence(bsl::ostream& stream, unsigned val)
{
    if      (val < 0x80) {
        return oneByteUtf8String(  stream, val);                      // RETURN
    }
    else if (val < (1 << 11)) {
        return twoByteUtf8String(  stream, val);                      // RETURN
    }
    else if (val < (1 << 16)) {
        return threeByteUtf8String(stream, val);                      // RETURN
    }
    else if (val <= 0x10ffff) {
        return fourByteUtf8String( stream, val);                      // RETURN
    }
    else {
        LOOP_ASSERT(val, 0 && "value above 0x10ffff");
        return stream;                                                // RETURN
    }
}

}  // close namespace CASE_MINuS_1_NAMESPACE

bsl::string dumpUtf8Vec(const bsl::vector<char>& utf8Vec)
{
    bsl::ostringstream oss;

    oss << bsl::hex;
    oss << "utf8(";
    for (unsigned u = 0; u < utf8Vec.size(); ++u) {
        oss << (u > 0 ? ", " : "") << "0x" <<
                                         (unsigned) (unsigned char) utf8Vec[u];
    }
    oss << ')';

    return oss.str();
}

bsl::string dumpUtf32Vec(const bsl::vector<unsigned int>& utf32Vec)
{
    bsl::ostringstream oss;

    oss << bsl::hex;
    oss << "utf32(";
    for (unsigned u = 0; u < utf32Vec.size(); ++u) {
        oss << (u > 0 ? ", " : "") << "0x" << utf32Vec[u];
    }
    oss << ')';

    return oss.str();
}

int myRandSeed = 1234567890;
static inline
unsigned int myRand32()
{
    return ((unsigned int) bdeu_Random::generate15(&myRandSeed) << 20) ^
           ((unsigned int) bdeu_Random::generate15(&myRandSeed) <<  8) ^
           ((unsigned int) bdeu_Random::generate15(&myRandSeed) >>  4);
}

static inline
unsigned int myRand15()
{
    return (unsigned int) bdeu_Random::generate15(&myRandSeed);
}


static
unsigned int myRandUtf32Char()
{
    unsigned int typ = myRand15() & 15;

    if (typ < 2) {
        // ascii

        unsigned int ret;
        do {
            ret = myRand15() & ((1 << 11) - 1);
        } while (! ret);

        return ret;                                                   // RETURN
    }
    else if (typ < 2 + 3) {
        // 2 octet

        unsigned int ret;
        do {
            ret = myRand15() & ((1 << 11) - 1);
        } while (ret < 0x80);

        return ret;                                                   // RETURN
    }
    else if (typ < 2 + 3 + 5) {
        // 3 octet -- legal or illegal

        unsigned int ret;
        do {
            ret = myRand32() & 0xffff;
        } while (ret < (1 << 11));

        return ret;                                                   // RETURN
    }
    else if (typ < 15) {
        // legal 4 octet

        unsigned int ret;
        ret = (myRand32() & 0xfffff) + 0x10000;
        ASSERT(ret <= 0x10ffff);
        ASSERT(ret >=  0x10000);

        return ret;                                                   // RETURN
    }
    else {
        // illegal 4 octet

        unsigned int ret;
        do {
            ret = myRand32();
        } while (ret <= 0x10ffff);

        return ret;                                                   // RETURN
    }
}

template <typename TYPE>
struct NotEqual {
    // For passing to 'bsl::find_if'.

    // DATA
    TYPE d_word;

    // CREATOR
    explicit
    NotEqual(TYPE c) : d_word(c) {}

    // ACCESSOR
    bool operator()(TYPE c) const { return d_word != c; }
};

static const struct Utf32TableStruct {
    int           d_line;
    unsigned int  d_utf32Val;
    const char   *d_utf8String;
    const bool    d_error;
} utf32Table[] = {
    { L_, 1,             "\x01",              0 },  // 1 char min
    { L_, 0x80,          "\xc2\x80",          0 },  // 2 char min
    { L_, 1<<11,         "\xe0\xa0\x80",      0 },  // 3 char min
    { L_, 1<<16,         "\xf0\x90\x80\x80",  0 },  // 4 char min

    { L_, 'H',           "\x48",              0 },  // 1 char med
    { L_, 0x2f1,         "\xcb\xb1",          0 },  // 2 char med
    { L_, 0x2710,        "\xe2\x9c\x90",      0 },  // 3 char med
    { L_, 0xd7ff,        "\xed\x9f\xbf",      0 },  // 3 below UTF-16 bit plane
    { L_, 0xe000,        "\xee\x80\x80",      0 },  // 3 above UTF-16 bit plane
    { L_, 0x186a0,       "\xf0\x98\x9a\xa0",  0 },  // 4 char med

    { L_, 0x7f,          "\x7f",              0 },  // 1 char max
    { L_, (1<<11)-1,     "\xdf\xbf",          0 },  // 2 char max
    { L_, (1<<16)-1,     "\xef\xbf\xbf",      0 },  // 3 char max
    { L_, 0x10ffff,      "\xf4\x8f\xbf\xbf",  0 },  // 4 char max

    { L_, 0xd800,        "?",                 1 },  // utf-16 lower bit plane
    { L_, 0xd8ff,        "?",                 1 },  // utf-16 lower bit plane
    { L_, 0xd917,        "?",                 1 },  // utf-16 lower bit plane
    { L_, 0xdaaf,        "?",                 1 },  // utf-16 lower bit plane
    { L_, 0xdb09,        "?",                 1 },  // utf-16 lower bit plane

    { L_, 0xdc00,        "?",                 1 },  // utf-16 upper bit plane
    { L_, 0xdcff,        "?",                 1 },  // utf-16 upper bit plane
    { L_, 0xdd80,        "?",                 1 },  // utf-16 upper bit plane
    { L_, 0xdea7,        "?",                 1 },  // utf-16 upper bit plane
    { L_, 0xdf03,        "?",                 1 },  // utf-16 upper bit plane
    { L_, 0xdfff,        "?",                 1 },  // utf-16 upper bit plane

    { L_, 0x110000,      "?",                 1 },  // above unicode
    { L_, 0x120000,      "?",                 1 },  // above unicode
    { L_, 1<<21,         "?",                 1 },  // above unicode
    { L_, 1<<29,         "?",                 1 },  // above unicode
    { L_, 1<<31,         "?",                 1 },  // above unicode
    { L_, (0xffff<<16),  "?",                 1 },  // above unicode
};
enum { NUM_UTF32_TABLE = sizeof utf32Table / sizeof *utf32Table };

static const struct Utf8TableStruct {
    int           d_line;
    const char   *d_utf8String;
    unsigned int  d_midVal;
    const bool    d_error;
    const int     d_truncBy;
} utf8Table[] = {
    { L_, "1\x01z",              1,         0, 0 },  // 1 char min
    { L_, "1\xc2\x80z",          0x80,      0, 0 },  // 2 char min
    { L_, "1\xe0\xa0\x80z",      1<<11,     0, 0 },  // 3 char min
    { L_, "1\xf0\x90\x80\x80z",  1<<16,     0, 0 },  // 4 char min

    { L_, "1\x48z",              'H',       0, 0 },  // 1 char med
    { L_, "1\xcb\xb1z",          0x2f1,     0, 0 },  // 2 char med
    { L_, "1\xe2\x9c\x90z",      0x2710,    0, 0 },  // 3 char med
    { L_, "1\xed\x9f\xbfz",      0xd7ff,    0, 0 },  // 3 below UTF16 bit plane
    { L_, "1\xee\x80\x80z",      0xe000,    0, 0 },  // 3 above UTF16 bit plane
    { L_, "1\xf0\x98\x9a\xa0z",  0x186a0,   0, 0 },  // 4 char med

    { L_, "1\x7fz",              0x7f,      0, 0 },  // 1 char max
    { L_, "1\xdf\xbfz",          (1<<11)-1, 0, 0 },  // 2 char max
    { L_, "1\xef\xbf\xbfz",      (1<<16)-1, 0, 0 },  // 3 char max
    { L_, "1\xf4\x8f\xbf\xbfz",  0x10ffff,  0, 0 },  // 4 char max

    { L_, "1\xc0\x80z",          '?',       1, 0 },  // 2 char zero
    { L_, "1\xe0\x80\x80z",      '?',       1, 0 },  // 3 char zero
    { L_, "1\xf0\x80\x80\x80z",  '?',       1, 0 },  // 4 char zero
    { L_, "1\xf8\x80\x80\x80\x80z", '?',    1, 0 },  // 5 char zero

    { L_, "1\xc1\xbfz",          '?',       1, 0 },  // 2 char 1 too small
    { L_, "1\xe0\x9f\xbfz",      '?',       1, 0 },  // 3 char 1 too small
    { L_, "1\xf0\x8f\xbf\xbfz",  '?',       1, 0 },  // 4 char 1 too small

    { L_, "1\xf4\x90\x80\x80z",  '?',       1, 0 },  // 4 char 1 too much
    { L_, "1\xf7\xbf\xbf\xbfz",  '?',       1, 0 },  // 4 char WAY too much

    { L_, "1\xfb\xbf\xbf\xbf\xbfz", '?',    1, 0 },  // 5 char disaster

    { L_, "1\xed\xa0\x80z",      '?',       1, 0 },  // Illegal UTF16 bit plane
    { L_, "1\xed\xa3\xbfz",      '?',       1, 0 },  // Illegal UTF16 bit plane
    { L_, "1\xed\xb0\x80z",      '?',       1, 0 },  // Illegal UTF16 bit plane
    { L_, "1\xed\xb3\xbfz",      '?',       1, 0 },  // Illegal UTF16 bit plane
    { L_, "1\xed\xb6\x99z",      '?',       1, 0 },  // Illegal UTF16 bit plane

    { L_, "1\xc2z",              '?',       1, 1 },  // 2 char trunc - 1
    { L_, "1\xe0\xa0z",          '?',       1, 1 },  // 3 char trunc - 1
    { L_, "1\xe0z",              '?',       1, 2 },  // 3 char trunc - 2
    { L_, "1\xf0\x90\x80z",      '?',       1, 1 },  // 4 char trunc - 1
    { L_, "1\xf0\x90z",          '?',       1, 2 },  // 4 char trunc - 2
    { L_, "1\xf0z",              '?',       1, 3 },  // 4 char trunc - 3
    { L_, "1\xfb\xbf\xbf\xbfz",  '?',       1, 1 },  // 5 char dister trunc - 1
    { L_, "1\xfb\xbf\xbfz",      '?',       1, 2 },  // 5 char dister trunc - 2
    { L_, "1\xfb\xbfz",          '?',       1, 3 },  // 5 char dister trunc - 3
    { L_, "1\xfbz",              '?',       1, 4 },  // 5 char dister trunc - 4
};
enum { NUM_UTF8_TABLE = sizeof utf8Table / sizeof *utf8Table };

int main(int argc, char **argv)
{
    int test = argc > 1 ? atoi(argv[1]) : 0;
    verbose = argc > 2;
    veryVerbose = argc > 3;
    veryVeryVerbose = argc > 4;
    veryVeryVeryVerbose = argc > 5;
    veryVeryVeryVeryVerbose = argc > 6;

    cout << "TEST " << __FILE__ << " CASE " << test << endl;

    switch (test) { case 0:  // Zero is always the leading case.
      case 16: {
        // --------------------------------------------------------------------
        // USAGE EXAMPLE
        // --------------------------------------------------------------------

        if (verbose) cout << "USAGE EXAMPLE\n"
                             "=============\n";

        // The following snippets of code illustrate a typical use of the
        // 'bdede_CharConvertUtf32' struct's utility functions, first
        // converting from UTF-8 to UTF-32, and then converting back to make
        // sure the round trip returns the same value.

        // First, we declare a string of utf8 containing single-, double-,
        // triple-, and quadruple-octet characters.

        const char utf8MultiLang[] = {
            "Hello"                                         // -- Ascii
            "\xce\x97"         "\xce\x95"       "\xce\xbb"  // -- Greek
            "\xe4\xb8\xad"     "\xe5\x8d\x8e"               // -- Chinese
            "\xe0\xa4\xad"     "\xe0\xa4\xbe"               // -- Hindi
            "\xf2\x94\xb4\xa5" "\xf3\xb8\xac\x83" };        // -- Quad octets

        // Then, we declare an enum summarizing the counts of characters in the
        // string and verify that the counts add up to the length of the
        // string.

        enum { NUM_ASCII_CHARS   = 5,
               NUM_GREEK_CHARS   = 3,
               NUM_CHINESE_CHARS = 2,
               NUM_HINDI_CHARS   = 2,
               NUM_QUAD_CHARS    = 2 };

        ASSERT(1 * NUM_ASCII_CHARS +
               2 * NUM_GREEK_CHARS +
               3 * NUM_CHINESE_CHARS +
               3 * NUM_HINDI_CHARS +
               4 * NUM_QUAD_CHARS == bsl::strlen(utf8MultiLang));

        // Next, we declare the vector where our utf32 output will go, and a
        // variable into which the number of characters (characters, not bytes
        // or words) written will be stored.  It is not necessary to initialize
        // 'utf32CharsWritten'.

        bsl::vector<unsigned int> v32;

        // Note that for performance, we should
        // 'v32.reserve(sizeof(utf8MultiLang))', but it's not strictly
        // necessary -- it will automatically be grown to the correct size.
        // Note also that if 'v32' were not empty, that wouldn't be a problem
        // -- any contents will be discarded.

        // Then, we do the translation to 'UTF-32'.

        int retVal = bdede_CharConvertUtf32::utf8ToUtf32(&v32,
                                                         utf8MultiLang);

        ASSERT(0 == retVal);        // verify success
        ASSERT(0 == v32.back());    // verify null terminated

        // Next, we verify that the number of characters (characters, not bytes
        // or words) that was returned is correct.  Note that in UTF-32, the
        // number of unicode characters written is the same as the number of
        // 32 bit words written.

        enum { EXPECTED_CHARS_WRITTEN =
                        NUM_ASCII_CHARS + NUM_GREEK_CHARS + NUM_CHINESE_CHARS +
                        NUM_HINDI_CHARS + NUM_QUAD_CHARS  + 1 };
        ASSERT(EXPECTED_CHARS_WRITTEN == v32.size());

        // Next, we calculate and confirm the difference betwen the number of
        // utf32 words output and the number of bytes input.  The ascii chars
        // will take 1 32-bit word apiece, the Greek chars are double octets
        // that will become single unsigneds, the Chinese chars are encoded as
        // utf8 triple octets that will turn into single 32-bit words, the same
        // for the Hindi chars, and the quad chars are quadruple octets that
        // will turn into single unsigned ints.

        enum { SHRINKAGE =
                          NUM_ASCII_CHARS   * (1-1) + NUM_GREEK_CHARS * (2-1) +
                          NUM_CHINESE_CHARS * (3-1) + NUM_HINDI_CHARS * (3-1) +
                          NUM_QUAD_CHARS    * (4-1) };

        ASSERT(v32.size() == sizeof(utf8MultiLang) - SHRINKAGE);

        // Then, we go on to do the reverse 'utf32ToUtf8' transform to turn it
        // back into utf8, and we should get a result identical to our original
        // input.  Declare a 'bsl::string' for our output, and a variable to
        // count the number of characters (characters, not bytes or words)
        // translated.

        bsl::string s;
        bsl::size_t utf8CharsWritten;

        // Again, note that for performance, we should ideally
        // 's.reserve(3 * v32.size())' but it's not really necessary.

        // Now, we do the reverse transform:

        retVal = bdede_CharConvertUtf32::utf32ToUtf8(&s,
                                                     v32.begin(),
                                                     &utf8CharsWritten);

        // Finally, we verify a successful status was returned, that the output
        // of the reverse transform was identical to the original input, and
        // that the number of chars translated was as expected.

        ASSERT(0 == retVal);
        ASSERT(utf8MultiLang == s);
        ASSERT(s.length() + 1         == sizeof(utf8MultiLang));

        ASSERT(EXPECTED_CHARS_WRITTEN == utf8CharsWritten);
        ASSERT(v32.size()             == utf8CharsWritten);
      } break;
      case 15: {
        // --------------------------------------------------------------------
        // PURELY RANDOM UTF-8 -> UTF-32 TEST
        //
        // Concerns:
        //   That the translator can handle random inpuut without dire effects.
        //: 1 The translator never segfaultss and asserts never fail.
        //: 2 The output is always error-free UTF-32.  (Note we say
        //:   'error-free', not 'correct'.  Figuring out what the correct
        //:   UTF-32 would be given arbitary UTF-8 input is about as hard as
        //:   writing this whole component, so the exact output is not
        //:   checked).  We merely check that it does not contain any invalid
        //:   UTF-32 values.
        //
        // Plan:
        //: 1 Iterate thousands of time, enough time to take about 0.1 sec on
        //:   Linux.
        //: 2 Generate 'numBytess', a length from 6-16, of bytes of of input
        //:   that the test sequence is to be.
        //: 3 For each loop, iterate twice, once with a non-zero randomly
        //:   generated legal utf32 'errorChar', and once with
        //:   '0 == errorChar'.
        //: 4 Generate an input buffer 'utf8InBuf' of 'numBytes' bytes of
        //:   values that are purely random except that only the last one is 0.
        //: 5 Translate the UTF-8 to a UTF-32 vector 'utf32OutVec'.  Observe
        //:   that the 'out of space' bit of the return value is always 0.
        //: 6 Iterate 'len' from slightly more than 'utf32OutVec.size()' down
        //:   to 0, and for each value, translate 'utf8InBuf' to a buffer,
        //:   passing 'len' as capacity.
        //: 7 Observe that no more than 'len' words of output were written,
        //:   that there were no embedded 0's in the ouput, and that the final
        //:   word is 0.
        // --------------------------------------------------------------------

        if (verbose) cout << "PURELY RANDOM UTF-8 -> UTF-32 TEST\n"
                             "==================================\n";

        // This test case is calibrated to run as many test cases as can be run
        // in 0.1 sec on Linux, which will be much faster than 30 sec on the
        // slowest architecture.

        bsls::Stopwatch sw;
        sw.start();

        bsl::vector<char>         utf8OutVec;
        bsl::vector<unsigned int> utf32OutVec;

        enum { MAX_SEQ_LEN             = 17,
               SEQ_LEN_MOD             = MAX_SEQ_LEN - 1,
               MAX_UTF8_BYTES_INPUT    = MAX_SEQ_LEN };

        char utf8InBuf[          MAX_UTF8_BYTES_INPUT];
        unsigned int utf32OutBuf[MAX_UTF8_BYTES_INPUT + 1];
        enum { UTF32_OUT_BUF_LEN = sizeof(utf32OutBuf) / sizeof(int) };

        bsl::string utf8Seq;

        for (int ti = 0; ti < 25 * 1000; ++ti) {
            const unsigned numBytesIn = myRand15() % SEQ_LEN_MOD + 2;
            const unsigned int fillWord = myRandUtf32Char();

            char *pc = utf8InBuf;
            for (unsigned tj = 1; tj < numBytesIn; ++tj) {
                utf8InBuf[tj] = (char) (myRand15() & 0xff);
            }
            *pc++ = 0;
            ASSERT(pc - utf8InBuf <= MAX_UTF8_BYTES_INPUT);

            bsl::vector<char> utf8InVec(utf8InBuf + 0, pc);

            for (int zeroErrorChar = 0; zeroErrorChar < 2; ++zeroErrorChar) {
                unsigned int errorChar;
                if (zeroErrorChar) {
                    errorChar = 0;
                }
                else {
                    int ret;
                    do {
                        errorChar = myRandUtf32Char();
                        unsigned int utf32ErrorSeq[] = { errorChar, 0 };

                        // Note UTF32 -> UTF-8 translation is already
                        // well-tested.

                        bsl::string utf8ErrorSeq;
                        ret = Util::utf32ToUtf8(&utf8ErrorSeq,
                                                utf32ErrorSeq);
                    } while (0 != ret);
                    ASSERT(errorChar);
                }

                utf32OutVec.clear();
                utf32OutVec.resize(myRand15() % (2 * numBytesIn), fillWord);

                int ret = Util::utf8ToUtf32(&utf32OutVec,
                                            utf8InBuf,
                                            errorChar);
                ASSERT(0 == (ret & ~Status::BDEDE_INVALID_CHARS_BIT));
                ASSERT(bsl::find(utf32OutVec.begin(), utf32OutVec.end(), 0) ==
                                                          &utf32OutVec.back());
                ASSERT(utf32OutVec.size() <  numBytesIn);

                bsl::size_t ncw = -1;
                ret = Util::utf32ToUtf8(&utf8OutVec,
                                        utf32OutVec.begin(),
                                        &ncw);
                ASSERT(0 == ret);    // this is important -- the utf32 output
                                     // must have no errors
                ASSERT(utf32OutVec.size() == ncw);
                ASSERT(utf8OutVec.size() <= numBytesIn);
                ASSERT(bsl::find(utf8OutVec.begin(), utf8OutVec.end(), 0) ==
                                                           &utf8OutVec.back());

                if (veryVeryVerbose) Q(Now do xlation to a utf8 buffer);

                for (bsl::size_t len = utf32OutVec.size() + 1; len >= 2;
                                                                       --len) {
                    bsl::fill(utf32OutBuf + 0,
                              utf32OutBuf + UTF32_OUT_BUF_LEN,
                              fillWord);

                    ncw = -1;
                    ret = Util::utf8ToUtf32(utf32OutBuf,
                                            len,
                                            utf8InBuf,
                                            &ncw,
                                            errorChar);
                    LOOP6_ASSERT(ti, len, utf32OutVec.size(), ret,
                             dumpUtf8Vec(utf8InVec), dumpUtf32Vec(utf32OutVec),
                                                  (len < utf32OutVec.size()) ==
                                    !! (ret & Status::BDEDE_OUT_OF_SPACE_BIT));
                    ASSERT(len > utf32OutVec.size() ? utf32OutVec.size() == ncw
                                                    : ncw == len);
                    ASSERT(bsl::find_if(utf32OutBuf + ncw,
                                        utf32OutBuf + UTF32_OUT_BUF_LEN,
                                        NotEqual<unsigned int>(fillWord)) ==
                                              utf32OutBuf + UTF32_OUT_BUF_LEN);
                    ASSERT(bsl::find(utf32OutBuf + 0,
                                     utf32OutBuf + ncw,
                                     0) == utf32OutBuf + ncw - 1);
                }
            }
        }
        sw.stop();

        if (verbose) P(sw.accumulatedWallTime());
      } break;
      case 14: {
        // --------------------------------------------------------------------
        // TABLE-DRIVEN RANDOM UTF-8 -> UTF-32 SEQUENCES
        //
        // Concerns:
        //   That the translator performs well when passed a random assortment
        //   of UTF-8 sequences from 'utf8Table'.
        //: 1 No eequence causes segfaults and asserts never fail.
        //: 2 The translated output is exactly correct.
        //: 3 The return value is correct.
        //: 4 When the output is to a buffer that isn't long enough, it exactly
        //:   fills up the space in the buffer.
        //: 5 The UTF-32 output has *NO* errors in it.
        //
        // Plan:
        //: 1 Iterate thousands of time, enough time to take about 0.1 sec on
        //:   Linux.
        //: 2 Generate 'numChars', a length from 2-7, of unicode chars that our
        //:   test sequence is to be.
        //: 3 For each loop, iterate twice, once with a non-zero randomly
        //:   generated legal utf32 'errorChar', and once with
        //:   '0 == errorChar'.
        //: 4 When '0 != errorChar', generate a corresponding UTF-8 sequence
        //:   'errorSeq'.
        //: 5 Generate a sequence of bytes in buffer 'utf8InBuf' (and a copy in
        //:   vector 'utf8InVec') of 'numChars' unicode chars, but randomly
        //:   selecting utf8 sequences from 'utf8Table' (and eliminating the
        //:   preceding '1' and trailing 'z'.  Simultanously construct
        //:   vector 'utf32ExpVec' of what we expect the UTF-32 output to be
        //:   and vector 'utf8ExpVec' of what we expect the result to be when
        //:   that UTF-32 is translated back to UTF-8.
        //: 6 Translate 'utf8InBuf' to a utf32 vector 'utf32OutVec' and observe
        //:   the result and return value are as expected.
        //: 7 Translate 'utv32OutVec' to a utf8 vector 'utf8OutVec' and observe
        //:   the result and return value are as expected.
        //: 8 Iterate 'len' from slightly above the expected length of UTF-32
        //:   output down to 2, and translate 'utf8InBuf' to a utf32 buffer,
        //:   passing 'len' as capacity, and observe that the result and return
        //:   value are as expected.
        //: 9 Observe that no more than 'len' words of output were written,
        //:   that there were no embedded 0's in the ouput, and that the final
        //:   word is 0.
        // --------------------------------------------------------------------

        if (verbose) cout << "TABLE-DRIVEN RANDOM UTF-8 -> UTF-32 SEQUENCES\n"
                             "=============================================\n";

        // This test case is calibrated to run as many test cases as can be run
        // in 0.1 sec on Linux, which will be much faster than 30 sec on the
        // slowest architecture.

        bsls::Stopwatch sw;
        sw.start();

        bsl::vector<unsigned int> utf8InVec, utf32ExpVec;
        bsl::vector<char> utf8ExpVec;

        bsl::vector<char>         utf8OutVec;
        bsl::vector<unsigned int> utf32OutVec;

        enum { MAX_SEQ_LEN             = 7,
               SEQ_LEN_MOD             = MAX_SEQ_LEN - 1,
               MAX_UTF32_CHARS_WRITTEN = MAX_SEQ_LEN,
               MAX_UTF8_BYTES_INPUT    = (MAX_SEQ_LEN - 1) * 5 + 1,
               UTF8_TABLE_MOD          = NUM_UTF8_TABLE + 1 };

        char utf8InBuf[          MAX_UTF8_BYTES_INPUT];
        unsigned int utf32OutBuf[MAX_UTF32_CHARS_WRITTEN + 1];
        enum { UTF32_OUT_BUF_LEN = sizeof(utf32OutBuf) / sizeof(int) };

        bsl::string utf8Seq;

        for (int ti = 0; ti < 8 * 1000; ++ti) {
            const unsigned numCharsIn = myRand15() % SEQ_LEN_MOD + 2;
            const unsigned int fillWord = myRandUtf32Char();
            const char fillChar = (char) (myRand15() % 0xff);

            for (int zeroErrorChar = 0; zeroErrorChar < 2; ++zeroErrorChar) {
                unsigned int errorChar;
                bsl::string utf8ErrorSeq;
                if (zeroErrorChar) {
                    errorChar = 0;
                }
                else {
                    int ret;
                    do {
                        errorChar = myRandUtf32Char();
                        unsigned int utf32ErrorSeq[] = { errorChar, 0 };

                        // Note UTF32 -> UTF-8 translation is already
                        // well-tested.

                        ret = Util::utf32ToUtf8(&utf8ErrorSeq,
                                                utf32ErrorSeq);
                    } while (0 != ret);
                    ASSERT(errorChar);
                    ASSERT(utf8ErrorSeq.length() >= 1);
                }

                utf8ExpVec. clear();
                utf32ExpVec.clear();

                char *pc = utf8InBuf;
                bool errorsPresent = false;
                bool prevTrunc = false;
                for (unsigned tj = 1; tj < numCharsIn; ++tj) {
                    unsigned idx;
                    bool repeat = true;
                    for (; repeat;) {
                        idx = myRand15() % UTF8_TABLE_MOD;
                        if (NUM_UTF8_TABLE == idx) {
                            // continuation char, unless previous was truncated

                            repeat = prevTrunc;
                            if (!prevTrunc) {
                                char cont = (char) (0x80|(myRand15() & 0x3f));
                                unsigned seqlen = myRand15() % 5 + 1;
                                bsl::memset(pc, cont, seqlen);
                                pc += seqlen;

                                errorsPresent = true;
                                prevTrunc = seqlen < 5;

                                if (errorChar) {
                                    utf8ExpVec.insert(utf8ExpVec.end(),
                                                      utf8ErrorSeq.begin(),
                                                      utf8ErrorSeq.end());
                                    utf32ExpVec.push_back(errorChar);
                                }
                            }
                        }
                        else {
                            const char *utf8Seq =
                                               utf8Table[idx].d_utf8String + 1;
                            unsigned seqlen = bsl::strlen(utf8Seq) - 1;
                            ASSERT(seqlen <= 5);
                            ASSERT(seqlen >= 1);
                            bsl::memcpy(pc, utf8Seq, seqlen);
                            pc += seqlen;

                            repeat = false;
                            prevTrunc = utf8Table[idx].d_truncBy > 0;
                            if (utf8Table[idx].d_error) {
                                errorsPresent = true;

                                if (errorChar) {
                                    utf8ExpVec.insert(utf8ExpVec.end(),
                                                      utf8ErrorSeq.begin(),
                                                      utf8ErrorSeq.end());
                                    utf32ExpVec.push_back(errorChar);
                                }
                            }
                            else {
                                utf8ExpVec.insert(utf8ExpVec.end(),
                                                  utf8Seq,
                                                  utf8Seq + seqlen);
                                utf32ExpVec.push_back(utf8Table[idx].d_midVal);
                            }
                        }
                    }
                }
                *pc++ = 0;
                utf8ExpVec. push_back(0);
                utf32ExpVec.push_back(0);
                ASSERT(pc <= utf8InBuf + MAX_UTF8_BYTES_INPUT);
                LOOP4_ASSERT(ti, utf8ExpVec.size(), pc - utf8InBuf,
                                                errorChar, errorChar >= 0x80 ||
                                    (int) utf8ExpVec.size() <= pc - utf8InBuf);
                bsl::vector<char> utf8InVec(
                            utf8InBuf, utf8InBuf + bsl::strlen(utf8InBuf) + 1);

                utf32OutVec.clear();
                utf32OutVec.resize(myRand15() % (2 * numCharsIn), fillWord);

                int ret = Util::utf8ToUtf32(&utf32OutVec,
                                            utf8InBuf,
                                            errorChar);
                ASSERT(ret == (errorsPresent ? Status::BDEDE_INVALID_CHARS_BIT
                                             : 0));
                LOOP3_ASSERT(ti, dumpUtf32Vec(utf32ExpVec),
                                                     dumpUtf32Vec(utf32OutVec),
                                                   utf32ExpVec == utf32OutVec);
                ASSERT(bsl::find(utf32OutVec.begin(), utf32OutVec.end(), 0) ==
                                                         &utf32OutVec.back());
                ASSERT((errorsPresent && !errorChar)
                                           ? utf32OutVec.size() <  numCharsIn
                                           : utf32OutVec.size() == numCharsIn);

                if (veryVeryVerbose) Q(Now do the return trip);

                utf8OutVec.clear();
                utf8OutVec.resize(myRand15() % (8 * numCharsIn), fillChar);

                bsl::size_t ncw = -1;
                ret = Util::utf32ToUtf8(&utf8OutVec,
                                        utf32OutVec.begin(),
                                        &ncw);
                ASSERT(0 == ret);    // this is important -- the utf32 output
                                     // must have no errors
                ASSERT(utf32ExpVec.size() == ncw);
                ASSERT(bsl::find(utf8OutVec.begin(), utf8OutVec.end(), 0) ==
                                                           &utf8OutVec.back());
                ASSERT(utf8ExpVec == utf8OutVec);

                if (veryVeryVerbose) Q(Now do xlation to a utf8 buffer);

                for (bsl::size_t len = utf32ExpVec.size() + 1; len >= 2;
                                                                       --len) {
                    bsl::fill(utf32OutBuf + 0,
                              utf32OutBuf + UTF32_OUT_BUF_LEN,
                              fillWord);

                    ncw = -1;
                    bsl::size_t nbw = -1;
                    ret = Util::utf8ToUtf32(utf32OutBuf,
                                            len,
                                            utf8InBuf,
                                            &ncw,
                                            errorChar);
                    LOOP6_ASSERT(ti, len, utf32ExpVec.size(), ret,
                             dumpUtf8Vec(utf8InVec), dumpUtf32Vec(utf32ExpVec),
                                                  (len < utf32ExpVec.size()) ==
                                    !! (ret & Status::BDEDE_OUT_OF_SPACE_BIT));
                    ASSERT(errorsPresent || 0 ==
                                      (ret & Status::BDEDE_INVALID_CHARS_BIT));
                    ASSERT(len > utf32ExpVec.size() ? utf32ExpVec.size() == ncw
                                                    : ncw == len);
                    ASSERT(bsl::find_if(utf32OutBuf + ncw,
                                        utf32OutBuf + UTF32_OUT_BUF_LEN,
                                        NotEqual<unsigned int>(fillWord)) ==
                                              utf32OutBuf + UTF32_OUT_BUF_LEN);
                    ASSERT(bsl::find(utf32OutBuf + 0,
                                     utf32OutBuf + ncw,
                                     0) == utf32OutBuf + ncw - 1);
                }
            }
        }
        sw.stop();

        if (verbose) P(sw.accumulatedWallTime());
      } break;
      case 13: {
        // --------------------------------------------------------------------
        // PURELY RANDOM TEST UTF32 -> UTF8
        //
        // Concerns:
        //   That the UTF-32 -> UTF-8 translators will function properly with
        //  really randomly generated input.
        //: 1 That they produce correct output.
        //: 2 They return correct values.
        //: 3 When the output is to a buffer, they don't write past the end
        //:   of where they're supposed to.
        //: 4 The UTF-8 output should have *NO* erorrs in it.
        //
        // Plan:
        //: 1 Iterate thousands of times, enough to take 0.1 seconds on Linux.
        //: 2 For each iteration, generate a sequence of 1 to 6 UTF-32 chars
        //:   (not counting the 0), using the function 'myRandUtf32Char', which
        //:   has a possibility of generating any non-zero 32 bit value,
        //:   weighted toward the more intersting values.
        //: 3 Iterate twice, once with a randomly generate ASCII 'errorChar'
        //:   and once where 'errorChar' is 0.
        //: 4 For the random sequence generated in '2', anticipate the
        //:   corresponding UTF-8 output, given the input and the value of
        //:   'errorChar'.  Also anticipate the UTF-32 that would result from
        //:   a reverse translation of that output.
        //: 5 Translate the UTF-32 to a UTF-8 'bsl::vector', verify it against
        //:   the anticipated results.
        //: 6 Translate the UTF-32 to a UTF-8 'bsl::string', verify it against
        //:   the anticipated results.
        //: 7 Translate the UTF-8 output that we created back to a UTF-32
        //:   vector, verify that the results are as anticipated.
        //: 8 Iterate 'len' from the length of the UTF-8 output plus one
        //:   down to 1, and repeatedly to UTF-32 -> UTF-8 translation with a
        //:   buffer destination, and capacity 'len', and observe that the
        //:   results are as they should be.
        // --------------------------------------------------------------------

        if (verbose) cout << "PURELY RANDOM TEST UTF32 -> UTF8\n"
                             "================================\n";

        // This test case is calibrated to run as many test cases as can be run
        // in 0.1 sec on Linux, which will be much faster than 30 sec on the
        // slowest architecture.

        bsls::Stopwatch sw;
        sw.start();

        bsl::vector<unsigned int> utf32InVec, utf32ExpVec;
        bsl::vector<char> utf8ExpVec;

        bsl::vector<char>         utf8OutVec;
        bsl::string               utf8OutStr;
        bsl::vector<unsigned int> utf32OutVec;

        enum { MAX_SEQ_LEN            = 7,
               SEQ_LEN_MOD            = MAX_SEQ_LEN - 2,
               MAX_UTF8_BYTES_WRITTEN = (MAX_SEQ_LEN - 1) * 4 + 1 };

        char utf8OutBuf[MAX_UTF8_BYTES_WRITTEN + 1];

        for (int ti = 0; ti < 5 * 1000; ++ti) {
            const unsigned numCharsIn = myRand15() % SEQ_LEN_MOD + 2;
            const char fillChar = (char) (myRand15() & 0xff);

            utf32InVec. clear();

            for (unsigned tj = 1; tj < numCharsIn; ++tj) {
                utf32InVec.push_back(myRandUtf32Char());
            }
            utf32InVec.push_back(0);

            for (int zeroErrorChar = 0; zeroErrorChar < 2; ++zeroErrorChar) {
                char errorChar = 0;
                if (!zeroErrorChar) {
                    errorChar = myRand15() % 0x80;
                    errorChar || (errorChar = '?');    // never zero
                }

                utf8ExpVec. clear();
                utf32ExpVec.clear();

                bool errorsPresent = false;
                unsigned int uc;
                for (unsigned int *pui = utf32InVec.begin(); (uc = *pui);
                                                                       ++pui) {
                    const bool IS_ERROR = (uc >= 0xd800 && uc <= 0xdfff) ||
                                                                 uc > 0x10ffff;

                    if (! IS_ERROR) {
                        char buffer[4];
                        char *pc = decodeUtf32(buffer, uc);
                        ASSERT(pc <= buffer + 4);

                        utf8ExpVec.insert(utf8ExpVec.end(), buffer, pc);
                        utf32ExpVec.push_back(uc);
                    }
                    else if (!zeroErrorChar) {
                        utf8ExpVec. push_back(errorChar);
                        utf32ExpVec.push_back(errorChar);
                    }

                    errorsPresent |= IS_ERROR;
                }
                utf8ExpVec. push_back(0);
                utf32ExpVec.push_back(0);
                LOOP3_ASSERT(zeroErrorChar, utf32ExpVec.size(), numCharsIn,
                            !zeroErrorChar ? utf32ExpVec.size() == numCharsIn
                                           : utf32ExpVec.size() <= numCharsIn);
                ASSERT(utf8ExpVec.size() <= MAX_UTF8_BYTES_WRITTEN);

                bsl::size_t ncw = -1;
                utf8OutVec.resize(myRand15() % 10);
                bsl::fill(utf8OutVec.begin(), utf8OutVec.end(), fillChar);
                int ret = Util::utf32ToUtf8(&utf8OutVec,
                                            utf32InVec.begin(),
                                            &ncw,
                                            errorChar);
                ASSERT(ret == (errorsPresent ? Status::BDEDE_INVALID_CHARS_BIT
                                             : 0));
                ASSERT(ncw == utf32ExpVec.size());

                ASSERT(utf8OutVec.size() == utf8ExpVec.size());
                ASSERT(utf8OutVec        == utf8ExpVec);
                ASSERT(bsl::strlen(utf8OutVec.begin()) == utf8OutVec.size()-1);

                utf8OutStr.resize(myRand15() % 10);
                bsl::fill(utf8OutStr.begin(), utf8OutStr.end(), fillChar);

                ncw = -1;
                ret = Util::utf32ToUtf8(&utf8OutStr,
                                        utf32InVec.begin(),
                                        &ncw,
                                        errorChar);
                ASSERT(ret == (errorsPresent ? Status::BDEDE_INVALID_CHARS_BIT
                                             : 0));
                ASSERT(ncw == utf32ExpVec.size());
                ASSERT(! bsl::strcmp(utf8OutStr.c_str(), utf8OutVec.begin()));

                utf32OutVec.resize(myRand15() % 10);
                bsl::fill(utf32OutVec.begin(), utf32OutVec.end(), fillChar);

                ret = Util::utf8ToUtf32(&utf32OutVec,
                                        utf8ExpVec.begin(),
                                        zeroErrorChar ? 0 : '*');
                ASSERT(0 == ret);
                ASSERT(utf32OutVec.size() == utf32ExpVec.size());
                ASSERT(utf32OutVec        == utf32ExpVec);


                for (bsl::size_t len = utf8ExpVec.size() + 1; len >= 1; --len){
                    bsl::fill(&utf8OutBuf[0], &utf8OutBuf[sizeof(utf8OutBuf)],
                                                                     fillChar);

                    ncw = -1;
                    bsl::size_t nbw = -1;
                    ret = Util::utf32ToUtf8(utf8OutBuf,
                                            len,
                                            utf32InVec.begin(),
                                            &ncw,
                                            &nbw,
                                            errorChar);
                    if (!errorsPresent) {
                        ASSERT(0 == (ret & Status::BDEDE_INVALID_CHARS_BIT));
                    }
                    ASSERT((len < utf8ExpVec.size()) ==
                                     !!(ret & Status::BDEDE_OUT_OF_SPACE_BIT));
                    ASSERT(ncw <= utf8ExpVec.size());
                    ASSERT(ncw <= len);
                    ASSERT(nbw <= MAX_UTF8_BYTES_WRITTEN);
                    ASSERT(nbw <= len);
                    ASSERT(nbw >= (unsigned) bsl::max<int>(len - 4, 0));
                    ASSERT(utf8OutBuf + sizeof(utf8OutBuf) ==
                                  bsl::find_if(utf8OutBuf + nbw,
                                               utf8OutBuf + sizeof(utf8OutBuf),
                                               NotEqual<char>(fillChar)));
                    ASSERT(bsl::strlen(utf8OutBuf) + 1 == nbw);
                    ASSERT(! bsl::strncmp(utf8OutBuf,
                                          utf8ExpVec.begin(),
                                          nbw - 1));
                }
            }
        }
        sw.stop();

        if (verbose) P(sw.accumulatedWallTime());
      } break;
      case 12: {
        // --------------------------------------------------------------------
        // RANDOM SEQUENCES TEST UTF-32 -> UTF-8 WITH ZERO ERRORCHAR
        //
        // Concerns:
        //   That the translators will function properly on randomly generated
        //   input.
        //
        // Plan:
        //   Use 'utf32Table' to generate random sequences of UTF-8 and
        //   anticipate the corresponding UTF-32, do the translation and
        //   verify the results.
        // --------------------------------------------------------------------

        if (verbose) cout <<
                 "RANDOM SEQUENCES TEST UTF-32 -> UTF-8 WITH ZERO ERRORCHAR\n"
                 "=========================================================\n";

        // This test case is calibrated to run as many test cases as can be run
        // in 0.1 sec on Linux, which will be much faster than 30 sec on the
        // slowest architecture.

        bsls::Stopwatch sw;
        sw.start();

        bsl::vector<unsigned int> utf32InVec, utf32ExpVec;
        bsl::vector<char> utf8ExpVec;
        bsl::vector<char> bufferVec;

        for (int ti = 0; ti < 15 * 1000; ++ti) {
            const int numCharsIn = myRand32() % 4 + 1;
            const char fillChar = (char) (myRand15() & 0xff);

            utf32InVec. clear();
            utf8ExpVec. clear();
            utf32ExpVec.clear();

            bool errorsPresent = false;
            for (int tj = 1; tj < numCharsIn; ++tj) {
                unsigned tr = myRand32() % NUM_UTF32_TABLE;
                unsigned int uc      = utf32Table[tr].d_utf32Val;
                const char *utf8Str  = utf32Table[tr].d_utf8String;
                const bool  IS_ERROR = utf32Table[tr].d_error;

                utf32InVec.push_back(uc);
                if (! IS_ERROR) {
                    utf8ExpVec.insert(utf8ExpVec.end(),
                                      utf8Str,
                                      utf8Str + bsl::strlen(utf8Str));
                    utf32ExpVec.push_back(uc);
                }

                errorsPresent |= IS_ERROR;
            }
            utf32InVec. push_back(0);
            utf8ExpVec. push_back(0);
            utf32ExpVec.push_back(0);

            ASSERT((int) utf32InVec.size() == numCharsIn);
            bsl::size_t numCharsOut = utf32ExpVec.size();

            if (veryVerbose) Q(UTF-32 -> UTF-8);

            bsl::size_t ncw = -1;

            bsl::vector<char> utf8OutVec;
            int ret = Util::utf32ToUtf8(&utf8OutVec,
                                        utf32InVec.begin(),
                                        &ncw,
                                        0);
            ASSERT(ret == (errorsPresent ? Status::BDEDE_INVALID_CHARS_BIT
                                         : 0));
            ASSERT((int) ncw == numCharsOut);

            ASSERT(utf8OutVec.size() == utf8ExpVec.size());
            ASSERT(utf8OutVec        == utf8ExpVec);

            if (veryVerbose) Q(UTF-8 -> UTF-32);

            bsl::vector<unsigned int> utf32OutVec;
            ret = Util::utf8ToUtf32(&utf32OutVec,
                                    utf8OutVec.begin());
            ASSERT(0 == ret);
            ASSERT((int) utf32OutVec.size() == numCharsOut);

            ASSERT(utf32ExpVec.size() == utf32OutVec.size());
            ASSERT(utf32ExpVec        == utf32OutVec);

            if (veryVerbose) Q(UTF-32 -> UTF-8 Buffer);

            for (int len = utf8OutVec.size() + 1; len >= 0; --len) {
                bufferVec.clear();
                bufferVec.resize(utf8OutVec.size() + 4, fillChar);

                const int expectedRet = len < (int) utf8OutVec.size() ?
                                            Status::BDEDE_OUT_OF_SPACE_BIT : 0;

                ncw = -1;
                bsl::size_t nbw = -1;
                ret = Util::utf32ToUtf8(bufferVec.begin(),
                                        (bsl::size_t) len,
                                        utf32InVec.begin(),
                                        &ncw,
                                        &nbw,
                                        0);
                LOOP5_ASSERT(ti, len, utf8OutVec.size(), expectedRet, ret,
                        expectedRet == (ret & Status::BDEDE_OUT_OF_SPACE_BIT));
                ASSERT((int) ncw <= numCharsOut);
                ASSERT(len >= (int) utf8OutVec.size() ||
                                                     (int) ncw <  numCharsOut);
                ASSERT(len <  (int) utf8OutVec.size() ||
                                                     (int) ncw == numCharsOut);
                ASSERT(nbw <= utf8OutVec.size());
                ASSERT(len >= (int) utf8OutVec.size() ||
                                                     nbw <  utf8OutVec.size());
                ASSERT(len <  (int) utf8OutVec.size() ||
                                                     nbw == utf8OutVec.size());
                ASSERT(!nbw == !ncw);
                ASSERT(len > (int) utf8OutVec.size() || (int) nbw >= len - 4);
                ASSERT(!nbw || bsl::strlen(bufferVec.begin()) == nbw - 1);

                ASSERT(!nbw || 0 == bsl::strncmp(utf8OutVec.begin(),
                                                 bufferVec.begin(),
                                                 nbw - 1));
                ASSERT(bufferVec.end() == bsl::find_if(
                                                    &bufferVec[nbw],
                                                    bufferVec.end(),
                                                    NotEqual<char>(fillChar)));
            }
        }
        sw.stop();

        if (verbose) P(sw.accumulatedWallTime());
      } break;
      case 11: {
        // --------------------------------------------------------------------
        // RANDOM SEQUENCES TEST UTF-33 -> UTF-8
        //
        // Concerns:
        //   That the translators will function properly on randomly generated
        //   input.
        //
        // Plan:
        //   Use 'utf32Table' to generate random sequences of UTF-8 and
        //   anticipate the corresponding UTF-32, do the translation and
        //   verify the results.
        // --------------------------------------------------------------------

        if (verbose) cout << "RANDOM SEQUENCES TEST UTF-32 -> UTF-8\n"
                             "=====================================\n";

        // This test case is calibrated to run as many test cases as can be run
        // in 0.1 sec on Linux, which will be much faster than 30 sec on the
        // slowest architecture.

        bsls::Stopwatch sw;
        sw.start();

        bsl::vector<unsigned int> utf32InVec, utf32ExpVec;
        bsl::vector<char> utf8ExpVec;
        bsl::vector<char> bufferVec;

        for (int ti = 0; ti < 15 * 1000; ++ti) {
            const int numChars = myRand32() % 6 + 2;
            const char fillChar = (char) (myRand15() & 0xff);

            utf32InVec. clear();
            utf8ExpVec. clear();
            utf32ExpVec.clear();

            bool errorsPresent = false;
            for (int tj = 1; tj < numChars; ++tj) {
                unsigned tr = myRand32() % NUM_UTF32_TABLE;
                unsigned int uc      = utf32Table[tr].d_utf32Val;
                const char *utf8Str  = utf32Table[tr].d_utf8String;
                const bool  IS_ERROR = utf32Table[tr].d_error;

                utf32InVec.push_back(uc);
                utf8ExpVec.insert(utf8ExpVec.end(),
                                  utf8Str,
                                  utf8Str + bsl::strlen(utf8Str));
                utf32ExpVec.push_back(IS_ERROR ? '?' : uc);

                errorsPresent |= IS_ERROR;
            }
            utf32InVec. push_back(0);
            utf8ExpVec. push_back(0);
            utf32ExpVec.push_back(0);

            ASSERT((int) utf32InVec.size() == numChars);

            if (veryVerbose) Q(UTF-32 -> UTF-8);

            bsl::size_t ncw = -1;

            bsl::vector<char> utf8OutVec;
            utf8OutVec.resize(myRand15() % 9, fillChar);
            int ret = Util::utf32ToUtf8(&utf8OutVec,
                                        utf32InVec.begin(),
                                        &ncw);
            ASSERT(ret == (errorsPresent ? Status::BDEDE_INVALID_CHARS_BIT
                                         : 0));
            ASSERT((int) ncw == numChars);

            ASSERT(utf8OutVec.size() == utf8ExpVec.size());
            ASSERT(utf8OutVec        == utf8ExpVec);

            if (veryVerbose) Q(UTF-8 -> UTF-32);

            bsl::vector<unsigned int> utf32OutVec;
            utf32OutVec.resize(myRand15() % 9, myRand32());
            ret = Util::utf8ToUtf32(&utf32OutVec,
                                    utf8OutVec.begin());
            ASSERT(0 == ret);
            ASSERT((int) utf32OutVec.size() == numChars);

            ASSERT(utf32ExpVec.size() == utf32OutVec.size());
            ASSERT(utf32ExpVec        == utf32OutVec);

            if (veryVerbose) Q(UTF-32 -> UTF-8 Buffer);

            for (int len = utf8OutVec.size() + 1; len >= 2; --len) {
                bufferVec.clear();
                bufferVec.resize(utf8OutVec.size() + 4, fillChar);

                int expectedRet = len < (int) utf8OutVec.size() ?
                                            Status::BDEDE_OUT_OF_SPACE_BIT : 0;

                ncw = -1;
                bsl::size_t nbw = -1;
                ret = Util::utf32ToUtf8(bufferVec.begin(),
                                        (bsl::size_t) len,
                                        utf32InVec.begin(),
                                        &ncw,
                                        &nbw);
                LOOP5_ASSERT(ti, len, utf8OutVec.size(), expectedRet, ret,
                        expectedRet == (ret & Status::BDEDE_OUT_OF_SPACE_BIT));
                ASSERT((int) ncw <= numChars);
                ASSERT(len >= (int) utf8OutVec.size() ||(int) ncw <  numChars);
                ASSERT(len <  (int) utf8OutVec.size() ||(int) ncw == numChars);
                ASSERT(nbw <= utf8OutVec.size());
                ASSERT(len >= (int) utf8OutVec.size() ||
                                                     nbw <  utf8OutVec.size());
                ASSERT(len <  (int) utf8OutVec.size() ||
                                                     nbw == utf8OutVec.size());
                ASSERT(len > (int) utf8OutVec.size() || (int) nbw >= len - 4);
                ASSERT(!nbw || bsl::strlen(bufferVec.begin()) == nbw - 1);

                ASSERT(!nbw || 0 == bsl::strncmp(utf8OutVec.begin(),
                                                 bufferVec.begin(),
                                                 nbw - 1));
                ASSERT(bufferVec.end() == bsl::find_if(
                                                    &bufferVec[nbw],
                                                    bufferVec.end(),
                                                    NotEqual<char>(fillChar)));
            }
        }
        sw.stop();

        if (verbose) P(sw.accumulatedWallTime());
      } break;
      case 10: {
        // --------------------------------------------------------------------
        // REAL PROSE TEST
        //
        // Concerns:
        //   That the translators will fuunction properly on real,
        //   human-generated, multi language prose.
        //
        // Plan:
        //   The char array 'utf8Multilang' above contains prose written in in
        //   Chinese, Hindi, French, and Greek written in UTF-8, with a few
        //   4-octet sequences added.  This will be translated into UTF-32 and
        //   back, which should be achievable without any errors, and the
        //   final result should be identical to the original.
        // --------------------------------------------------------------------

        if (verbose) cout << "REAL PROSE TEST\n"
                             "===============\n";

        const unsigned origLen = bsl::strlen(charUtf8MultiLang);
        ASSERT(origLen > 1000);

        if (verbose) P(origLen);

        bsl::vector<unsigned int> utf32Vec;
        int ret = Util::utf8ToUtf32(&utf32Vec, charUtf8MultiLang);
        ASSERT(0 == ret);

        ASSERT(utf32Vec.size() > 400);
        if (verbose) P(utf32Vec.size());

        bsl::string utf8Str;
        ret = Util::utf32ToUtf8(&utf8Str, utf32Vec.begin());
        ASSERT(0 == ret);

        ASSERT(origLen == utf8Str.length());

        ASSERT(0 == bsl::strcmp(utf8Str.c_str(), charUtf8MultiLang));
      } break;
      case 9: {
        // --------------------------------------------------------------------
        // TESTING UTF-32 -> UTF-8 WITH EXPLICIT 'errorCharacter'
        //
        // Concerns:
        //   That non-zero values other than '?' can be substituted for
        //   'errorCharacter'.
        //
        // Plan:
        //   Repeat the vector destination case from TC 7, subsituting all
        //   ascii values for 'errorCharacter' and observe the outbut.
        // --------------------------------------------------------------------

        if (verbose) cout <<
                    "TESTING UTF-32 -> UTF-8 WITH EXPLICIT 'errorCharacter'\n"
                    "======================================================\n";

        if (verbose) Q(Passing non-zero 'errorCharacter');

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { '1', UTF32_VAL, 'z', 0 };

            int expectedRet = IS_ERROR
                            ? Status::BDEDE_INVALID_CHARS_BIT
                            : 0;

            for (int errChr = 1; errChr < 0x80; ++errChr) {
                bsl::vector<char> compareVec, outVec;
                compareVec.push_back('1');
                if (IS_ERROR) {
                    compareVec.push_back((char) errChr);
                }
                else {
                    for (const char *pc = UTF8_STRING; *pc; ++pc) {
                        compareVec.push_back(*pc);
                    }
                }
                compareVec.push_back('z');
                compareVec.push_back(0);

                bsl::size_t numChars = -1;
                int ret = Util::utf32ToUtf8(&outVec,
                                            utf32Seq,
                                            &numChars,
                                            (char) errChr);
                ASSERT(4 == numChars);

                LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                ASSERT(compareVec == outVec);
            }
        }

        if (verbose) Q(Explicitly Passing '0 == errorCharacter');

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { '1', UTF32_VAL, 'z', 0 };

            int expectedRet = IS_ERROR
                            ? Status::BDEDE_INVALID_CHARS_BIT
                            : 0;

            bsl::vector<char> compareVec, outVec;
            compareVec.push_back('1');
            if (! IS_ERROR) {
                for (const char *pc = UTF8_STRING; *pc; ++pc) {
                    compareVec.push_back(*pc);
                }
            }
            compareVec.push_back('z');
            compareVec.push_back(0);

            bsl::size_t numChars = -1;
            int ret = Util::utf32ToUtf8(&outVec,
                                        utf32Seq,
                                        &numChars,
                                        0);
            ASSERT((unsigned) 4 - IS_ERROR == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareVec == outVec);
        }
      } break;
      case 8: {
        // --------------------------------------------------------------------
        // Testing Utf-32 -> utf-8 Translation With Zero error char
        //
        // Concerns:
        //: 1 That UTF-32 -> UTF-8 translation is performed correctly when
        //:   0 is passed to 'errorCharacter'.
        //:   o When the destination is a 'bsl::vector<char>'.
        //:   o When the destination is a 'bsl::string'
        //:   o When the destination is a buffer of limited length.
        //
        // Plan:
        //: 1 Repeat the tests from TC 7, omitting the 'check' iteration
        //:   and passing '0' to the 'errorCharacter' arguments.
        //: 2 For the buffer test, calculate 'enc', which is the expected
        //:   number of chars output in the buffer test, derived from the
        //:   previously calculated 'expectedNumChars' from the vector and
        //:   string tests.
        // --------------------------------------------------------------------

        if (verbose) cout << "Testing UTF-32 -> UTF-8 Translation\n"
                             "===================================\n";

        if (verbose) Q(Testing Full Sequence);

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { '1', UTF32_VAL, 'z', 0 };
            bsl::vector<char> compareVec, outVec;
            compareVec.push_back('1');
            if (!IS_ERROR) {
                for (const char *pc = UTF8_STRING; *pc; ++pc) {
                    compareVec.push_back(*pc);
                }
            }
            compareVec.push_back('z');
            compareVec.push_back(0);
            const bsl::string compareStr = &compareVec[0];

            int expectedRet = IS_ERROR
                            ? Status::BDEDE_INVALID_CHARS_BIT
                            : 0;

            bsl::size_t expectedNumChars = 4 - IS_ERROR;
            bsl::size_t numChars = -1;
            int ret = Util::utf32ToUtf8(&outVec,
                                        utf32Seq,
                                        &numChars,
                                        0);
            ASSERT(expectedNumChars == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareVec == outVec);

            bsl::string outStr;
            numChars = -1;    ret = -1;

            ret = Util::utf32ToUtf8(&outStr,
                                    utf32Seq,
                                    &numChars,
                                    0);
            ASSERT(expectedNumChars == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareStr == outStr);

            for (bsl::size_t len = compareVec.size() + 2;
                                          (bsl::size_t) -1 != len; --len) {
                char outBuf[100];
                bsl::memset(outBuf, -1, sizeof(outBuf));
                numChars = -1;

                expectedRet = IS_ERROR && len >= 2
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedRet |= len < compareVec.size()
                                               ? Status::BDEDE_OUT_OF_SPACE_BIT
                                               : 0;

                const unsigned int cvs = compareVec.size();
                const unsigned enc = len >= cvs   ? expectedNumChars
                                   : len == cvs-1 ? expectedNumChars - 1
                                   : len >= 2     ? 2
                                   :                len;
                ASSERT(expectedNumChars <= 4);
                const bsl::size_t expectedNumBytes =
                                   enc <= 2                    ? enc
                                 : enc == expectedNumChars - 1 ? cvs - 1
                                 :                               cvs;

                bsl::size_t numBytes = -1;
                ret = Util::utf32ToUtf8(outBuf,
                                        len,
                                        utf32Seq,
                                        &numChars,
                                        &numBytes,
                                        0);
                LOOP4_ASSERT(LINE, len, expectedNumBytes, numBytes,
                                                 expectedNumBytes == numBytes);
                ASSERT(enc == numChars);

                LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);

                LOOP2_ASSERT(LINE, len,
                               0 == bsl::memcmp(outBuf, &compareStr[0],
                                                        expectedNumBytes - 1));
                LOOP2_ASSERT(LINE, len,
                                0 == len || 0 == outBuf[expectedNumBytes - 1]);
            }
        }

        if (verbose) Q(Testing Sequence Without Leading Ascii Val);

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { UTF32_VAL, 'z', 0 };
            bsl::vector<char> compareVec, outVec;
            if (!IS_ERROR) {
                for (const char *pc = UTF8_STRING; *pc; ++pc) {
                    compareVec.push_back(*pc);
                }
            }
            compareVec.push_back('z');
            compareVec.push_back(0);
            const bsl::string compareStr = &compareVec[0];

            int expectedRet = IS_ERROR
                            ? Status::BDEDE_INVALID_CHARS_BIT
                            : 0;

            bsl::size_t expectedNumChars = 3 - IS_ERROR;
            bsl::size_t numChars = -1;
            int ret = Util::utf32ToUtf8(&outVec,
                                        utf32Seq,
                                        &numChars,
                                        0);
            ASSERT(expectedNumChars == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareVec == outVec);

            bsl::string outStr;
            numChars = -1;    ret = -1;

            ret = Util::utf32ToUtf8(&outStr,
                                    utf32Seq,
                                    &numChars,
                                    0);
            ASSERT(expectedNumChars == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareStr == outStr);

            for (bsl::size_t len = compareVec.size() + 2;
                                          (bsl::size_t) -1 != len; --len) {
                char outBuf[100];
                bsl::memset(outBuf, -1, sizeof(outBuf));
                numChars = -1;

                expectedRet = IS_ERROR && len >= 1
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedRet |= len < compareVec.size()
                                               ? Status::BDEDE_OUT_OF_SPACE_BIT
                                               : 0;

                const unsigned int cvs = compareVec.size();
                const unsigned enc = len >= cvs     ? expectedNumChars
                                   : len == cvs - 1 ? expectedNumChars - 1
                                   :                  !!len;
                ASSERT(expectedNumChars <= 3);
                const bsl::size_t expectedNumBytes =
                                          enc == expectedNumChars     ? cvs
                                        : enc == expectedNumChars - 1 ? cvs - 1
                                        :                               !!enc;

                if (veryVeryVeryVerbose) {
                    P_(LINE);    P_(len);    P_(cvs);    P_(expectedNumChars);
                    P_(enc);     P(expectedNumBytes);
                }

                bsl::size_t numBytes = -1;
                ret = Util::utf32ToUtf8(outBuf,
                                        len,
                                        utf32Seq,
                                        &numChars,
                                        &numBytes,
                                        0);
                LOOP4_ASSERT(LINE, len, expectedNumBytes, numBytes,
                                                 expectedNumBytes == numBytes);
                LOOP4_ASSERT(LINE, len, enc, numChars, enc == numChars);

                LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);

                LOOP2_ASSERT(LINE, len,
                               0 == bsl::memcmp(outBuf, &compareStr[0],
                                                        expectedNumBytes - 1));
                LOOP2_ASSERT(LINE, len,
                                0 == len || 0 == outBuf[expectedNumBytes - 1]);
            }
        }

        if (verbose) Q(Testing Sequence Without Trailing Ascii);

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { '1', UTF32_VAL, 0 };
            bsl::vector<char> compareVec, outVec;
            compareVec.push_back('1');
            if (!IS_ERROR) {
                for (const char *pc = UTF8_STRING; *pc; ++pc) {
                    compareVec.push_back(*pc);
                }
            }
            compareVec.push_back(0);
            const bsl::string compareStr = &compareVec[0];

            int expectedRet = IS_ERROR
                            ? Status::BDEDE_INVALID_CHARS_BIT
                            : 0;

            const bsl::size_t expectedNumChars = 3 - IS_ERROR;
            bsl::size_t numChars = -1;
            int ret = Util::utf32ToUtf8(&outVec,
                                        utf32Seq,
                                        &numChars,
                                        0);
            ASSERT(expectedNumChars == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareVec == outVec);

            bsl::string outStr;
            numChars = -1;    ret = -1;

            ret = Util::utf32ToUtf8(&outStr,
                                    utf32Seq,
                                    &numChars,
                                    0);
            ASSERT(expectedNumChars == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareStr == outStr);

            for (bsl::size_t len = compareVec.size() + 2;
                                          (bsl::size_t) -1 != len; --len) {
                char outBuf[100];
                bsl::memset(outBuf, -1, sizeof(outBuf));
                numChars = -1;

                expectedRet = IS_ERROR && len >= 2
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedRet |= len < compareVec.size()
                                               ? Status::BDEDE_OUT_OF_SPACE_BIT
                                               : 0;

                const unsigned int cvs = compareVec.size();
                const unsigned enc = len >= cvs   ? expectedNumChars
                                   : len == cvs-1 ? expectedNumChars - 1
                                   : len >= 2     ? 2
                                   :                len;
                ASSERT(expectedNumChars <= 3);
                const bsl::size_t expectedNumBytes =
                                   enc <= 2                    ? enc
                                 : enc == expectedNumChars - 1 ? cvs - 1
                                 :                               cvs;

                if (veryVeryVerbose) {
                    P_(LINE);    P_(len);    P_(cvs);    P_(expectedNumChars);
                    P_(enc);     P(expectedNumBytes);
                }

                bsl::size_t numBytes = -1;
                ret = Util::utf32ToUtf8(outBuf,
                                        len,
                                        utf32Seq,
                                        &numChars,
                                        &numBytes,
                                        0);
                LOOP4_ASSERT(LINE, len, expectedNumBytes, numBytes,
                                                 expectedNumBytes == numBytes);
                ASSERT(enc == numChars);

                LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);

                LOOP2_ASSERT(LINE, len,
                               0 == bsl::memcmp(outBuf, &compareStr[0],
                                                        expectedNumBytes - 1));
                LOOP2_ASSERT(LINE, len,
                                0 == len || 0 == outBuf[expectedNumBytes - 1]);
            }
        }

        if (verbose) Q(Testing Sequence By Itself);

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { UTF32_VAL, 0 };
            bsl::vector<char> compareVec, outVec;
            if (!IS_ERROR) {
                for (const char *pc = UTF8_STRING; *pc; ++pc) {
                    compareVec.push_back(*pc);
                }
            }
            compareVec.push_back(0);
            const bsl::string compareStr = &compareVec[0];

            int expectedRet = IS_ERROR
                            ? Status::BDEDE_INVALID_CHARS_BIT
                            : 0;

            const bsl::size_t expectedNumChars = 2 - IS_ERROR;
            bsl::size_t numChars = -1;
            int ret = Util::utf32ToUtf8(&outVec,
                                        utf32Seq,
                                        &numChars,
                                        0);
            ASSERT(expectedNumChars == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareVec == outVec);

            bsl::string outStr;
            numChars = -1;    ret = -1;

            ret = Util::utf32ToUtf8(&outStr,
                                    utf32Seq,
                                    &numChars,
                                    0);
            ASSERT(expectedNumChars == numChars);

            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(compareStr == outStr);

            for (bsl::size_t len = compareVec.size() + 2;
                                          (bsl::size_t) -1 != len; --len) {
                char outBuf[100];
                bsl::memset(outBuf, -1, sizeof(outBuf));
                numChars = -1;

                expectedRet = IS_ERROR && len >= 1
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedRet |= len < compareVec.size()
                                               ? Status::BDEDE_OUT_OF_SPACE_BIT
                                               : 0;

                const unsigned int cvs = compareVec.size();
                const unsigned enc = len >= cvs   ? expectedNumChars
                                   :                !!len;
                ASSERT(expectedNumChars <= 2);
                const bsl::size_t expectedNumBytes =
                                               enc <  expectedNumChars ? !!enc
                                             :                           cvs;

                if (veryVeryVerbose) {
                    P_(LINE);    P_(len);    P_(cvs);    P_(expectedNumChars);
                    P_(enc);     P(expectedNumBytes);
                }

                bsl::size_t numBytes = -1;
                ret = Util::utf32ToUtf8(outBuf,
                                        len,
                                        utf32Seq,
                                        &numChars,
                                        &numBytes,
                                        0);
                LOOP4_ASSERT(LINE, len, expectedNumBytes, numBytes,
                                                 expectedNumBytes == numBytes);
                ASSERT(enc == numChars);

                LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);

                LOOP2_ASSERT(LINE, len,
                               0 == bsl::memcmp(outBuf, &compareStr[0],
                                                        expectedNumBytes - 1));
                LOOP2_ASSERT(LINE, len,
                                0 == len || 0 == outBuf[expectedNumBytes - 1]);
            }
        }
      } break;
      case 7: {
        // --------------------------------------------------------------------
        // Testing Utf-32 -> utf-8 Translation
        //
        // Concerns:
        //: 1 That UTF-32 -> UTF-8 translation is performed correctly
        //:   o When the destination is a 'bsl::vector<char>'.
        //:   o When the destination is a 'bsl::string'
        //:   o When the destination is a buffer of limited length.
        //
        // Plan:
        //: 1 Test all the sequences in utf32Table
        //:   o When the destination is a 'bsl::vector<char>'.
        //:   o When the destination is a 'bsl::string'
        //:   o When the destination is a buffer of limited length.
        //: 2 Repeat the tests in 1
        //:   o Preceded, and followed, by an ascii value
        //:   o Followed by an ascii value
        //:   o Preceded by an ascii value
        //:   o by itself
        //: 3 In all these tests, calculate and verify
        //:   o 'expectedRet', the expected return value of the call
        //:   o 'expectedNumChars', the expected value to be returned by the
        //:     'numCharactersWritten' arg, if passed
        //:   o 'expectedNumBytes', the expected value to be returned by the
        //:     'numBytesWritten' arg, if passed
        //:   o 'compareVec' and 'compareStr' containing the anticipated
        //:     UTF-8 output sequence
        //: 4 Iterate the variable 'check' to indicate
        //:   o 'check == 0' means call only the buffer routine, passing both
        //:     '&numChars' and '&numBytes' to it.
        //:   o 'check == 1', means call the vector, string, and buffer
        //:     reoutines, passing '&numChars' but not '&numBytesWritten' to
        //:     them.
        //:   o 'check == 2', means call the vector, string, and buffer
        //:     reoutines, passing neither '&numChars' nor '&numBytesWritten'
        //:     to them.
        //: 5 When calling the buffer output routine, iterate the variable
        //:   'len' to be passed to the 'capacity' arg, from more than enough
        //:   down to zero and observe that the translator translates as much
        //:   of the sequence as will fit.
        // --------------------------------------------------------------------

        if (verbose) cout << "Testing UTF-32 -> UTF-8 Translation\n"
                             "===================================\n";

        if (verbose) Q(Testing Full Sequence);

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { '1', UTF32_VAL, 'z', 0 };
            bsl::vector<char> compareVec, outVec;
            compareVec.push_back('1');
            for (const char *pc = UTF8_STRING; *pc; ++pc) {
                compareVec.push_back(*pc);
            }
            compareVec.push_back('z');
            compareVec.push_back(0);
            const bsl::string compareStr = &compareVec[0];

            for (int check = 0; check < 2; ++check) {
                // check == 0, check 'numChars' && 'numBytes'
                // check == 1: check 'numChars'
                // check == 2: check neither

                int expectedRet = IS_ERROR
                                ? Status::BDEDE_INVALID_CHARS_BIT
                                : 0;

                bsl::size_t numChars = -1;
                int ret;

                if (check) {
                    if (check > 1) {
                        ret = Util::utf32ToUtf8(&outVec,
                                                utf32Seq);
                    }
                    else {
                        ret = Util::utf32ToUtf8(&outVec,
                                                utf32Seq,
                                                &numChars);
                    }
                    ASSERT(check > 1 || 4 == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                    ASSERT(compareVec == outVec);

                    bsl::string outStr;
                    numChars = -1;    ret = -1;

                    if (check > 1) {
                        ret = Util::utf32ToUtf8(&outStr,
                                                utf32Seq);
                    }
                    else {
                        ret = Util::utf32ToUtf8(&outStr,
                                                utf32Seq,
                                                &numChars);
                    }
                    ASSERT(check > 1 || 4 == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                    ASSERT(compareStr == outStr);
                }

                for (bsl::size_t len = compareVec.size() + 2;
                                              (bsl::size_t) -1 != len; --len) {
                    char outBuf[100];
                    bsl::memset(outBuf, -1, sizeof(outBuf));
                    numChars = -1;

                    expectedRet = IS_ERROR && len >= 2
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < compareVec.size()
                                               ? Status::BDEDE_OUT_OF_SPACE_BIT
                                               : 0;

                    const unsigned int cvs = compareVec.size();
                    const bsl::size_t expectedNumChars = len >= cvs   ? 4
                                                       : len == cvs-1 ? 3
                                                       : len >= 2     ? 2
                                                       :                len;
                    ASSERT(expectedNumChars <= 4);
                    const bsl::size_t expectedNumBytes =
                                       expectedNumChars <= 2 ? expectedNumChars
                                     : expectedNumChars == 3 ? cvs - 1
                                     :                         cvs;

                    bsl::size_t numBytes = -1;
                    if      (check > 1) {
                        ret = Util::utf32ToUtf8(outBuf,
                                               len,
                                               utf32Seq);
                    }
                    else if (check > 0) {
                        ret = Util::utf32ToUtf8(outBuf,
                                                len,
                                                utf32Seq,
                                                &numChars);
                    }
                    else {
                        ret = Util::utf32ToUtf8(outBuf,
                                                len,
                                                utf32Seq,
                                                &numChars,
                                                &numBytes);
                        LOOP4_ASSERT(LINE, len, expectedNumBytes, numBytes,
                                                 expectedNumBytes == numBytes);
                    }
                    ASSERT(check > 1 || expectedNumChars == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);

                    LOOP2_ASSERT(LINE, len,
                                       0 == bsl::memcmp(outBuf, &compareStr[0],
                                                        expectedNumBytes - 1));
                    LOOP2_ASSERT(LINE, len,
                                0 == len || 0 == outBuf[expectedNumBytes - 1]);
                }
            }
        }

        if (verbose) Q(Testing Sequence Without Leading Ascii Val);

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { UTF32_VAL, 'z', 0 };
            bsl::vector<char> compareVec, outVec;
            for (const char *pc = UTF8_STRING; *pc; ++pc) {
                compareVec.push_back(*pc);
            }
            compareVec.push_back('z');
            compareVec.push_back(0);
            const bsl::string compareStr = &compareVec[0];

            for (int check = 0; check < 2; ++check) {
                // check == 0, check 'numChars' && 'numBytes'
                // check == 1: check 'numChars'
                // check == 2: check neither

                int expectedRet = IS_ERROR
                                ? Status::BDEDE_INVALID_CHARS_BIT
                                : 0;

                bsl::size_t numChars = -1;
                int ret;

                if (check) {
                    if (check > 1) {
                        ret = Util::utf32ToUtf8(&outVec,
                                                utf32Seq);
                    }
                    else {
                        ret = Util::utf32ToUtf8(&outVec,
                                                utf32Seq,
                                                &numChars);
                    }
                    ASSERT(check > 1 || 3 == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                    ASSERT(compareVec == outVec);

                    bsl::string outStr;
                    numChars = -1;    ret = -1;

                    if (check > 1) {
                        ret = Util::utf32ToUtf8(&outStr,
                                                utf32Seq);
                    }
                    else {
                        ret = Util::utf32ToUtf8(&outStr,
                                                utf32Seq,
                                                &numChars);
                    }
                    ASSERT(check > 1 || 3 == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                    ASSERT(compareStr == outStr);
                }

                for (bsl::size_t len = compareVec.size() + 2;
                                              (bsl::size_t) -1 != len; --len) {
                    char outBuf[100];
                    bsl::memset(outBuf, -1, sizeof(outBuf));
                    numChars = -1;

                    expectedRet = IS_ERROR && len >= 1
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < compareVec.size()
                                               ? Status::BDEDE_OUT_OF_SPACE_BIT
                                               : 0;

                    const unsigned int cvs = compareVec.size();
                    const bsl::size_t expectedNumChars = len >= cvs   ? 3
                                                       : len == cvs-1 ? 2
                                                       : len >= 1     ? 1
                                                       :                0;
                    ASSERT(expectedNumChars <= 3);
                    const bsl::size_t expectedNumBytes =
                                       expectedNumChars <= 1 ? expectedNumChars
                                     : expectedNumChars == 2 ? cvs - 1
                                     :                         cvs;

                    bsl::size_t numBytes = -1;
                    if      (check > 1) {
                        ret = Util::utf32ToUtf8(outBuf,
                                               len,
                                               utf32Seq);
                    }
                    else if (check > 0) {
                        ret = Util::utf32ToUtf8(outBuf,
                                                len,
                                                utf32Seq,
                                                &numChars);
                    }
                    else {
                        ret = Util::utf32ToUtf8(outBuf,
                                                len,
                                                utf32Seq,
                                                &numChars,
                                                &numBytes);
                        LOOP4_ASSERT(LINE, len, expectedNumBytes, numBytes,
                                                 expectedNumBytes == numBytes);
                    }
                    ASSERT(check > 1 || expectedNumChars == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);

                    LOOP2_ASSERT(LINE, len,
                                       0 == bsl::memcmp(outBuf, &compareStr[0],
                                                        expectedNumBytes - 1));
                    LOOP2_ASSERT(LINE, len,
                                0 == len || 0 == outBuf[expectedNumBytes - 1]);
                }
            }
        }

        if (verbose) Q(Testing Sequence Without Trailing ASCII);

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { '1', UTF32_VAL, 0 };
            bsl::vector<char> compareVec, outVec;
            compareVec.push_back('1');
            for (const char *pc = UTF8_STRING; *pc; ++pc) {
                compareVec.push_back(*pc);
            }
            compareVec.push_back(0);
            const bsl::string compareStr = &compareVec[0];

            for (int check = 0; check < 2; ++check) {
                // check == 0, check 'numChars' && 'numBytes'
                // check == 1: check 'numChars'
                // check == 2: check neither

                int expectedRet = IS_ERROR
                                ? Status::BDEDE_INVALID_CHARS_BIT
                                : 0;

                bsl::size_t numChars = -1;
                int ret;

                if (check) {
                    if (check > 1) {
                        ret = Util::utf32ToUtf8(&outVec,
                                                utf32Seq);
                    }
                    else {
                        ret = Util::utf32ToUtf8(&outVec,
                                                utf32Seq,
                                                &numChars);
                    }
                    ASSERT(check > 1 || 3 == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                    ASSERT(compareVec == outVec);

                    bsl::string outStr;
                    numChars = -1;    ret = -1;

                    if (check > 1) {
                        ret = Util::utf32ToUtf8(&outStr,
                                                utf32Seq);
                    }
                    else {
                        ret = Util::utf32ToUtf8(&outStr,
                                                utf32Seq,
                                                &numChars);
                    }
                    ASSERT(check > 1 || 3 == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                    ASSERT(compareStr == outStr);
                }

                for (bsl::size_t len = compareVec.size() + 2;
                                              (bsl::size_t) -1 != len; --len) {
                    char outBuf[100];
                    bsl::memset(outBuf, -1, sizeof(outBuf));
                    numChars = -1;

                    expectedRet = IS_ERROR && len >= 2
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < compareVec.size()
                                               ? Status::BDEDE_OUT_OF_SPACE_BIT
                                               : 0;

                    const unsigned int cvs = compareVec.size();
                    const bsl::size_t expectedNumChars = len >= cvs ? 3
                                                       : len >= 2   ? 2
                                                       :              len;
                    ASSERT(expectedNumChars <= 4);
                    const bsl::size_t expectedNumBytes =
                                       expectedNumChars <= 2 ? expectedNumChars
                                     :                         cvs;

                    bsl::size_t numBytes = -1;
                    if      (check > 1) {
                        ret = Util::utf32ToUtf8(outBuf,
                                               len,
                                               utf32Seq);
                    }
                    else if (check > 0) {
                        ret = Util::utf32ToUtf8(outBuf,
                                                len,
                                                utf32Seq,
                                                &numChars);
                    }
                    else {
                        ret = Util::utf32ToUtf8(outBuf,
                                                len,
                                                utf32Seq,
                                                &numChars,
                                                &numBytes);
                        LOOP4_ASSERT(LINE, len, expectedNumBytes, numBytes,
                                                 expectedNumBytes == numBytes);
                    }
                    ASSERT(check > 1 || expectedNumChars == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);

                    LOOP2_ASSERT(LINE, len,
                                       0 == bsl::memcmp(outBuf, &compareStr[0],
                                                        expectedNumBytes - 1));
                    LOOP2_ASSERT(LINE, len,
                                0 == len || 0 == outBuf[expectedNumBytes - 1]);
                }
            }
        }

        if (verbose) Q(Testing Sequence Without Leading or Trailing Ascii Val);

        for (int ti = 0; ti < NUM_UTF32_TABLE; ++ti) {
            const int           LINE        = utf32Table[ti].d_line;
            const unsigned int  UTF32_VAL   = utf32Table[ti].d_utf32Val;
            const char         *UTF8_STRING = utf32Table[ti].d_utf8String;
            const bool          IS_ERROR    = utf32Table[ti].d_error;

            const unsigned int utf32Seq[] = { UTF32_VAL, 0 };
            bsl::vector<char> compareVec, outVec;
            for (const char *pc = UTF8_STRING; *pc; ++pc) {
                compareVec.push_back(*pc);
            }
            compareVec.push_back(0);
            const bsl::string compareStr = &compareVec[0];

            for (int check = 0; check < 2; ++check) {
                // check == 0, check 'numChars' && 'numBytes'
                // check == 1: check 'numChars'
                // check == 2: check neither

                int expectedRet = IS_ERROR
                                ? Status::BDEDE_INVALID_CHARS_BIT
                                : 0;

                bsl::size_t numChars = -1;
                int ret;

                if (check) {
                    if (check > 1) {
                        ret = Util::utf32ToUtf8(&outVec,
                                                utf32Seq);
                    }
                    else {
                        ret = Util::utf32ToUtf8(&outVec,
                                                utf32Seq,
                                                &numChars);
                    }
                    ASSERT(check > 1 || 2 == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                    ASSERT(compareVec == outVec);

                    bsl::string outStr;
                    numChars = -1;    ret = -1;

                    if (check > 1) {
                        ret = Util::utf32ToUtf8(&outStr,
                                                utf32Seq);
                    }
                    else {
                        ret = Util::utf32ToUtf8(&outStr,
                                                utf32Seq,
                                                &numChars);
                    }
                    ASSERT(check > 1 || 2 == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
                    ASSERT(compareStr == outStr);
                }

                for (bsl::size_t len = compareVec.size() + 2;
                                              (bsl::size_t) -1 != len; --len) {
                    char outBuf[100];
                    bsl::memset(outBuf, -1, sizeof(outBuf));
                    numChars = -1;

                    expectedRet = IS_ERROR && len >= 1
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < compareVec.size()
                                               ? Status::BDEDE_OUT_OF_SPACE_BIT
                                               : 0;

                    const unsigned int cvs = compareVec.size();
                    const bsl::size_t expectedNumChars = len >= cvs   ? 2
                                                       : len >= 1     ? 1
                                                       :                0;
                    ASSERT(expectedNumChars <= 3);
                    const bsl::size_t expectedNumBytes =
                                      expectedNumChars == 2 ? cvs
                                    :                         expectedNumChars;

                    if (veryVeryVerbose) {
                        P_(LINE);    P_(check);     P_(len);    P_(cvs);
                        P_(expectedNumChars);       P(expectedNumBytes);
                    }

                    bsl::size_t numBytes = -1;
                    if      (check > 1) {
                        ret = Util::utf32ToUtf8(outBuf,
                                               len,
                                               utf32Seq);
                    }
                    else if (check > 0) {
                        ret = Util::utf32ToUtf8(outBuf,
                                                len,
                                                utf32Seq,
                                                &numChars);
                    }
                    else {
                        ret = Util::utf32ToUtf8(outBuf,
                                                len,
                                                utf32Seq,
                                                &numChars,
                                                &numBytes);
                        LOOP4_ASSERT(LINE, len, expectedNumBytes, numBytes,
                                                 expectedNumBytes == numBytes);
                    }
                    ASSERT(check > 1 || expectedNumChars == numChars);

                    LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);

                    LOOP2_ASSERT(LINE, len,
                                       0 == bsl::memcmp(outBuf, &compareStr[0],
                                                        expectedNumBytes - 1));
                    LOOP2_ASSERT(LINE, len,
                                0 == len || 0 == outBuf[expectedNumBytes - 1]);
                }
            }
        }
      } break;
      case 6: {
        // --------------------------------------------------------------------
        // Testing UTF-8 -> UTF-32 OTHER VALUES OF ERRORCHAR
        //
        // Concerns:
        //   That values of 'errorChar' other than 'default' and 0 work
        //   correcttly.
        //
        // Plan:
        //   Repeat the first loop of the vector test in case 3 with multiple
        //   values of 'errorChar' other than 0 and verify that the specified
        //   char is properly substituted.  Only do those cases where
        //   'IS_ERROR' is true and 'IS_TRUNC' is 0.
        // --------------------------------------------------------------------

        if (verbose) cout <<
                         "Testing UTF-8 -> UTF-32 OTHER VALUES OF ERRORCHAR\n"
                         "=================================================\n";

        static unsigned int errorChars[] = { 1, 10, 20, 'a', 'A', 256, 500,
                          1000, 10 * 1000, 0xd7ff, 0xe000, 1 << 20, 0x10ffff };
        enum { NUM_ERROR_CHARS = sizeof errorChars / sizeof *errorChars };

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const char *UTF8_STRING = utf8Table[ti].d_utf8String;
            const bool  IS_ERROR    = utf8Table[ti].d_error;
            const int   TRUNC_BY    = utf8Table[ti].d_truncBy;

            if (!IS_ERROR || TRUNC_BY) {
                continue;
            }

            for (int te = 0; te < NUM_ERROR_CHARS; ++te) {
                const unsigned int ERROR_CHAR = errorChars[te];

                unsigned int expectedOut[] = { '1', ERROR_CHAR, 'z', 0 };
                int expectedRet = Status::BDEDE_INVALID_CHARS_BIT;
                const unsigned expectedChars = 4;

                bsl::vector<unsigned int> outVec;
                int ret = Util::utf8ToUtf32(&outVec,
                                            UTF8_STRING,
                                            ERROR_CHAR);
                ASSERT(expectedRet == ret);
                ASSERT(expectedChars == outVec.size());
                ASSERT(0 == outVec.back());

                const int expectedMatch = 4 * sizeof(unsigned int);

                ASSERT(0 == bsl::memcmp(outVec.begin(), expectedOut,
                                                               expectedMatch));

                LOOP3_ASSERT(ti, ERROR_CHAR, (void*) outVec[1],
                                                      ERROR_CHAR == outVec[1]);
            }
        }
      } break;
      case 5: {
        // --------------------------------------------------------------------
        // Testing UTF-8 -> UTF-32 Buffer Transl'n With 0 for errChr, to Vector
        //
        // Conerns:
        // That 'utf8ToUtf32' called with vector output performs as expeected:
        //: 1 Test sound encodings of minimal and maximal encoded values for
        //:   utf8 sequences 1, 2, 3, and 4 octets long.
        //: 2 Test non-minimal encodings -- values 1 too small, and zero
        //:   encodings
        //: 3 Test 5 octet encodings (always taken to be illegal)
        //: 4 Test truncated encodings.
        //: 5 Repeat test for the following configuations
        //:   o Preceded by, and followed by, valid ascii chars
        //:   o At beginnning of string
        //:   o At end of string
        //:   o Followed by a lone continuation char
        //
        // Plan:
        //   Repeat the plan for TC 4, except tailored to vector, rather than
        //   buffer, output.
        // --------------------------------------------------------------------

        if (verbose) cout <<
              "UTF-8 -> UTF-32 Buffer Transl'n With 0 for errChr, to Vector\n"
              "============================================================\n";

        if (verbose) Q(4-char sequences);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const int           LINE        = utf8Table[ti].d_line;
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;

            unsigned int expectedOut[] = { '1', MID_VAL, 'z', 0 };
            if (IS_ERROR) {
                bsl::memmove(&expectedOut[1], &expectedOut[2],
                                                     2 * sizeof(unsigned int));
            }

            const int expectedRet = IS_ERROR
                                         ? Status::BDEDE_INVALID_CHARS_BIT : 0;
            const unsigned expectedChars = 3 + !IS_ERROR;

            bsl::vector<unsigned int> outVec;
            int ret = Util::utf8ToUtf32(&outVec,
                                        UTF8_STRING,
                                        0);
            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            LOOP3_ASSERT(LINE, expectedChars, outVec.size(),
                                               expectedChars == outVec.size());
            LOOP2_ASSERT(LINE, expectedChars, 0 == outVec.back());
            int expectedMatch = 3 + !IS_ERROR;
            for (int i = 0; i < expectedMatch; ++i) {
                LOOP5_ASSERT(LINE, expectedChars, i, outVec[i],
                                  expectedOut[i], outVec[i] == expectedOut[i]);
            }
        }

        if (verbose) Q(Skipping first char);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const int           LINE        = utf8Table[ti].d_line;
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;
            ++UTF8_STRING;

            unsigned int expectedOut[] = { MID_VAL, 'z', 0 };
            if (IS_ERROR) {
                expectedOut[0] = 'z';
                expectedOut[1] = 0;
            }

            int expectedRet = IS_ERROR ? Status::BDEDE_INVALID_CHARS_BIT : 0;
            const unsigned expectedChars = IS_ERROR ? 2 : 3;

            bsl::vector<unsigned int> outVec;
            int ret = Util::utf8ToUtf32(&outVec,
                                        UTF8_STRING,
                                        0);
            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(expectedChars == outVec.size());
            ASSERT(0 == outVec.back());

            const int expectedMatch = (3 == expectedChars ? 3 :
                  bsl::max(0, (int) expectedChars - 1)) * sizeof(unsigned int);

            ASSERT(0 == bsl::memcmp(&outVec[0], expectedOut, expectedMatch));
        }

        if (verbose) Q(Eliminating last char);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;
            bsl::string s = UTF8_STRING;
            ASSERT(s.length() > 0);
            s.resize(s.length() - 1);

            unsigned int expectedOut[] = { '1', MID_VAL, 0 };
            int expectedRet = IS_ERROR ? Status::BDEDE_INVALID_CHARS_BIT : 0;
            const unsigned expectedChars = IS_ERROR ? 2 : 3;

            bsl::vector<unsigned int> outVec;
            int ret = Util::utf8ToUtf32(&outVec,
                                        s.c_str(),
                                        0);
            ASSERT(expectedRet == ret);
            ASSERT(expectedChars == outVec.size());
            ASSERT(0 == outVec.back());

            const int expectedMatch = (3 == expectedChars ? 3 :
                  bsl::max(0, (int) expectedChars - 1)) * sizeof(unsigned int);

            ASSERT(0 == bsl::memcmp(&outVec[0], expectedOut, expectedMatch));
        }

        if (verbose) Q(Replacing 'z' with continuation);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const int           LINE        = utf8Table[ti].d_line;
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;
            const int           TRUNC_BY    = utf8Table[ti].d_truncBy;

            bsl::string s = UTF8_STRING;
            ASSERT(s.length() > 0);
            ASSERT('z' == s.back());
            s.back() = (char) 0x83;

            unsigned int expectedOut[] = { '1', MID_VAL, 0 };
            if (IS_ERROR) {
                expectedOut[1] = 0;
            }
            const bool fiveOctet = (UTF8_STRING[1] & 0xf8) == 0xf8;
            int expectedRet;
            unsigned expectedChars;
            int expectedMatch;

            switch (TRUNC_BY) {
              case 0: {
                expectedRet = Status::BDEDE_INVALID_CHARS_BIT;
                expectedChars = IS_ERROR ? 2 : 3;
                expectedMatch = expectedChars;
              } break;
              case 1: {
                expectedRet = fiveOctet ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedChars = fiveOctet ? 2 : 3;
                expectedMatch = 1;
              } break;
              default: {    // 2 or more
                expectedRet = Status::BDEDE_INVALID_CHARS_BIT;
                expectedChars = 2;
                expectedMatch = expectedChars;
              }
            }
            expectedMatch *= sizeof(unsigned int);

            bsl::vector<unsigned int> outVec;
            int ret = Util::utf8ToUtf32(&outVec,
                                        s.c_str(),
                                        0);
            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            LOOP3_ASSERT(LINE, expectedChars, outVec.size(),
                                               expectedChars == outVec.size());
            ASSERT(0 == outVec.back());

            LOOP2_ASSERT(LINE, expectedMatch,
                     0 == bsl::memcmp(&outVec[0], expectedOut, expectedMatch));
        }
      } break;
      case 4: {
        // --------------------------------------------------------------------
        // Testing UTF-8 -> UTF-32 Buffer Translation With 0 for errorChar
        //
        // Conerns:
        // That 'utf8ToUtf32' called with buffer output performs as expeected:
        //: 1 Test sound encodings of minimal and maximal encoded values for
        //:   utf8 sequences 1, 2, 3, and 4 octets long.
        //: 2 Test non-minimal encodings -- values 1 too small, and zero
        //:   encodings
        //: 3 Test 5 octet encodings (always taken to be illegal)
        //: 4 Test truncated encodings.
        //: 5 Repeat test for the following configuations
        //:   o Preceded by, and followed by, valid ascii chars
        //:   o At beginnning of string
        //:   o At end of string
        //:   o Followed by a lone continuation char
        //
        // Plan:
        // Set up one loop for each of the case listed under '5' in the
        // concerns.  The loops will call 'utf8ToUtf32', setting up variables
        // first to anticipate what the expected behavior of this translation
        // call.
        //: 1 Iterate through all the entries in the static array 'utf8Table'
        //:   above, to determine the input string to pass to the translation
        //:   call.
        //: 2 Iterate the value 'len', the capacity in words of the output
        //:   buffer, from 'more than enough room' down to zero, and pass 'len'
        //:   to the 'capacity' arg of 'utf8ToUtf32' on each call.
        //: 3 Calculate 'expectedRet', the expected return value for
        //:   'utf8ToUtf32' and, after the call, verify it is indeed the
        //:   return value.
        //: 4 Create an unsigned int array 'expectedOut' of the expected output
        //:   sequence, and calculate 'expectedMatch', the number of bytes of
        //:   it that are expected to match the translation output, and compare
        //:   to the output after the translation call.
        //: 5 Calculate 'expectedChars', the expected number of chars output
        //:   (including the terminating 0), and verify it is the value of
        //:   'numChars' returned by the translation call.
        //: 6 Calculate 'expectedMatch', the number of bytes of the output
        //:   which are expecte to match 'expectedOut' from '5', note that
        //:   'expectedMatch' will vary with 'len'.  After the translation,
        //:   verify that the first 'expectedMatch' bytes of output match
        //:   expectedOut.
        // --------------------------------------------------------------------

        if (verbose) cout <<
                 "Testing UTF-8 -> UTF-32 Buffer Translation (0 for errChr)\n"
                 "=========================================================\n";

        if (verbose) Q(4-char sequences);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const int           LINE        = utf8Table[ti].d_line;
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;

            const int MAX_LEN = 5;
            unsigned int out32Buf[MAX_LEN];
            unsigned int expectedOut[] = { '1', MID_VAL, 'z', 0 };
            if (IS_ERROR) {
                bsl::memmove(&expectedOut[1], &expectedOut[2],
                                                     2 * sizeof(unsigned int));
            }
            for (int len = MAX_LEN; len >= 0; --len) {
                bsl::memset(out32Buf, -1, sizeof(out32Buf));
                int expectedRet = IS_ERROR && len >= 2
                                  ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedRet |= len < (IS_ERROR ? 3 : 4)
                               ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                const unsigned expectedChars = bsl::min(len, 3+!IS_ERROR);

                bsl::size_t numChars = -1;
                int ret = Util::utf8ToUtf32(out32Buf,
                                            len,
                                            UTF8_STRING,
                                            &numChars,
                                            0);
                LOOP4_ASSERT(LINE, len, expectedRet, ret, expectedRet == ret);
                LOOP3_ASSERT(LINE, expectedChars, numChars,
                                                    expectedChars == numChars);
                LOOP3_ASSERT(LINE, len, expectedChars,
                                 0 == len || 0 == out32Buf[expectedChars - 1]);
                int expectedMatch = 3 + !IS_ERROR;
                expectedMatch = len >= expectedMatch ? expectedMatch
                                                     : bsl::max(0, len - 1);
                for (int i = 0; i < expectedMatch; ++i) {
                    LOOP6_ASSERT(LINE, len, expectedChars, i, out32Buf[i],
                                expectedOut[i], out32Buf[i] == expectedOut[i]);
                }
            }
        }

        if (verbose) Q(Skipping first char);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const int           LINE        = utf8Table[ti].d_line;
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;
            ++UTF8_STRING;

            const int MAX_LEN = 6;
            unsigned int out32Buf[MAX_LEN];
            unsigned int expectedOut[] = { MID_VAL, 'z', 0 };
            if (IS_ERROR) {
                expectedOut[0] = 'z';
                expectedOut[1] = 0;
            }

            for (int len = MAX_LEN; len >= 0; --len) {
                bsl::memset(out32Buf, -1, sizeof(out32Buf));
                int expectedRet = IS_ERROR && len >= 1
                                  ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedRet |= len < (IS_ERROR ? 2 : 3)
                               ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                const unsigned expectedChars = bsl::min(len, IS_ERROR ? 2 : 3);

                bsl::size_t numChars = -1;
                int ret = Util::utf8ToUtf32(out32Buf,
                                            len,
                                            UTF8_STRING,
                                            &numChars,
                                            0);
                LOOP4_ASSERT(LINE, len, expectedRet, ret, expectedRet == ret);
                ASSERT(expectedChars == numChars);
                ASSERT(0 == len || 0 == out32Buf[expectedChars - 1]);

                const int expectedMatch = (3 == expectedChars ? 3 :
                  bsl::max(0, (int) expectedChars - 1)) * sizeof(unsigned int);

                ASSERT(0 == bsl::memcmp(out32Buf, expectedOut, expectedMatch));
            }
        }

        if (verbose) Q(Eliminating last char);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const int           LINE        = utf8Table[ti].d_line;
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;
            bsl::string s = UTF8_STRING;
            ASSERT(s.length() > 0);
            s.resize(s.length() - 1);

            const int MAX_LEN = 5;
            unsigned int out32Buf[MAX_LEN];
            unsigned int expectedOut[] = { '1', MID_VAL, 0 };
            for (int len = MAX_LEN; len >= 0; --len) {
                bsl::memset(out32Buf, -1, sizeof(out32Buf));
                int expectedRet = IS_ERROR && len >= 2
                                  ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedRet |= len < (IS_ERROR ? 2 : 3)
                               ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                const unsigned expectedChars =
                                           bsl::min(len, IS_ERROR ? 2 : 3);

                bsl::size_t numChars = -1;
                int ret = Util::utf8ToUtf32(out32Buf,
                                            len,
                                            s.c_str(),
                                            &numChars,
                                            0);
                LOOP4_ASSERT(LINE, len, expectedRet, ret, expectedRet == ret);
                ASSERT(expectedChars == numChars);
                ASSERT(0 == len || 0 == out32Buf[expectedChars - 1]);

                const int expectedMatch = (3 == expectedChars ? 3 :
                  bsl::max(0, (int) expectedChars - 1)) * sizeof(unsigned int);

                ASSERT(0 == bsl::memcmp(out32Buf, expectedOut, expectedMatch));
            }
        }

        if (verbose) Q(Replacing 'z' with continuation);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const int           LINE        = utf8Table[ti].d_line;
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;
            const int           TRUNC_BY    = utf8Table[ti].d_truncBy;

            bsl::string s = UTF8_STRING;
            ASSERT(s.length() > 0);
            ASSERT('z' == s.back());
            s.back() = (char) 0x83;

            const int MAX_LEN = 6;
            unsigned int out32Buf[MAX_LEN];
            unsigned int expectedOut[] = { '1', MID_VAL, 0 };
            if (IS_ERROR) {
                expectedOut[1] = 0;
            }
            const bool fiveOctet = (UTF8_STRING[1] & 0xf8) == 0xf8;
            for (int len = MAX_LEN; len >= 0; --len) {
                bsl::memset(out32Buf, -1, sizeof(out32Buf));
                int expectedRet;
                unsigned expectedChars;

                switch (TRUNC_BY) {
                  case 0: {
                    expectedRet = (IS_ERROR && len >= 2) || len >= 3
                                  ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < (IS_ERROR ? 2 : 3)
                                  ? Status::BDEDE_OUT_OF_SPACE_BIT  : 0;
                    expectedChars = bsl::min(len, IS_ERROR ? 2 : 3);
                  } break;
                  case 1: {
                    expectedRet =
                                len < (0xf8 == (0xf8 & UTF8_STRING[1]) ? 2 : 3)
                                          ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                    expectedRet |= len >= 2 && fiveOctet ?
                                           Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedChars = bsl::min(len, fiveOctet ? 2 : 3);
                  } break;
                  default: {    // 2 or more
                    expectedRet = len >= 2 ?
                                           Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < (IS_ERROR ? 2 : 3)
                                          ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                    expectedChars = bsl::min(len, 2);
                  }
                }

                int expectedMatch = bsl::max(0,
                       (!TRUNC_BY ? ((int) expectedChars -
                       !!(expectedRet & Status::BDEDE_OUT_OF_SPACE_BIT)) :
                    bsl::min(len - 1, 1))) * sizeof(unsigned int);

                bsl::size_t numChars = -1;
                int ret = Util::utf8ToUtf32(out32Buf,
                                            len,
                                            s.c_str(),
                                            &numChars,
                                            0);
                LOOP4_ASSERT(LINE, len, expectedRet, ret, expectedRet == ret);
                LOOP4_ASSERT(LINE, len, expectedChars, numChars,
                                                    expectedChars == numChars);
                ASSERT(0 == numChars || 0 == out32Buf[numChars - 1]);

                LOOP3_ASSERT(LINE, expectedMatch, len,
                            0 == bsl::memcmp(out32Buf, expectedOut,
                                                               expectedMatch));
            }
        }
      } break;
      case 3: {
        // --------------------------------------------------------------------
        // Testing UTF-8 -> UTF-32 Vector Translation
        //
        // Conerns:
        //: 1 That vector translation will size the vector appropriately
        //:   and produce the correct output.
        //
        // Plan:
        //: 1 Repeat the code for TC 2, expect this time make the output be
        //:   vector.
        //: 2 Note that much of the testing here involves safe asserts built
        //:   into the translation routine, since we're testing the exact
        //:   accuracy of the length-prediction function, which we can't test
        //:   directly since it is not public.
        // --------------------------------------------------------------------

        if (verbose) cout << "Testing UTF-8 -> UTF-32 Vector Translation\n"
                             "==================================\n";

        if (verbose) Q(4-char sequences);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;

            unsigned int expectedOut[] = { '1', MID_VAL, 'z', 0 };
            int expectedRet = IS_ERROR ? Status::BDEDE_INVALID_CHARS_BIT : 0;
            const unsigned expectedChars = 4;

            bsl::vector<unsigned int> outVec;
            int ret = Util::utf8ToUtf32(&outVec,
                                        UTF8_STRING);
            ASSERT(expectedRet == ret);
            ASSERT(expectedChars == outVec.size());
            ASSERT(0 == outVec.back());

            const int expectedMatch = 4 * sizeof(unsigned int);

            ASSERT(0 == bsl::memcmp(outVec.begin(), expectedOut,
                                                               expectedMatch));

            LOOP3_ASSERT(ti, MID_VAL, (void*) outVec[1],
                                                     MID_VAL == outVec[1]);
        }

        if (verbose) Q(Skipping first char);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;
            ++UTF8_STRING;

            unsigned int expectedOut[] = { MID_VAL, 'z', 0 };
            bsl::vector<unsigned int> outVec;
            int expectedRet = IS_ERROR
                              ? Status::BDEDE_INVALID_CHARS_BIT : 0;
            const unsigned expectedChars = 3;

            int ret = Util::utf8ToUtf32(&outVec,
                                        UTF8_STRING);
            ASSERT(expectedRet == ret);
            ASSERT(expectedChars == outVec.size());
            ASSERT(0 == outVec.back());

            const int expectedMatch = 3 * sizeof(unsigned int);

            ASSERT(0 == bsl::memcmp(outVec.begin(),
                                    expectedOut,
                                    expectedMatch));

            LOOP3_ASSERT(ti, MID_VAL, hx(outVec[0]), MID_VAL == outVec[0]);
        }

        if (verbose) Q(Eliminating last char);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const bool          IS_ERROR    = utf8Table[ti].d_error;
            bsl::string s = UTF8_STRING;
            ASSERT(s.length() > 0);
            s.resize(s.length() - 1);

            unsigned int expectedOut[] = { '1', MID_VAL, 0 };
            bsl::vector<unsigned int> outVec;
            int expectedRet = IS_ERROR
                              ? Status::BDEDE_INVALID_CHARS_BIT : 0;
            const unsigned expectedChars = 3;

            int ret = Util::utf8ToUtf32(&outVec,
                                        s.c_str());
            ASSERT(expectedRet == ret);
            ASSERT(expectedChars == outVec.size());
            ASSERT(0 == outVec.back());

            const int expectedMatch = 3 * sizeof(unsigned int);

            ASSERT(0 == bsl::memcmp(outVec.begin(),
                                    expectedOut,
                                    expectedMatch));

            LOOP3_ASSERT(ti, MID_VAL, (void*) outVec[1], MID_VAL == outVec[1]);
        }

        if (verbose) Q(Replacing 'z' with continuation);

        for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
            const int           LINE        = utf8Table[ti].d_line;
            const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
            const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
            const int           TRUNC_BY    = utf8Table[ti].d_truncBy;

            bsl::string s = UTF8_STRING;
            ASSERT(s.length() > 0);
            ASSERT('z' == s.back());
            s.back() = (char) 0x83;

            unsigned int expectedOut[] = { '1', MID_VAL, '?', 0 };
            bsl::vector<unsigned int> outVec;
            int expectedRet;
            unsigned expectedChars;
            int expectedMatch;

            switch (TRUNC_BY) {
              case 0: {
                expectedRet = Status::BDEDE_INVALID_CHARS_BIT;
                expectedChars = 4;
                expectedMatch = 4 * sizeof(unsigned int);
              } break;
              case 1: {
                expectedRet = (UTF8_STRING[1] & 0xf8) == 0xf8 ?
                                           Status::BDEDE_INVALID_CHARS_BIT : 0;
                expectedChars = 3;
                expectedMatch = sizeof(unsigned int);
              } break;
              default: {    // 2 or more
                expectedRet = Status::BDEDE_INVALID_CHARS_BIT;
                expectedChars = 3;
                expectedMatch = 3 * sizeof(unsigned int);
                expectedOut[2] = 0;
              }
            }

            int ret = Util::utf8ToUtf32(&outVec,
                                        s.c_str());
            LOOP3_ASSERT(LINE, expectedRet, ret, expectedRet == ret);
            ASSERT(expectedChars == outVec.size());
            ASSERT(0 == outVec.back());

            LOOP2_ASSERT(LINE, expectedMatch,
                            0 == bsl::memcmp(outVec.begin(), expectedOut,
                                                               expectedMatch));

            if (1 != TRUNC_BY) {
                LOOP3_ASSERT(LINE, MID_VAL, (void*) outVec[1],
                                                         MID_VAL == outVec[1]);
            }
        }
      } break;
      case 2: {
        // --------------------------------------------------------------------
        // Testing UTF-8 -> UTF-32 Buffer Translation
        //
        // Conerns:
        // That 'utf8ToUtf32' called with buffer output performs as expeected:
        //: 1 Test sound encodings of minimal and maximal encoded values for
        //:   utf8 sequences 1, 2, 3, and 4 octets long.
        //: 2 Test non-minimal encodings -- values 1 too small, and zero
        //:   encodings
        //: 3 Test 5 octet encodings (always taken to be illegal)
        //: 4 Test truncated encodings.
        //: 5 Repeat test for the following configuations
        //:   o Preceded by, and followed by, valid ascii chars
        //:   o At beginnning of string
        //:   o At end of string
        //:   o Followed by a lone continuation char
        //
        // Plan:
        // Set up one loop for each of the case listed under '5' in the
        // concerns.  The loops will call 'utf8ToUtf32', setting up variables
        // first to anticipate what the expected behavior of this translation
        // call.
        //: 1 Iterate twice over the variable 'checkNumChars', which is really
        //:   a boolean that describes whether we will pass an argument
        //:   '&numChars' to 'utf8ToUtf32' and check its return value for
        //:   correctness.
        //: 2 Within the loop of '1', iterate through all the entries in
        //:   the static array 'utf8Table' above, to determine the input
        //:   string to pass to the translation call.
        //: 3 Iterate the value 'len', the capacity in words of the output
        //:   buffer, from 'more than enough room' down to zero, and pass 'len'
        //:   to the 'capacity' arg of 'utf8ToUtf32' on each call.
        //: 4 Calculate 'expectedRet', the expected return value for
        //:   'utf8ToUtf32' and, after the call, verify it is indeed the
        //:   return value.
        //: 5 Create an unsigned int array 'expectedOut' of the expected output
        //:   sequence, and calculate 'expectedMatch', the number of bytes of
        //:   it that are expected to match the translation output, and compare
        //:   to the output after the translation call.
        //: 6 Calculate 'expectedChars', the expected number of chars output
        //:   (including the terminating 0), and verify it is the value of
        //:   'numChars' returned by the translation call (if' checkNumChars'
        //:   is true, meaning 'numChars' is passed to the translation call).
        //: 7 Calculate 'expectedMatch', the number of bytes of the output
        //:   which are expecte to match 'expectedOut' from '5', note that
        //:   'expectedMatch' will vary with 'len'.  After the translation,
        //:   verify that the first 'expectedMatch' bytes of output match
        //:   expectedOut.
        // --------------------------------------------------------------------

        if (verbose) cout << "Testing UTF-8 -> UTF-32 Buffer Translation\n"
                             "==========================================\n";

        if (verbose) Q(4-char sequences);

        for (int checkNumChars = 0; checkNumChars < 2; ++checkNumChars) {
            for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
                const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
                const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
                const bool          IS_ERROR    = utf8Table[ti].d_error;

                const int MAX_LEN = 6;
                unsigned int out32Buf[MAX_LEN];
                unsigned int expectedOut[] = { '1', MID_VAL, 'z', 0 };
                for (int len = MAX_LEN; len >= 0; --len) {
                    bsl::memset(out32Buf, -1, sizeof(out32Buf));
                    int expectedRet = IS_ERROR && len > 1
                                      ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < 4
                                   ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                    const unsigned expectedChars = bsl::min(len, 4);

                    bsl::size_t numChars = -1;
                    int ret = checkNumChars
                            ? Util::utf8ToUtf32(out32Buf,
                                                len,
                                                UTF8_STRING,
                                                &numChars)
                            : Util::utf8ToUtf32(out32Buf,
                                                len,
                                                UTF8_STRING);
                    LOOP4_ASSERT(ti, len, expectedRet, ret,
                                                           expectedRet == ret);
                    ASSERT(!checkNumChars || expectedChars == numChars);
                    ASSERT(0 == len || 0 == out32Buf[expectedChars - 1]);

                    const int expectedMatch =
                                          (len >= 4 ? 4 : bsl::max(len - 1, 0))
                                                        * sizeof(unsigned int);

                    ASSERT(0 == bsl::memcmp(out32Buf, expectedOut,
                                                               expectedMatch));

                    if (len >= 3) {
                        LOOP3_ASSERT(ti, MID_VAL, (void*) out32Buf[1],
                                                       MID_VAL == out32Buf[1]);
                    }
                }
            }
        }

        if (verbose) Q(Skipping first char);

        for (int checkNumChars = 0; checkNumChars < 2; ++checkNumChars) {
            for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
                const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
                const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
                const bool          IS_ERROR    = utf8Table[ti].d_error;
                ++UTF8_STRING;

                const int MAX_LEN = 6;
                unsigned int out32Buf[MAX_LEN];
                unsigned int expectedOut[] = { MID_VAL, 'z', 0 };
                for (int len = MAX_LEN; len >= 0; --len) {
                    bsl::memset(out32Buf, -1, sizeof(out32Buf));
                    int expectedRet = IS_ERROR && len > 0
                                      ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < 3
                                   ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                    const unsigned expectedChars = bsl::min(len, 3);

                    bsl::size_t numChars = -1;
                    int ret = checkNumChars
                            ? Util::utf8ToUtf32(out32Buf,
                                                len,
                                                UTF8_STRING,
                                                &numChars)
                            : Util::utf8ToUtf32(out32Buf,
                                                len,
                                                UTF8_STRING);
                    ASSERT(expectedRet == ret);
                    ASSERT(!checkNumChars || expectedChars == numChars);
                    ASSERT(0 == len || 0 == out32Buf[expectedChars - 1]);

                    const int expectedMatch =
                                          (len >= 3 ? 3 : bsl::max(len - 1, 0))
                                                        * sizeof(unsigned int);

                    ASSERT(0 == bsl::memcmp(out32Buf, expectedOut,
                                                               expectedMatch));

                    if (len >= 2) {
                        LOOP3_ASSERT(ti, MID_VAL, (void*) out32Buf[0],
                                                       MID_VAL == out32Buf[0]);
                    }
                }
            }
        }

        if (verbose) Q(Eliminating last char);

        for (int checkNumChars = 0; checkNumChars < 2; ++checkNumChars) {
            for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
                const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
                const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
                const bool          IS_ERROR    = utf8Table[ti].d_error;
                bsl::string s = UTF8_STRING;
                ASSERT(s.length() > 0);
                s.resize(s.length() - 1);

                const int MAX_LEN = 5;
                unsigned int out32Buf[MAX_LEN];
                unsigned int expectedOut[] = { '1', MID_VAL, 0 };
                for (int len = MAX_LEN; len >= 0; --len) {
                    bsl::memset(out32Buf, -1, sizeof(out32Buf));
                    int expectedRet = IS_ERROR && len >= 2
                                      ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                    expectedRet |= len < 3
                                   ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                    const unsigned expectedChars = bsl::min(len, 3);

                    bsl::size_t numChars = -1;
                    int ret = checkNumChars
                            ? Util::utf8ToUtf32(out32Buf,
                                                len,
                                                s.c_str(),
                                                &numChars)
                            : Util::utf8ToUtf32(out32Buf,
                                                len,
                                                s.c_str());
                    ASSERT(expectedRet == ret);
                    ASSERT(!checkNumChars || expectedChars == numChars);
                    ASSERT(0 == len || 0 == out32Buf[expectedChars - 1]);

                    const int expectedMatch =
                                          (len >= 3 ? 3 : bsl::max(len - 1, 0))
                                                        * sizeof(unsigned int);

                    ASSERT(0 == bsl::memcmp(out32Buf, expectedOut,
                                                               expectedMatch));

                    if (len >= 3) {
                        LOOP3_ASSERT(ti, MID_VAL, (void*) out32Buf[1],
                                                       MID_VAL == out32Buf[1]);
                    }
                }
            }
        }

        if (verbose) Q(Replacing 'z' with continuation);

        for (int checkNumChars = 0; checkNumChars < 2; ++checkNumChars) {
            for (int ti = 0; ti < NUM_UTF8_TABLE; ++ti) {
                const int           LINE        = utf8Table[ti].d_line;
                const char         *UTF8_STRING = utf8Table[ti].d_utf8String;
                const unsigned int  MID_VAL     = utf8Table[ti].d_midVal;
                const bool          IS_ERROR    = utf8Table[ti].d_error;
                const int           TRUNC_BY    = utf8Table[ti].d_truncBy;

                bsl::string s = UTF8_STRING;
                ASSERT(s.length() > 0);
                ASSERT('z' == s.back());
                s.back() = (char) 0x83;

                const int MAX_LEN = 6;
                unsigned int out32Buf[MAX_LEN];
                unsigned int expectedOut[] = { '1', MID_VAL, '?', 0 };
                for (int len = MAX_LEN; len >= 0; --len) {
                    bsl::memset(out32Buf, -1, sizeof(out32Buf));
                    int expectedRet;
                    unsigned expectedChars;
                    int expectedMatch;

                    switch (TRUNC_BY) {
                      case 0: {
                        expectedRet = (IS_ERROR && len >= 2) || len >= 3
                                      ? Status::BDEDE_INVALID_CHARS_BIT : 0;
                        expectedRet |= len < 4
                                      ? Status::BDEDE_OUT_OF_SPACE_BIT  : 0;
                        expectedChars = bsl::min(len, 4);
                        expectedMatch =(len >= 4 ? 4 : bsl::max(len - 1, 0))
                                                        * sizeof(unsigned int);
                      } break;
                      case 1: {
                        expectedRet = len < 3
                                      ? Status::BDEDE_OUT_OF_SPACE_BIT  : 0;
                        expectedRet |= len >= 2 &&
                                              (UTF8_STRING[1] & 0xf8) == 0xf8 ?
                                           Status::BDEDE_INVALID_CHARS_BIT : 0;
                        expectedChars = bsl::min(len, 3);
                        expectedMatch = bsl::max(0, bsl::min(len - 1, 1)) *
                                                          sizeof(unsigned int);
                      } break;
                      default: {    // 2 or more
                        expectedRet = len >= 2 ?
                                           Status::BDEDE_INVALID_CHARS_BIT : 0;
                        expectedRet |= len < 3
                                       ? Status::BDEDE_OUT_OF_SPACE_BIT : 0;
                        expectedChars = bsl::min(len, 3);
                        expectedMatch = (len >= 3 ? 3 : bsl::max(len - 1, 0))
                                                        * sizeof(unsigned int);
                        expectedOut[2] = 0;
                      }
                    }

                    bsl::size_t numChars = -1;
                    int ret = checkNumChars
                            ? Util::utf8ToUtf32(out32Buf,
                                                len,
                                                s.c_str(),
                                                &numChars)
                            : Util::utf8ToUtf32(out32Buf,
                                                len,
                                                s.c_str());
                    LOOP4_ASSERT(LINE, len, expectedRet, ret,
                                                           expectedRet == ret);
                    ASSERT(!checkNumChars || expectedChars == numChars);
                    ASSERT(0 == len || 0 == out32Buf[expectedChars - 1]);

                    LOOP3_ASSERT(LINE, expectedMatch, len,
                                0 == bsl::memcmp(out32Buf, expectedOut,
                                                               expectedMatch));

                    if (len >= 3 && TRUNC_BY != 1) {
                        LOOP3_ASSERT(LINE, MID_VAL, (void*) out32Buf[1],
                                                       MID_VAL == out32Buf[1]);
                    }
                }
            }
        }
      } break;
      case 1: {
        // --------------------------------------------------------------------
        // BREATING TEST
        //
        // Plan:
        //   Translate a sequence, with no errors, from utf8 to utf32 and
        //   back.
        // --------------------------------------------------------------------

        const char *utf8 = "H" "e" "l" "l" "o" "\n"   // ASCII
                           "\xcb\xb1" "\n"            // 2-char utf8 753
                           "\xe2\x9c\x90" "\n"        // 3-char utf8 10000
                           "\xf0\x98\x9a\xa0" "\n";   // 4-char utf8 100000

        unsigned int utf32[100];
        std::size_t numChars, numBytes;

        int sts = Util::utf8ToUtf32(utf32,
                                    100,
                                    utf8,
                                    &numChars);
        ASSERT(0 == sts);
        ASSERT(13 == numChars);
        ASSERT(0 == utf32[numChars - 1]);

        const unsigned *putf32 = utf32;

        ASSERT(*putf32++ == 'H');
        ASSERT(*putf32++ == 'e');
        ASSERT(*putf32++ == 'l');
        ASSERT(*putf32++ == 'l');
        ASSERT(*putf32++ == 'o');
        ASSERT(*putf32++ == '\n');
        ASSERT(*putf32++ == 753);
        ASSERT(*putf32++ == '\n');
        ASSERT(*putf32++ == 10000);
        ASSERT(*putf32++ == '\n');
        ASSERT(*putf32++ == 100000);
        ASSERT(*putf32++ == '\n');
        ASSERT(*putf32++ == 0);

        char utf8Out[100];

        numChars = numBytes = -1;
        sts = Util::utf32ToUtf8(utf8Out,
                                100,
                                utf32,
                                &numChars,
                                &numBytes);
        ASSERT(0  == sts);
        ASSERT(13 == numChars);
        ASSERT( bsl::strlen(utf8) + 1 == numBytes);
        ASSERT(!bsl::strcmp(utf8, utf8Out));
      } break;
      case -1: {
        namespace TC = CASE_MINUS_1_NAMESPACE;

        const unsigned chars[] = { 'H', 'e', 'l', 'l', 'o', '\n',
                                   753, 10000, 100000, 0xd7ff, 0xe000,
                                   0xd800, 0xd8ff, 0xdc00, 0xdcff, 0xdd99, 0 };
        for (const unsigned *pu = chars; *pu; ++pu) {
            cout << bsl::hex << *pu << bsl::dec << ": ";
            TC::outputSequence(cout, *pu) << '\n';
        }
      } break;
      default: {
        cerr << "WARNING: CASE `" << test << "' NOT FOUND." << endl;
        testStatus = -1;
      }
    }

    return testStatus;
}

// -------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2013
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE -------------------------------
