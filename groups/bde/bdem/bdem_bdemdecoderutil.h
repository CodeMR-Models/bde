// bdem_bdemdecoderutil.h                  -*-C++-*-
#ifndef INCLUDED_BDEM_BDEMDECODERUTIL
#define INCLUDED_BDEM_BDEMDECODERUTIL

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide a 'bdem'-compatible decoder utility.
//
//@CLASSES:
//    bdem_BdemDecoderUtil: 'bdem'-compatible decoder utility
//
//@SEE_ALSO: bdem_bdemencoderutil, bdem_berdecoderutil
//
//@AUTHOR: Rohan Bhindwale (rbhindwa), Shezan Baig (sbaig)
//
//@DESCRIPTION: The 'bdem_BdemDecoderUtil' 'struct' provided in this component
// contains a parameterized 'decode' function that decodes a specified
// value-semantic object from a specified stream.  There are six overloaded
// versions of this function:
//..
//    o reads from a 'bdex' stream and uses default options
//    o reads from a 'bdex' stream and uses user-supplied options
//    o reads from an 'bsl::streambuf' and uses default options
//    o reads from an 'bsl::streambuf' and uses user-supplied options
//    o reads from an 'bsl::ostream' and uses default options
//    o reads from an 'bsl::ostream' and uses user-supplied options
//..
//
// These functions decode objects in the 'bdem' wire format.  The 'options'
// argument allows client to switch between version 1 and version 2 of the
// 'bdem' wire format.  By default, version 2 is used.  The typical use case
// for this component is to stream a 'bdem_List' on the sender's side, and
// decode the stream into an object on the receiver's side.
//
// These functions can be used with types supported by the 'bdeat' framework.
// In particular, types generated by the 'bas_codegen.pl' tool can be used.
//
///'bdem' Encoding Rules
///---------------------
// The following 'bdem' encoding rules are used by this component:
//..
//    o fundamental C++ types are casted to 'bdem' types using the mapping
//      defined in 'bdem_selectbdemtype'.
//    o an object that falls under 'bdeat_TypeCategory::Sequence' is encoded as
//      a LIST containing the attributes of the sequence.
//    o an object that falls under 'bdeat_TypeCategory::Choice' is encoded as a
//      LIST.  If the choice object has no selection, then the list will
//      contain exactly one sub-item, which must be an empty string.  If the
//      choice object has a selection, then the list will contain exactly two
//      sub-items - the first sub-item will be a string indicating the name of
//      the selection; the second sub-item will be the value of the selection.
//    o a 'bdet_DateTz' object is encoded as a LIST containing exactly two
//      sub-items - the first sub-item will be a DATE containing the value of
//      the local date; the second sub-item will be an INT containing the
//      timezone offset in minutes.
//    o a 'bdet_DatetimeTz' object is encoded as a LIST containing exactly two
//      sub-items - the first sub-item will be a DATETIME containing the value
//      of the local datetime; the second sub-item will be an INT containing
//      the timezone offset in minutes.
//    o a 'bdet_TimeTz' object is encoded as a LIST containing exactly two
//      sub-items - the first sub-item will be a TIME containing the value of
//      the local time; the second sub-item will be an INT containing the
//      timezone offset in minutes.
//..
//
///Usage
///-----
// The following snippets of code illustrate the usage of this component.
// Suppose we have an XML schema inside a file called 'employee.xsd':
//..
//  <?xml version='1.0' encoding='UTF-8'?>
//  <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
//             xmlns:test='http://bloomberg.com/schemas/test'
//             targetNamespace='http://bloomberg.com/schemas/test'
//             elementFormDefault='unqualified'>
//
//      <xs:complexType name='Address'>
//          <xs:sequence>
//              <xs:element name='street' type='xs:string'/>
//              <xs:element name='city'   type='xs:string'/>
//              <xs:element name='state'  type='xs:string'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:complexType name='Employee'>
//          <xs:sequence>
//              <xs:element name='name'        type='xs:string'/>
//              <xs:element name='homeAddress' type='test:Address'/>
//              <xs:element name='age'         type='xs:int'/>
//              <xs:element name='dateJoined'  type='date'/>
//          </xs:sequence>
//      </xs:complexType>
//
//  </xs:schema>
//..
// Using the 'bas_codegen.pl' tool, we can generate C++ classes for this
// schema:
//..
//  $ bas_codegen.pl -g h -g cpp -p test employee.xsd
//..
// This tool will generate the header and implementation files for the
// 'test_address' and 'test_employee' components in the current directory.
//
// Now suppose we want to create a 'bdem_List' object that contains data
// corresponding to this schema:
//..
//  #include <bdex_byteoutstream.h>
//  #include <bdesb_fixedmeminstreambuf.h>
//  #include <bdem_list.h>
//
//  #include <test_employee.h>
//
//  #include <bdem_bdemdecoderutil.h>
//
//  using namespace BloombergLP;
//
//  void usageExample()
//  {
//      bdem_List list;
//
//      list.appendString("Bob");                     // name
//      list.appendUnsetList();                       // homeAddress
//      // homeAddress.street
//      list.theModifiableList(1).appendString("Some Street");
//      // homeAddress.city
//      list.theModifiableList(1).appendString("Some City");
//      // homeAddress.state
//      list.theModifiableList(1).appendString("Some State");
//      list.appendInt(21);                           // age
//      list.appendUnsetList();                       // dateJoined
//      // dateJoined.localDate
//      list.theModifiableList(3).appendDate(bdet_Date(2003, 3, 20));
//      list.theModifiableList(3).appendInt(-300);    // dateJoined.offset
//..
// Now we will stream out this list in 'bdem' wire format (version 2).  Note
// that we will use 'bdex_ByteOutStream' for in-core buffer management:
//..
//      bdex_ByteOutStream os;
//
//      const int BDEM_VERSION = 2;
//
//      list.bdexStreamOut(os, BDEM_VERSION);
//
//      assert(os);
//..
// At this point, 'os' contains a representation of 'list' in 'bdem' wire
// format (version 2).  Now we will verify the contents of 'os' by decoding the
// stream into a 'test::Employee' object:
//..
//      bdesb_FixedMemInStreamBuf isb(os.data(), os.length());       // NO COPY
//      test::Employee            bob;
//
//      int retCode = bdem_BdemDecoderUtil::decode(&isb, &bob);
//
//      assert(0                            == retCode);
//      assert(list.theString(0)            == bob.name());
//      assert(list.theList(1).theString(0) == bob.homeAddress().street());
//      assert(list.theList(1).theString(1) == bob.homeAddress().city());
//      assert(list.theList(1).theString(2) == bob.homeAddress().state());
//      assert(list.theInt(2)               == bob.age());
//      assert(list.theList(3).theDate(0)   == bob.dateJoined().localDate());
//      assert(list.theList(3).theInt(1)    == bob.dateJoined().offset());
//  }
//..

#ifndef INCLUDED_BDESCM_VERSION
#include <bdescm_version.h>
#endif

#ifndef INCLUDED_BDEM_BDEMDECODEROPTIONS
#include <bdem_bdemdecoderoptions.h>
#endif

#ifndef INCLUDED_BDEM_ELEMTYPE
#include <bdem_elemtype.h>
#endif

#ifndef INCLUDED_BDEM_SELECTBDEMTYPE
#include <bdem_selectbdemtype.h>
#endif

#ifndef INCLUDED_BDEAT_ARRAYFUNCTIONS
#include <bdeat_arrayfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CHOICEFUNCTIONS
#include <bdeat_choicefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CUSTOMIZEDTYPEFUNCTIONS
#include <bdeat_customizedtypefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_ENUMFUNCTIONS
#include <bdeat_enumfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_NULLABLEVALUEFUNCTIONS
#include <bdeat_nullablevaluefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_SEQUENCEFUNCTIONS
#include <bdeat_sequencefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_TYPECATEGORY
#include <bdeat_typecategory.h>
#endif

#ifndef INCLUDED_BDEAT_VALUETYPEFUNCTIONS
#include <bdeat_valuetypefunctions.h>
#endif

#ifndef INCLUDED_BDEF_BIND
#include <bdef_bind.h>
#endif

#ifndef INCLUDED_BDEF_FUNCTION
#include <bdef_function.h>
#endif

#ifndef INCLUDED_BDEF_MEMFN
#include <bdef_memfn.h>
#endif

#ifndef INCLUDED_BDEF_PLACEHOLDER
#include <bdef_placeholder.h>
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include <bslmf_assert.h>
#endif

#ifndef INCLUDED_BSLMF_ISSAME
#include <bslmf_issame.h>
#endif

#ifndef INCLUDED_BSLMF_SWITCH
#include <bslmf_switch.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

#ifndef INCLUDED_BDETU_UNSET
#include <bdetu_unset.h>
#endif

#ifndef BDEX_BYTEINSTREAMFORMATTER
#include <bdex_byteinstreamformatter.h>
#endif

#ifndef INCLUDED_BDEX_INSTREAMFUNCTIONS
#include <bdex_instreamfunctions.h>
#endif

#ifndef INCLUDED_CSTRING
#include <cstring>
#define INCLUDED_CSTRING
#endif

#ifndef INCLUDED_BSL_ISTREAM
#include <bsl_istream.h>
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include <bsl_streambuf.h>
#endif

#ifndef INCLUDED_BSL_STRING
#include <bsl_string.h>
#endif

#ifndef INCLUDED_BSL_VECTOR
#include <bsl_vector.h>
#endif

#ifndef BDE_DONT_ALLOW_TRANSITIVE_INCLUDES

#ifndef INCLUDED_BDEMF_ASSERT
#include <bdemf_assert.h>
#endif

#ifndef INCLUDED_BDEMF_ISSAME
#include <bdemf_issame.h>
#endif

#ifndef INCLUDED_BDEMF_SWITCH
#include <bdemf_switch.h>
#endif

#ifndef INCLUDED_BDES_ASSERT
#include <bdes_assert.h>
#endif

#ifndef INCLUDED_ISTREAM
#include <istream>
#define INCLUDED_ISTREAM
#endif

#ifndef INCLUDED_STREAMBUF
#include <streambuf>
#define INCLUDED_STREAMBUF
#endif

#ifndef INCLUDED_STRING
#include <string>
#define INCLUDED_STRING
#endif

#ifndef INCLUDED_VECTOR
#include <vector>
#define INCLUDED_VECTOR
#endif

#endif

namespace BloombergLP {

                        // ===========================
                        // struct bdem_BdemDecoderUtil
                        // ===========================

struct bdem_BdemDecoderUtil {
    // This 'struct' contains the parameterized 'decode' functions that decode
    // data (in a 'bdem' wire format) from an incoming stream into 'bdeat'
    // types.

    // MANIPULATORS
    template <typename STREAM, typename TYPE>
    static STREAM& decode(STREAM& stream, TYPE *variable);
    template <typename STREAM, typename TYPE>
    static STREAM& decode(STREAM&                         stream,
                          TYPE                           *variable,
                          const bdem_BdemDecoderOptions&  options);
        // Decode an object of parameterized 'TYPE' from the specified
        // parameterized 'bdex' 'stream' using the optionally specified
        // 'options' and load the result into the specified modifiable
        // 'variable'.  Return a reference to 'stream'.  Note that 'stream'
        // will be invalidated if the decoding fails.

    template <typename TYPE>
    static int decode(bsl::streambuf *buffer, TYPE *variable);
    template <typename TYPE>
    static int decode(bsl::streambuf                 *buffer,
                      TYPE                           *variable,
                      const bdem_BdemDecoderOptions&  options);
        // Decode an object of parameterized 'TYPE' from the specified 'buffer'
        // using the optionally specified 'options' and load the result into
        // the specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.

    template <typename TYPE>
    static bsl::istream& decode(bsl::istream& stream, TYPE *variable);
    template <typename TYPE>
    static bsl::istream& decode(bsl::istream&                   stream,
                                TYPE                           *variable,
                                const bdem_BdemDecoderOptions&  options);
        // Decode an object of parameterized 'TYPE' from the specified 'stream'
        // using the optionally specified 'options' and load the result into
        // the specified modifiable 'variable'.  Return a reference to
        // 'stream'.  Note that 'stream' will be invalidated if the decoding
        // fails.

};

// ---  Anything below this line is implementation specific.  Do not use.  ----

struct bdem_BdemDecoderUtil_NativeBdemArrayCategory;
struct bdem_BdemDecoderUtil_ExtendedBdemArrayCategory;
struct bdem_BdemDecoderUtil_SequenceArrayCategory;
struct bdem_BdemDecoderUtil_ChoiceArrayCategory;
struct bdem_BdemDecoderUtil_OtherArrayCategory;

template <typename STREAM>
class bdem_BdemDecoderUtil_Decoder;

             // =================================================
             // private class bdem_BdemDecoderUtil_BuildElemTypes
             // =================================================

class bdem_BdemDecoderUtil_BuildElemTypes {
    // This class is used to build a vector of 'bdem' element types.  Note that
    // vector<char> is used instead of vector<bdem_ElemType::Type> because the
    // 'bdem' wire format uses vector<char> and the streaming can be optimized.

    // PRIVATE DATA MEMBERS
    bsl::vector<char> d_elemTypes;  // array of 'bdem' element types

    // NOT IMPLEMENTED
    bdem_BdemDecoderUtil_BuildElemTypes(
                                   const bdem_BdemDecoderUtil_BuildElemTypes&);
    bdem_BdemDecoderUtil_BuildElemTypes& operator=(
                                   const bdem_BdemDecoderUtil_BuildElemTypes&);

  public:
    // CREATORS
    bdem_BdemDecoderUtil_BuildElemTypes(int numElements);
        // Create a 'bdem' element type builder with sufficient initial
        // capacity to accommodate up to the specified 'numElements' element
        // types without subsequent reallocation *by* *this* *builder*.

    // Generated by compiler:
    // ~bdem_BdemDecoderUtil_BuildElemTypes();

    // MANIPULATORS
    template <typename TYPE, typename INFO>
    int operator()(const TYPE& value, const INFO&);
        // Append the 'bdem' element type corresponding to the specified non-
        // modifiable 'value' of parameterized 'TYPE' to the array of element
        // types built by this object and return 0.

    // ACCESSORS
    const bsl::vector<char>& elemTypes() const;
        // Return a reference to the array of non-modifiable 'bdem' element
        // types build by this object.
};

               // =============================================
               // private struct bdem_BdemDecoderUtil_Constants
               // =============================================

struct bdem_BdemDecoderUtil_Constants {
    // This 'struct' contains constants that are used throughout this
    // component.

    enum {
        FIRST_BIT_MASK      = 0x80000000U,  // mask for first bit in a 32 bit
                                            // unsigned integer
        FIRST_TWO_BITS_MASK = 0xC0000000U   // mask for first two bits in a 32
                                            // bit unsigned integer
    };
};

        // ===========================================================
        // private class bdem_BdemDecoderUtil_DecodeAttributesWithMask
        // ===========================================================

template <typename STREAM>
class bdem_BdemDecoderUtil_DecodeAttributesWithMask {
    // This class is used to decode a sequence of attributes, preceding every
    // 32 attributes with a 32-bit bitmap.  If a bit is reset, that means that
    // the corresponding attribute is null and is compressed out of the stream
    // (see 'bdem' wire format, version 2, for more details).

    // PRIVATE DATA MEMBERS
    int                                   d_attributeIndex;
    unsigned int                          d_bitmap;
    bdem_BdemDecoderUtil_Decoder<STREAM> *d_decoder_p;
    STREAM                               *d_stream_p;

  private:
    // NOT IMPLEMENTED
    bdem_BdemDecoderUtil_DecodeAttributesWithMask(
                         const bdem_BdemDecoderUtil_DecodeAttributesWithMask&);
    bdem_BdemDecoderUtil_DecodeAttributesWithMask& operator=(
                         const bdem_BdemDecoderUtil_DecodeAttributesWithMask&);

  public:
    // CREATORS
    bdem_BdemDecoderUtil_DecodeAttributesWithMask(
                                STREAM                               *stream,
                                bdem_BdemDecoderUtil_Decoder<STREAM> *decoder);

    // Generated by compiler:
    // ~bdem_BdemDecoderUtil_DecodeAttributesWithMask();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(TYPE *object,
                   const INFO_TYPE&);

    template <typename TYPE>
    int execute(TYPE *object);
};

                 // ==========================================
                 // private class bdem_BdemDecoderUtil_Decoder
                 // ==========================================

template <typename STREAM>
class bdem_BdemDecoderUtil_Decoder {
    // This class contains the logic for decoding each of the supported types.
    // It is parameterized with the 'bdex' stream type.

    int     d_bdemVersion;  // 'bdem' version to be used for decoding
    int     d_level;        // bitmap for 'bdem' streaming version 2 put out
                            // only at top-level
    int     d_maxDepth;     // maximum depth that we can recurse before failing
    STREAM *d_stream_p;     // stream from which 'bdem'-compliant message is
                            // decoded (held, not owned)

  private:
    struct NativeBdemTypeCategory   { };
    struct ExtendedBdemTypeCategory { };
    struct NotBdemTypeCategory      { };

    // PRIVATE MANIPULATORS
    template <typename DEST_TYPE, typename BDEM_TYPE>
    int convertFromBdemType(DEST_TYPE *variable, const BDEM_TYPE& value);
        // Convert (using a static cast) the specified 'value' to the specified
        // 'variable'.  Note that this function always returns 0.

    template <typename TYPE>
    int decodeImp(TYPE *variable, bdeat_TypeCategory::Array);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Array'.

    template <typename TYPE>
    int decodeImp(TYPE *variable, bdeat_TypeCategory::Choice);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Choice'.

    template <typename TYPE>
    int decodeImp(TYPE *variable, bdeat_TypeCategory::CustomizedType);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::CustomizedType'.

    template <typename TYPE>
    int decodeImp(TYPE *variable, bdeat_TypeCategory::Enumeration);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Enumeration'.

    template <typename TYPE>
    int decodeImp(TYPE *variable, bdeat_TypeCategory::NullableValue);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::NullableValue'.

    template <typename TYPE>
    int decodeImp(TYPE *variable, bdeat_TypeCategory::Sequence);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Sequence'.

    template <typename TYPE>
    int decodeImp(TYPE *variable, bdeat_TypeCategory::Simple);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Simple'.

    template <typename TYPE>
    int decodeArrayChoiceImp(TYPE *variable, int numRows);

    template <typename TYPE>
    int decodeArrayImp(TYPE *variable,
                       bdem_BdemDecoderUtil_NativeBdemArrayCategory);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must be a native
        // 'bdem' array.

    template <typename TYPE>
    int decodeArrayImp(TYPE *variable,
                       bdem_BdemDecoderUtil_ChoiceArrayCategory);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Array' and must contain elements that fall
        // under 'bdeat_TypeCategory::Choice'.

    template <typename TYPE>
    int decodeArrayImp(TYPE *variable,
                       bdem_BdemDecoderUtil_ExtendedBdemArrayCategory);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Array' and must contain extended types
        // ('bdet_DateTz', 'bdet_DatetimeTz', and 'bdet_TimeTz').

    template <typename TYPE>
    int decodeArrayImp(TYPE *variable,
                       bdem_BdemDecoderUtil_SequenceArrayCategory);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Array' and must contain elements that fall
        // under 'bdeat_TypeCategory::Sequence'.

    template <typename TYPE>
    int decodeArrayImp(TYPE *variable,
                       bdem_BdemDecoderUtil_OtherArrayCategory);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Array' but not fall under any of the other
        // overloads of 'decodeArrayImp'.

    template <typename TYPE>
    int decodeChoiceImp(TYPE               *variable,
                        char                selectionType,
                        const bsl::string&  selectionName);

    int decodeExtendedTypeValue(bdet_DateTz *variable);
    int decodeExtendedTypeValue(bdet_DatetimeTz *variable);
    int decodeExtendedTypeValue(bdet_TimeTz *variable);

    template <typename TYPE>
    int decodeNullableArrayImp(TYPE *variable,
                               bdeat_TypeCategory::Choice);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' contains elements
        // that fall under 'bdeat_TypeCategory::Choice'.

    template <typename TYPE, typename ANY_CATEGORY>
    int decodeNullableArrayImp(TYPE *variable, ANY_CATEGORY);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.  Note that the second argument is used for
        // overloading purposes and indicates that 'TYPE' does not fall under
        // any of the other overloads of 'decodeNullableArrayImp'.

    template <typename TYPE>
    int decodeNullableImp(TYPE *variable,
                          bdeat_TypeCategory::Array);
    template <typename TYPE>
    int decodeNullableImp(TYPE *variable,
                          bdeat_TypeCategory::Choice);
    template <typename TYPE>
    int decodeNullableImp(TYPE *variable,
                          bdeat_TypeCategory::Enumeration);
    template <typename TYPE>
    int decodeNullableImp(TYPE *variable,
                          bdeat_TypeCategory::Sequence);
    template <typename TYPE>
    int decodeNullableImp(TYPE *variable,
                          bdeat_TypeCategory::Simple);

    template <typename TYPE>
    int decodeNullableSimpleImp(TYPE *variable,
                                NativeBdemTypeCategory);

    template <typename TYPE>
    int decodeNullableSimpleImp(TYPE *variable,
                                ExtendedBdemTypeCategory);

    template <typename TYPE>
    int decodeNullableSimpleImp(TYPE *variable,
                                NotBdemTypeCategory);

    template <typename TYPE>
    int decodeSequenceImp(TYPE                     *variable,
                          const bsl::vector<char>&  attributeElemTypes);

    template <typename TYPE>
    int decodeSimpleImp(TYPE *variable,
                        NativeBdemTypeCategory);

    template <typename TYPE>
    int decodeSimpleImp(TYPE *variable,
                        NotBdemTypeCategory);

  private:
    // NOT IMPLEMENTED
    bdem_BdemDecoderUtil_Decoder(const bdem_BdemDecoderUtil_Decoder&);
    bdem_BdemDecoderUtil_Decoder& operator=(
                                          const bdem_BdemDecoderUtil_Decoder&);

  public:
    // CREATORS
    bdem_BdemDecoderUtil_Decoder(STREAM *stream,
                                 int     bdemVersion,
                                 int     maxDepth);
        // Create a 'bdem'-compatible decoder using the specified 'stream', the
        // specified 'bdemVersion', and the specified 'maxDepth'.

    // Generated by compiler:
    // ~bdem_BdemDecoderUtil_Decoder();

    // MANIPULATORS
    template <typename TYPE, typename INFO>
    int operator()(TYPE *variable, const INFO&);
        // Decode an object of parameterized 'TYPE' from the stream held by
        // this decoder into the specified modifiable 'variable'.  Return 0 on
        // success, and a non-zero value otherwise.

    template <typename TYPE>
    int operator()(TYPE *variable);
        // Decode an object of parameterized 'TYPE' from the stream held by
        // this decoder into the specified modifiable 'variable'.  Return 0 on
        // success, and a non-zero value otherwise.

    template <typename TYPE>
    int decode(TYPE *variable);
        // Decode an object of parameterized 'TYPE' from the stream held by
        // this decoder into the specified modifiable 'variable'.  Return 0 on
        // success, and a non-zero value otherwise.

    int decode(bdet_DateTz *variable);
    int decode(bdet_DatetimeTz *variable);
    int decode(bdet_TimeTz *variable);
        // Decode an object from the stream held by this decoder into the
        // specified modifiable 'variable'.  Return 0 on success, and a
        // non-zero value otherwise.
};

          // ========================================================
          // private struct bdem_BdemDecoderUtil_ExtendedBdemTypeUtil
          // ========================================================

struct bdem_BdemDecoderUtil_ExtendedBdemTypeUtil {
    // This 'struct' contains utility functions for extended types (i.e.,
    // 'bdet_DateTz', 'bdet_DatetimeTz', and 'bdet_TimeTz').

    static bool areElemTypesValid(bdet_DateTz              *ignored,
                                  const bsl::vector<char>&  elemTypes);
    static bool areElemTypesValid(bdet_DatetimeTz          *ignored,
                                  const bsl::vector<char>&  elemTypes);
    static bool areElemTypesValid(bdet_TimeTz              *ignored,
                                  const bsl::vector<char>&  elemTypes);
};

                 // =========================================
                 // private class bdem_BdemDecoderUtil_IsNull
                 // =========================================

class bdem_BdemDecoderUtil_IsNull {
    // This class checks whether the visited value is equal to its
    // corresponding 'bdetu_unset' value.  Note that the 'operator()' function
    // will not compile if 'TYPE' does not have a corresponding 'bdetu_unset'
    // value.

    bool d_result;

  private:
    // NOT IMPLEMENTED
    bdem_BdemDecoderUtil_IsNull(const bdem_BdemDecoderUtil_IsNull&);
    bdem_BdemDecoderUtil_IsNull& operator=(const bdem_BdemDecoderUtil_IsNull&);

  public:
    // CREATORS
    bdem_BdemDecoderUtil_IsNull();

    // Generated by compiler:
    // ~bdem_BdemDecoderUtil_IsNull();

    // MANIPULATORS
    template <typename TYPE, typename INFO>
    int operator()(const TYPE& value, const INFO&);

    template <typename TYPE>
    int operator()(const TYPE& value);

    // ACCESSORS
    bool result() const;
};

              // ================================================
              // private class bdem_BdemDecoderUtil_NewLevelGuard
              // ================================================

class bdem_BdemDecoderUtil_NewLevelGuard {
    // This guard is used to maintain a counter that indicates the current
    // nested level in the decoder.  When constructed, the level number is
    // incremented.  When destructed, the level number is decremented.

    // PRIVATE DATA MEMBERS
    int *d_level_p;  // pointer to current level (held, not owned)

  private:
    // NOT IMPLEMENTED
    bdem_BdemDecoderUtil_NewLevelGuard(
                                    const bdem_BdemDecoderUtil_NewLevelGuard&);
    bdem_BdemDecoderUtil_NewLevelGuard& operator=(
                                    const bdem_BdemDecoderUtil_NewLevelGuard&);

  public:
    // CREATORS
    bdem_BdemDecoderUtil_NewLevelGuard(int *level);

    ~bdem_BdemDecoderUtil_NewLevelGuard();
};

         // ==========================================================
         // private class bdem_BdemDecoderUtil_SelectArrayTypeCategory
         // ==========================================================

struct bdem_BdemDecoderUtil_NativeBdemArrayCategory   { };
struct bdem_BdemDecoderUtil_ExtendedBdemArrayCategory { };
struct bdem_BdemDecoderUtil_SequenceArrayCategory     { };
struct bdem_BdemDecoderUtil_ChoiceArrayCategory       { };
struct bdem_BdemDecoderUtil_OtherArrayCategory        { };

template <typename TYPE>
struct bdem_BdemDecoderUtil_SelectArrayTypeCategory {
    // This meta-function is used to obtain the array type category for the
    // parameterized 'TYPE'.

  private:
    typedef typename
    bdem_SelectBdemType<TYPE>::Type BdemArrayType;

    typedef typename
    bdeat_ArrayFunctions::ElementType<TYPE>::Type ElementType;

    enum {
        IS_ELEMENT_NULLABLE
            = bdeat_NullableValueFunctions::IsNullableValue<ElementType>::VALUE
    };

    BSLMF_ASSERT(!IS_ELEMENT_NULLABLE);

    enum {
        IS_NATIVE_BDEM_ARRAY_TYPE = bslmf_IsSame<TYPE, BdemArrayType>::VALUE
    };

    enum {
        IS_EXTENDED_BDEM_ARRAY_TYPE
                          = bslmf_IsSame<ElementType, bdet_DateTz>::VALUE     |
                            bslmf_IsSame<ElementType, bdet_DatetimeTz>::VALUE |
                            bslmf_IsSame<ElementType, bdet_TimeTz>::VALUE
    };

    enum {
        IS_ELEMENT_SEQUENCE
                      = bdeat_SequenceFunctions::IsSequence<ElementType>::VALUE
    };

    enum {
        IS_ELEMENT_CHOICE = bdeat_ChoiceFunctions::IsChoice<ElementType>::VALUE
    };

    enum {
        SELECTOR = IS_NATIVE_BDEM_ARRAY_TYPE   ? 0 :
                   IS_EXTENDED_BDEM_ARRAY_TYPE ? 1 :
                   IS_ELEMENT_SEQUENCE         ? 2 :
                   IS_ELEMENT_CHOICE           ? 3 : 4
    };

  public:
    typedef typename
    bslmf_Switch<SELECTOR, bdem_BdemDecoderUtil_NativeBdemArrayCategory,
                           bdem_BdemDecoderUtil_ExtendedBdemArrayCategory,
                           bdem_BdemDecoderUtil_SequenceArrayCategory,
                           bdem_BdemDecoderUtil_ChoiceArrayCategory,
                           bdem_BdemDecoderUtil_OtherArrayCategory>::Type Type;
};

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

                        // ---------------------------
                        // struct bdem_BdemDecoderUtil
                        // ---------------------------

// MANIPULATORS
template <typename STREAM, typename TYPE>
inline
STREAM& bdem_BdemDecoderUtil::decode(STREAM& stream, TYPE *variable)
{
    return decode(stream, variable, bdem_BdemDecoderOptions());
}

template <typename STREAM, typename TYPE>
STREAM& bdem_BdemDecoderUtil::decode(STREAM&                         stream,
                                     TYPE                           *variable,
                                     const bdem_BdemDecoderOptions&  options)
{
    if (!stream) {
        return stream;
    }

    BSLS_ASSERT_SAFE(0 < options.maxDepth());

    int bdemVersion = options.bdemVersion();

    if (1 != bdemVersion && 2 != bdemVersion) {
        stream.invalidate();

        return stream;
    }

    bdem_BdemDecoderUtil_Decoder<STREAM> decoder(&stream,
                                                 bdemVersion,
                                                 options.maxDepth());

    bdeat_ValueTypeFunctions::reset(variable);

    if (0 != decoder.decode(variable)) {
        stream.invalidate();
    }

    return stream;
}

template <typename TYPE>
inline
int bdem_BdemDecoderUtil::decode(bsl::streambuf *buffer, TYPE *variable)
{
    return decode(buffer, variable, bdem_BdemDecoderOptions());
}

template <typename TYPE>
inline
int bdem_BdemDecoderUtil::decode(bsl::streambuf                 *buffer,
                                 TYPE                           *variable,
                                 const bdem_BdemDecoderOptions&  options)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    bdex_ByteInStreamFormatter formatter(buffer);

    decode(formatter, variable, options);

    return formatter ? SUCCESS : FAILURE;
}

template <typename TYPE>
inline
bsl::istream& bdem_BdemDecoderUtil::decode(bsl::istream&  stream,
                                           TYPE          *variable)
{
    return decode(stream, variable, bdem_BdemDecoderOptions());
}

template <typename TYPE>
inline
bsl::istream& bdem_BdemDecoderUtil::decode(
                                      bsl::istream&                   stream,
                                      TYPE                           *variable,
                                      const bdem_BdemDecoderOptions&  options)
{
    if (!stream.good()) {
        return stream;
    }

    if (0 != decode(stream.rdbuf(), variable, options)) {
        stream.setstate(bsl::ios_base::failbit);
    }

    return stream;
}

             // -------------------------------------------------
             // private class bdem_BdemDecoderUtil_BuildElemTypes
             // -------------------------------------------------

// CREATORS
inline
bdem_BdemDecoderUtil_BuildElemTypes::
bdem_BdemDecoderUtil_BuildElemTypes(int numElements)
{
    d_elemTypes.reserve(numElements);
}

// MANIPULATORS
template <typename TYPE, typename INFO>
inline
int bdem_BdemDecoderUtil_BuildElemTypes::operator()(const TYPE&, const INFO&)
{
    enum { SUCCESS = 0 };

    d_elemTypes.push_back(bdem_SelectBdemType<TYPE>::VALUE);

    return SUCCESS;
}

// ACCESSORS
inline
const bsl::vector<char>&
bdem_BdemDecoderUtil_BuildElemTypes::elemTypes() const
{
    return d_elemTypes;
}

        // -----------------------------------------------------------
        // private class bdem_BdemDecoderUtil_DecodeAttributesWithMask
        // -----------------------------------------------------------

// CREATORS
template <typename STREAM>
inline
bdem_BdemDecoderUtil_DecodeAttributesWithMask<STREAM>::
                                 bdem_BdemDecoderUtil_DecodeAttributesWithMask(
                                 STREAM                               *stream,
                                 bdem_BdemDecoderUtil_Decoder<STREAM> *decoder)
: d_attributeIndex(0)
, d_bitmap(0)
, d_decoder_p(decoder)
, d_stream_p(stream)
{
}

// MANIPULATORS
template <typename STREAM>
template <typename TYPE, typename INFO_TYPE>
inline
int bdem_BdemDecoderUtil_DecodeAttributesWithMask<STREAM>::operator()(
                                                              TYPE *object,
                                                              const INFO_TYPE&)
{
    return execute(object);
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_DecodeAttributesWithMask<STREAM>::execute(
                                                                  TYPE *object)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    enum { BITMAP_FREQUENCY = 32 };

    int bit = d_attributeIndex % BITMAP_FREQUENCY;

    if (0 == bit) {
        if (!d_stream_p->getUint32(d_bitmap)) {
            return FAILURE;
        }
    }

    ++d_attributeIndex;

    typedef unsigned int bde_uint;

    unsigned int mask
             = bde_uint(bdem_BdemDecoderUtil_Constants::FIRST_BIT_MASK) >> bit;

    if (0 == (d_bitmap & mask)) {
        // Attribute was compressed out of the stream.

        return SUCCESS;
    }

    return d_decoder_p->decode(object);
}

                 // ------------------------------------------
                 // private class bdem_BdemDecoderUtil_Decoder
                 // ------------------------------------------

// PRIVATE MANIPULATORS
template <typename STREAM>
template <typename DEST_TYPE, typename BDEM_TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::convertFromBdemType(
                                                    DEST_TYPE        *variable,
                                                    const BDEM_TYPE&  value)
{
    enum { SUCCESS = 0 };

    *variable = static_cast<DEST_TYPE>(value);

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeImp(TYPE *variable,
                                                    bdeat_TypeCategory::Array)
{
    typedef typename
    bdem_BdemDecoderUtil_SelectArrayTypeCategory<TYPE>::Type ArrayTypeCategory;

    return decodeArrayImp(variable, ArrayTypeCategory());
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeImp(TYPE *variable,
                                                    bdeat_TypeCategory::Choice)
{
    enum { FAILURE = -1, SELECTION_NOT_PRESENT = -1 };

    BSLS_ASSERT_SAFE(variable);

    int length;

    if (d_level == d_maxDepth
     || !d_stream_p->getLength(length)) {
        return FAILURE;                                               // RETURN
    }

    bdem_BdemDecoderUtil_NewLevelGuard newLevelGuard(&d_level);

    char        selectionType = SELECTION_NOT_PRESENT;
    bsl::string selectionName;

    switch (length) {
      case 1: {
        // There must be 1 string element, otherwise fail.  Also, if the length
        // is 1, then selectionType will always be 'SELECTION_NOT_PRESENT'.

        enum {
            EXPECTED_BITMAP = bdem_BdemDecoderUtil_Constants::FIRST_BIT_MASK
        };

        char         firstElemType;
        unsigned int bitmap;

        if (!d_stream_p->getInt8(firstElemType)
         || bdem_ElemType::BDEM_STRING != firstElemType
         || ( 2 == d_bdemVersion
           && 1 == d_level
           && (!d_stream_p->getUint32(bitmap) || bitmap != EXPECTED_BITMAP))
         || !d_stream_p->getString(selectionName)) {
            return FAILURE;
        }
      } break;
      case 2: {
        // The first element must be a valid string, otherwise fail.  We must
        // also fail if selectionType is 'SELECTION_NOT_PRESENT'.

        enum {
            EXPECTED_BITMAP
                          = bdem_BdemDecoderUtil_Constants::FIRST_TWO_BITS_MASK
        };

        char         firstElemType;
        unsigned int bitmap;

        if (!d_stream_p->getInt8(firstElemType)
         || bdem_ElemType::BDEM_STRING != firstElemType
         || !d_stream_p->getInt8(selectionType)
         || SELECTION_NOT_PRESENT == selectionType
         || ( 2 == d_bdemVersion
           && 1 == d_level
           && (!d_stream_p->getUint32(bitmap) || bitmap != EXPECTED_BITMAP))
         || !d_stream_p->getString(selectionName)
         || selectionName.empty()) {
            return FAILURE;
        }
      } break;
      default: {
        return FAILURE;
      } break;
    };

    return decodeChoiceImp(variable, selectionType, selectionName);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeImp(
                                            TYPE *variable,
                                            bdeat_TypeCategory::CustomizedType)
{
    enum { FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    typedef typename
    bdeat_CustomizedTypeFunctions::BaseType<TYPE>::Type BaseType;

    BaseType base;

    if (0 != decode(&base)) {
        return FAILURE;
    }

    return bdeat_CustomizedTypeFunctions::convertFromBaseType(variable, base);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeImp(
                                               TYPE *variable,
                                               bdeat_TypeCategory::Enumeration)
{
    enum { FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    // Enumerations are always streamed as 'int's.

    int intValue;

    if (0 != decode(&intValue)) {
        return FAILURE;
    }

    return bdeat_EnumFunctions::fromInt(variable, intValue);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeImp(
                                             TYPE *variable,
                                             bdeat_TypeCategory::NullableValue)
{
    BSLS_ASSERT_SAFE(variable);

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;

    typedef typename
    bdeat_TypeCategory::Select<ValueType>::Type TypeCategory;

    return decodeNullableImp(variable, TypeCategory());
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeImp(
                                                  TYPE *variable,
                                                  bdeat_TypeCategory::Sequence)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    // Stream in the types of attributes in the sequence.

    bsl::vector<char> types;

    if (0 != decode(&types)) {
        return FAILURE;
    }

    return decodeSequenceImp(variable, types);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeImp(TYPE *variable,
                                                    bdeat_TypeCategory::Simple)
{
    BSLS_ASSERT_SAFE(variable);

    typedef typename
    bdem_SelectBdemType<TYPE>::Type BdemType;

    typedef typename
    bslmf_If<bslmf_IsSame<TYPE, BdemType>::VALUE,
             NativeBdemTypeCategory,
             NotBdemTypeCategory>::Type Toggle;

    return decodeSimpleImp(variable, Toggle());
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeArrayChoiceImp(TYPE *variable,
                                                               int   numRows)
{
    BSLS_ASSERT_SAFE(variable);

    enum { SUCCESS = 0, FAILURE = -1 };

    if (d_level == d_maxDepth) {
        return FAILURE;
    }

    bdeat_ArrayFunctions::resize(variable, numRows);

    bdem_BdemDecoderUtil_NewLevelGuard newLevelGuard(&d_level);

    for (int i = 0; i != numRows; ++i) {
        if (2 == d_bdemVersion && 1 == d_level) {
            enum {
                EXPECTED_BITMAP
                               = bdem_BdemDecoderUtil_Constants::FIRST_BIT_MASK
            };

            unsigned int bitmap;

            if (!d_stream_p->getUint32(bitmap) || bitmap != EXPECTED_BITMAP) {
                return FAILURE;
            }
        }

        if (0 != bdeat_ArrayFunctions::manipulateElement(variable, *this, i)) {
            return FAILURE;                                           // RETURN
        }
    }

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeArrayImp(
                                  TYPE *variable,
                                  bdem_BdemDecoderUtil_NativeBdemArrayCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    enum { BDEX_VERSION = 1 };

    if (!bdex_InStreamFunctions::streamIn(*d_stream_p,
                                          *variable,
                                          BDEX_VERSION)) {
        return FAILURE;
    }

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeArrayImp(
                                TYPE *variable,
                                bdem_BdemDecoderUtil_ExtendedBdemArrayCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    typedef typename
    bdeat_ArrayFunctions::ElementType<TYPE>::Type ElementType;

    // Decode type information.

    bsl::vector<char> types;
    int               numRows;

    if (0 != decode(&types)
     || !bdem_BdemDecoderUtil_ExtendedBdemTypeUtil::areElemTypesValid(
                                                               (ElementType*)0,
                                                               types)
     || !d_stream_p->getLength(numRows) || 0 > numRows) {
        return FAILURE;                                               // RETURN
    }

    bdeat_ArrayFunctions::resize(variable, numRows);

    typedef bdem_BdemDecoderUtil_Decoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(ElementType*),
                               ThisClass*>       MemFn;

    MemFn memFn(&ThisClass::decodeExtendedTypeValue, this);

    for (int i = 0; i < numRows; ++i) {
        if (0 != bdeat_ArrayFunctions::manipulateElement(variable, memFn, i)) {
            return FAILURE;                                           // RETURN
        }
    }

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeArrayImp(
                                      TYPE *variable,
                                      bdem_BdemDecoderUtil_ChoiceArrayCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    int  numCols, numRows;
    char columnType;

    if (!d_stream_p->getLength(numCols)
     || 1 != numCols
     || !d_stream_p->getInt8(columnType)
     || bdem_ElemType::BDEM_LIST != columnType
     || !d_stream_p->getLength(numRows)
     || 0 > numRows) {
        return FAILURE;                                               // RETURN
    }

    return decodeArrayChoiceImp(variable, numRows);
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeArrayImp(
                                    TYPE *variable,
                                    bdem_BdemDecoderUtil_SequenceArrayCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    // Decode type information.

    bsl::vector<char> types;
    int               numRows;

    if (0 != decode(&types)
     || !d_stream_p->getLength(numRows) || 0 > numRows) {
        return FAILURE;                                               // RETURN
    }

    bdeat_ArrayFunctions::resize(variable, numRows);

    typedef typename
    bdeat_ArrayFunctions::ElementType<TYPE>::Type ElementType;
    typedef bdef_Function<int (*)(ElementType*)>  Functor;

    typedef bdem_BdemDecoderUtil_Decoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(ElementType*,
                                                  const bsl::vector<char>&),
                               ThisClass*>       MemFn;

    MemFn memFn(&ThisClass::decodeSequenceImp, this);

    using bdef_PlaceHolders::_1;

    Functor decodeSequenceFunctor = bdef_BindUtil::bind(memFn, _1, types);

    for (int i = 0; i < numRows; ++i) {
        if (0 != bdeat_ArrayFunctions::manipulateElement(variable,
                                                         decodeSequenceFunctor,
                                                         i)) {
            return FAILURE;                                           // RETURN
        }
    }

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeArrayImp(
                                       TYPE *variable,
                                       bdem_BdemDecoderUtil_OtherArrayCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    int length;

    if (!d_stream_p->getLength(length) || 0 > length) {
        return FAILURE;                                               // RETURN
    }

    bdeat_ArrayFunctions::resize(variable, length);

    for (int i = 0; i < length; ++i) {
        if (0 != bdeat_ArrayFunctions::manipulateElement(variable, *this, i)) {
            return FAILURE;                                           // RETURN
        }
    }

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeChoiceImp(
                                             TYPE               *variable,
                                             char                selectionType,
                                             const bsl::string&  selectionName)
{
    enum { SUCCESS = 0, FAILURE = -1, SELECTION_NOT_PRESENT = -1 };

    if (selectionName.empty()) {
        bdeat_ValueTypeFunctions::reset(variable);

        return SUCCESS;
    }

    if (0 != bdeat_ChoiceFunctions::makeSelection(variable,
                                                  selectionName.data(),
                                                  selectionName.length())) {
        return FAILURE;                                               // RETURN
    }

    if (SELECTION_NOT_PRESENT == selectionType) {
        // The selection data has been compressed out of the stream.

        return SUCCESS;
    }

    bdem_BdemDecoderUtil_BuildElemTypes buildElemType(1);

    if (bdeat_ChoiceFunctions::accessSelection(*variable, buildElemType)
     || buildElemType.elemTypes()[0] != selectionType) {
        return FAILURE;                                               // RETURN
    }

    return bdeat_ChoiceFunctions::manipulateSelection(variable, *this);
}

template <typename STREAM>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeExtendedTypeValue(
                                                         bdet_DateTz *variable)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    bdem_BdemDecoderUtil_NewLevelGuard newLevelGuard(&d_level);

    if (2 == d_bdemVersion && 1 == d_level) {
        enum {
            EXPECTED_BITMAP
                          = bdem_BdemDecoderUtil_Constants::FIRST_TWO_BITS_MASK
        };

        unsigned int bitmap;

        if (!d_stream_p->getUint32(bitmap) || EXPECTED_BITMAP != bitmap) {
            return FAILURE;
        }
    }

    bdet_Date localDate;
    int       offset;

    if (0 != decode(&localDate)
     || 0 != decode(&offset)) {
        return FAILURE;
    }

    variable->setDateTz(localDate, offset);

    return SUCCESS;
}

template <typename STREAM>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeExtendedTypeValue(
                                                     bdet_DatetimeTz *variable)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    bdem_BdemDecoderUtil_NewLevelGuard newLevelGuard(&d_level);

    if (2 == d_bdemVersion && 1 == d_level) {
        enum {
            EXPECTED_BITMAP
                          = bdem_BdemDecoderUtil_Constants::FIRST_TWO_BITS_MASK
        };

        unsigned int bitmap;

        if (!d_stream_p->getUint32(bitmap) || EXPECTED_BITMAP != bitmap) {
            return FAILURE;
        }
    }

    bdet_Datetime localDatetime;
    int           offset;

    if (0 != decode(&localDatetime)
     || 0 != decode(&offset)) {
        return FAILURE;
    }

    variable->setDatetimeTz(localDatetime, offset);

    return SUCCESS;
}

template <typename STREAM>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeExtendedTypeValue(
                                                         bdet_TimeTz *variable)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    bdem_BdemDecoderUtil_NewLevelGuard newLevelGuard(&d_level);

    if (2 == d_bdemVersion && 1 == d_level) {
        enum {
            EXPECTED_BITMAP
                          = bdem_BdemDecoderUtil_Constants::FIRST_TWO_BITS_MASK
        };

        unsigned int bitmap;

        if (!d_stream_p->getUint32(bitmap) || EXPECTED_BITMAP != bitmap) {
            return FAILURE;
        }
    }

    bdet_Time localTime;
    int       offset;

    if (0 != decode(&localTime)
     || 0 != decode(&offset)) {
        return FAILURE;
    }

    variable->setTimeTz(localTime, offset);

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableArrayImp(
                                                    TYPE *variable,
                                                    bdeat_TypeCategory::Choice)
{
    // For array of choices, we can determine that it is null if the number of
    // columns in zero.  If the array is not null, then it must have exactly
    // one column of type 'bdem_ElemType::BDEM_LIST'.

    BSLS_ASSERT_SAFE(variable);

    enum { SUCCESS = 0, FAILURE = -1 };

    int numCols, numRows;

    if (!d_stream_p->getLength(numCols)) {
        return FAILURE;
    }

    if (0 == numCols) {
        if (!d_stream_p->getLength(numRows) || 0 != numRows) {
            return FAILURE;
        }

        bdeat_ValueTypeFunctions::reset(variable);  // make object null

        return SUCCESS;
    }

    bdeat_NullableValueFunctions::makeValue(variable);

    char columnType;

    if (1 != numCols
     || !d_stream_p->getInt8(columnType)
     || bdem_ElemType::BDEM_LIST != columnType
     || !d_stream_p->getLength(numRows)
     || 0 > numRows) {
        return FAILURE;                                               // RETURN
    }

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;
    typedef bdef_Function<int (*)(ValueType*)>          Functor;

    typedef bdem_BdemDecoderUtil_Decoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(ValueType*, int),
                               ThisClass*>       MemFn;

    MemFn memFn(&ThisClass::decodeArrayChoiceImp, this);

    using bdef_PlaceHolders::_1;

    Functor decodeFunctor = bdef_BindUtil::bind(memFn, _1, numRows);

    return bdeat_NullableValueFunctions::manipulateValue(variable,
                                                         decodeFunctor);
}

template <typename STREAM>
template <typename TYPE, typename ANY_CATEGORY>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableArrayImp(
                                                                TYPE *variable,
                                                                ANY_CATEGORY)
{
    // For all other array types, the bdem wire format is ambiguous in that if
    // the array on the stream has zero elements, it either means:
    //   a. there is an array with zero elements.
    //   b. there is no array (i.e., the array object is null).
    // We will take the benefit of the doubt that there is an array with zero
    // elements.  In other words, this means that the decoded 'variable' will
    // never be null.

    BSLS_ASSERT_SAFE(variable);

    bdeat_NullableValueFunctions::makeValue(variable);

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;

    typedef bdem_BdemDecoderUtil_Decoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(ValueType*),
                               ThisClass*>       MemFn;

    MemFn decodeMemFn(&ThisClass::decode, this);

    return bdeat_NullableValueFunctions::manipulateValue(variable,
                                                         decodeMemFn);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableImp(
                                                     TYPE *variable,
                                                     bdeat_TypeCategory::Array)
{
    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ArrayType;
    typedef typename
    bdeat_ArrayFunctions::ElementType<ArrayType>::Type  ElementType;
    typedef typename
    bdeat_TypeCategory::Select<ElementType>::Type       TypeCategory;

    enum {
        IS_EXTENDED_BDEM_TYPE
                          = bslmf_IsSame<ElementType, bdet_DateTz>::VALUE     |
                            bslmf_IsSame<ElementType, bdet_DatetimeTz>::VALUE |
                            bslmf_IsSame<ElementType, bdet_TimeTz>::VALUE
    };

    typedef typename
    bslmf_If<IS_EXTENDED_BDEM_TYPE,
             ExtendedBdemTypeCategory,
             TypeCategory>::Type Toggle;

    return decodeNullableArrayImp(variable, Toggle());
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableImp(
                                                    TYPE *variable,
                                                    bdeat_TypeCategory::Choice)
{
    enum { SUCCESS = 0, FAILURE = -1, SELECTION_NOT_PRESENT = -1 };

    BSLS_ASSERT_SAFE(variable);

    int length;

    if (d_level == d_maxDepth
     || !d_stream_p->getLength(length)) {
        return FAILURE;                                               // RETURN
    }

    bdem_BdemDecoderUtil_NewLevelGuard newLevelGuard(&d_level);

    char        selectionType = SELECTION_NOT_PRESENT;
    bsl::string selectionName;

    switch (length) {
      case 1: {
        // There must be 1 string element, otherwise fail.  Also, if the length
        // is 1, then selectionType will always be 'SELECTION_NOT_PRESENT'.

        enum {
            EXPECTED_BITMAP = bdem_BdemDecoderUtil_Constants::FIRST_BIT_MASK
        };

        char         firstElemType;
        unsigned int bitmap;

        if (!d_stream_p->getInt8(firstElemType)
         || bdem_ElemType::BDEM_STRING != firstElemType
         || ( 2 == d_bdemVersion
           && 1 == d_level
           && (!d_stream_p->getUint32(bitmap) || bitmap != EXPECTED_BITMAP))
         || !d_stream_p->getString(selectionName)) {
            return FAILURE;
        }

        break;
      }
      case 2: {
        // The first element must be a valid string, otherwise fail.  We must
        // also fail if selectionType is 'SELECTION_NOT_PRESENT'.

        enum {
            EXPECTED_BITMAP
                          = bdem_BdemDecoderUtil_Constants::FIRST_TWO_BITS_MASK
        };

        char         firstElemType;
        unsigned int bitmap;

        if (!d_stream_p->getInt8(firstElemType)
         || bdem_ElemType::BDEM_STRING != firstElemType
         || !d_stream_p->getInt8(selectionType)
         || SELECTION_NOT_PRESENT == selectionType
         || ( 2 == d_bdemVersion
           && 1 == d_level
           && (!d_stream_p->getUint32(bitmap) || bitmap != EXPECTED_BITMAP))
         || !d_stream_p->getString(selectionName)
         || selectionName.empty()) {
            return FAILURE;
        }

        break;
      }
      default: {
        bdeat_ValueTypeFunctions::reset(variable);  // make object null

        return SUCCESS;
      }
    };

    bdeat_NullableValueFunctions::makeValue(variable);

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;
    typedef bdef_Function<int (*)(ValueType*)>          Functor;

    typedef bdem_BdemDecoderUtil_Decoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(ValueType*,
                                                  char,
                                                  const bsl::string&),
                               ThisClass*>       MemFn;

    MemFn memFn(&ThisClass::decodeChoiceImp, this);

    using bdef_PlaceHolders::_1;

    Functor decodeChoiceFunctor = bdef_BindUtil::bind(memFn,
                                                      _1,
                                                      selectionType,
                                                      selectionName);

    return bdeat_NullableValueFunctions::manipulateValue(variable,
                                                         decodeChoiceFunctor);
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableImp(
                                               TYPE *variable,
                                               bdeat_TypeCategory::Enumeration)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    int proxy;

    if (0 != decode(&proxy)) {
        return FAILURE;
    }

    if (bdetu_Unset<int>::isUnset(proxy)) {
        bdeat_ValueTypeFunctions::reset(variable);  // make object null

        return SUCCESS;
    }

    bdeat_NullableValueFunctions::makeValue(variable);

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;
    typedef bdef_Function<int (*)(ValueType*)>          Functor;
    typedef int (*UtilFn)(ValueType*, int);

    UtilFn utilFn(&bdeat_EnumFunctions::fromInt);

    using bdef_PlaceHolders::_1;

    Functor convertFunctor = bdef_BindUtil::bind(utilFn, _1, proxy);

    return bdeat_NullableValueFunctions::manipulateValue(variable,
                                                         convertFunctor);
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableImp(
                                                  TYPE *variable,
                                                  bdeat_TypeCategory::Sequence)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    // Stream in the types of attributes in the sequence.

    bsl::vector<char> types;

    if (0 != decode(&types)) {
        return FAILURE;
    }

    if (0 == types.size()) {
        // Note that this is ambiguous in that it might mean:
        //   a. we have a sequence with 0 elements.
        //   b. we do not have a sequence (the object is null).
        // We will assume that the object in the stream is null, since a
        // sequence with 0 elements (although possible) is not likely.

        bdeat_ValueTypeFunctions::reset(variable);  // make object null

        return SUCCESS;
    }

    bdeat_NullableValueFunctions::makeValue(variable);

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;
    typedef bdef_Function<int (*)(ValueType*)>          Functor;

    typedef bdem_BdemDecoderUtil_Decoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(ValueType*,
                                                  const bsl::vector<char>&),
                               ThisClass*>       MemFn;

    MemFn memFn(&ThisClass::decodeSequenceImp, this);

    using bdef_PlaceHolders::_1;

    Functor decodeSequenceFunctor = bdef_BindUtil::bind(memFn, _1, types);

    return bdeat_NullableValueFunctions::manipulateValue(
                                                        variable,
                                                        decodeSequenceFunctor);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableImp(
                                                    TYPE *variable,
                                                    bdeat_TypeCategory::Simple)
{
    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;
    typedef typename
    bdem_SelectBdemType<ValueType>::Type                BdemType;

    enum {
        IS_NATIVE_BDEM_TYPE = bslmf_IsSame<ValueType, BdemType>::VALUE
    };

    enum {
        IS_EXTENDED_BDEM_TYPE
                            = bslmf_IsSame<ValueType, bdet_DateTz>::VALUE     |
                              bslmf_IsSame<ValueType, bdet_DatetimeTz>::VALUE |
                              bslmf_IsSame<ValueType, bdet_TimeTz>::VALUE
    };

    enum {
        SELECTOR = IS_NATIVE_BDEM_TYPE   ? 0 :
                   IS_EXTENDED_BDEM_TYPE ? 1 : 2
    };

    typedef typename
    bslmf_Switch<SELECTOR,
                 NativeBdemTypeCategory,
                 ExtendedBdemTypeCategory,
                 NotBdemTypeCategory>::Type Switch;

    return decodeNullableSimpleImp(variable, Switch());
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableSimpleImp(
                                                        TYPE *variable,
                                                        NativeBdemTypeCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;

    BSLMF_ASSERT((bdetu_UnsetValueIsDefined<ValueType>::VALUE));

    bdeat_NullableValueFunctions::makeValue(variable);

    if (0 != bdeat_NullableValueFunctions::manipulateValue(variable, *this)) {
        return FAILURE;
    }

    bdem_BdemDecoderUtil_IsNull isNull;

    if (0 != bdeat_NullableValueFunctions::accessValue(*variable, isNull)) {
        return FAILURE;
    }

    if (isNull.result() == true) {
        bdeat_ValueTypeFunctions::reset(variable);  // set it back to null
    }

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableSimpleImp(
                                                      TYPE *variable,
                                                      ExtendedBdemTypeCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    // Stream in the types of elements in the list.

    bsl::vector<char> types;

    if (0 != decode(&types)) {
        return FAILURE;
    }

    if (0 == types.size()) {
        bdeat_ValueTypeFunctions::reset(variable);  // make object null

        return SUCCESS;
    }

    // Check if the elemtypes are valid.

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;

    if (!bdem_BdemDecoderUtil_ExtendedBdemTypeUtil::areElemTypesValid(
                                                                 (ValueType*)0,
                                                                 types)) {
        return FAILURE;
    }

    // Object is not null and elemtypes are valid, so make a value and stream
    // it in.

    bdeat_NullableValueFunctions::makeValue(variable);

    typedef bdem_BdemDecoderUtil_Decoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(ValueType*),
                               ThisClass*>       MemFn;

    MemFn memFn(&ThisClass::decodeExtendedTypeValue, this);

    return bdeat_NullableValueFunctions::manipulateValue(variable, memFn);
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeNullableSimpleImp(
                                                           TYPE *variable,
                                                           NotBdemTypeCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;
    typedef typename
    bdem_SelectBdemType<ValueType>::Type                BdemType;

    BSLMF_ASSERT((bdetu_UnsetValueIsDefined<BdemType>::VALUE));

    BdemType proxy;

    if (!decode(&proxy)) {
        return FAILURE;
    }

    if (bdetu_Unset<BdemType>::isUnset(proxy)) {
        bdeat_ValueTypeFunctions::reset(variable);  // make object null

        return SUCCESS;
    }

    bdeat_NullableValueFunctions::makeValue(variable);

    typedef bdef_Function<int (*)(ValueType*)> Functor;

    typedef bdem_BdemDecoderUtil_Decoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(ValueType*,
                                                  const BdemType&),
                               ThisClass*>       MemFn;

    MemFn memFn(&ThisClass::convertFromBdemType, this);

    using bdef_PlaceHolders::_1;

    Functor convertFunctor = bdef_BindUtil::bind(memFn, _1, proxy);

    return bdeat_NullableValueFunctions::manipulateValue(variable,
                                                         convertFunctor);
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeSequenceImp(
                                  TYPE                     *variable,
                                  const bsl::vector<char>&  attributeElemTypes)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    bdem_BdemDecoderUtil_BuildElemTypes buildElemTypes(
                                                    attributeElemTypes.size());

    if (d_level == d_maxDepth
     || 0 != bdeat_SequenceFunctions::accessAttributes(*variable,
                                                       buildElemTypes)
     || attributeElemTypes != buildElemTypes.elemTypes()) {
        return FAILURE;
    }

    bdem_BdemDecoderUtil_NewLevelGuard newLevelGuard(&d_level);

    if (2 == d_bdemVersion && 1 == d_level) {
        bdem_BdemDecoderUtil_DecodeAttributesWithMask<STREAM>
                                           decodeAttributesWithMask(d_stream_p,
                                                                    this);

        return bdeat_SequenceFunctions::manipulateAttributes(
                                                     variable,
                                                     decodeAttributesWithMask);
    }
    else {
        return bdeat_SequenceFunctions::manipulateAttributes(variable, *this);
    }
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeSimpleImp(
                                                        TYPE *variable,
                                                        NativeBdemTypeCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    enum { BDEX_VERSION = 1 };

    if (!bdex_InStreamFunctions::streamIn(*d_stream_p,
                                          *variable,
                                          BDEX_VERSION)) {
        return FAILURE;                                           // RETURN
    }

    return SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decodeSimpleImp(TYPE *variable,
                                                          NotBdemTypeCategory)
{
    enum { SUCCESS = 0, FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    enum { BDEX_VERSION = 1 };

    typedef typename
    bdem_SelectBdemType<TYPE>::Type BdemType;

    // We need a proxy object.  Using proxy object ensures that unsigned
    // types will be correctly streamed in as signed types before casting.

    BdemType proxy;

    if (!bdex_InStreamFunctions::streamIn(*d_stream_p, proxy, BDEX_VERSION)) {
        return FAILURE;                                           // RETURN
    }

    *variable = static_cast<TYPE>(proxy);

    return SUCCESS;
}

// CREATORS
template <typename STREAM>
inline
bdem_BdemDecoderUtil_Decoder<STREAM>::bdem_BdemDecoderUtil_Decoder(
                                                           STREAM *stream,
                                                           int     bdemVersion,
                                                           int     maxDepth)
: d_bdemVersion(bdemVersion)
, d_level(0)
, d_maxDepth(maxDepth)
, d_stream_p(stream)
{
}

// MANIPULATORS
template <typename STREAM>
template <typename TYPE, typename INFO>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::operator()(TYPE *variable,
                                                     const INFO&)
{
    return decode(variable);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::operator()(TYPE *variable)
{
    return decode(variable);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemDecoderUtil_Decoder<STREAM>::decode(TYPE *variable)
{
    BSLS_ASSERT_SAFE(variable);

    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return decodeImp(variable, TypeCategory());
}

template <typename STREAM>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decode(bdet_DateTz *variable)
{
    enum { FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    bsl::vector<char> types;

    if (0 != decode(&types)
     || !bdem_BdemDecoderUtil_ExtendedBdemTypeUtil::areElemTypesValid(
                                                               (bdet_DateTz*)0,
                                                               types)) {
        return FAILURE;                                               // RETURN
    }

    return decodeExtendedTypeValue(variable);
}

template <typename STREAM>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decode(bdet_DatetimeTz *variable)
{
    enum { FAILURE = -1 };

    BSLS_ASSERT_SAFE(variable);

    bsl::vector<char> types;

    if (0 != decode(&types)
     || !bdem_BdemDecoderUtil_ExtendedBdemTypeUtil::areElemTypesValid(
                                                           (bdet_DatetimeTz*)0,
                                                           types)) {
        return FAILURE;                                               // RETURN
    }

    return decodeExtendedTypeValue(variable);
}

template <typename STREAM>
int bdem_BdemDecoderUtil_Decoder<STREAM>::decode(bdet_TimeTz *variable)
{
    enum { FAILURE = -1 };

    bsl::vector<char> types;

    if (0 != decode(&types)
     || !bdem_BdemDecoderUtil_ExtendedBdemTypeUtil::areElemTypesValid(
                                                               (bdet_TimeTz*)0,
                                                               types)) {
        return FAILURE;                                               // RETURN
    }

    return decodeExtendedTypeValue(variable);
}

          // --------------------------------------------------------
          // private struct bdem_BdemDecoderUtil_ExtendedBdemTypeUtil
          // --------------------------------------------------------

inline
bool bdem_BdemDecoderUtil_ExtendedBdemTypeUtil::areElemTypesValid(
                                           bdet_DateTz              *,
                                           const bsl::vector<char>&  elemTypes)
{
    return 2                   == elemTypes.size()
        && bdem_ElemType::BDEM_DATE == elemTypes[0]
        && bdem_ElemType::BDEM_INT  == elemTypes[1];
}

inline
bool bdem_BdemDecoderUtil_ExtendedBdemTypeUtil::areElemTypesValid(
                                          bdet_DatetimeTz          *,
                                          const bsl::vector<char>&  elemTypes)
{
    return 2                       == elemTypes.size()
        && bdem_ElemType::BDEM_DATETIME == elemTypes[0]
        && bdem_ElemType::BDEM_INT      == elemTypes[1];
}

inline
bool bdem_BdemDecoderUtil_ExtendedBdemTypeUtil::areElemTypesValid(
                                           bdet_TimeTz              *,
                                           const bsl::vector<char>&  elemTypes)
{
    return 2                   == elemTypes.size()
        && bdem_ElemType::BDEM_TIME == elemTypes[0]
        && bdem_ElemType::BDEM_INT  == elemTypes[1];
}

                 // -----------------------------------------
                 // private class bdem_BdemDecoderUtil_IsNull
                 // -----------------------------------------

// CREATORS
inline
bdem_BdemDecoderUtil_IsNull::bdem_BdemDecoderUtil_IsNull()
: d_result(false)
{
}

// MANIPULATORS
template <typename TYPE, typename INFO>
inline
int bdem_BdemDecoderUtil_IsNull::operator()(const TYPE& value, const INFO&)
{
    return (*this)(value);
}

template <typename TYPE>
inline
int bdem_BdemDecoderUtil_IsNull::operator()(const TYPE& value)
{
    enum { SUCCESS = 0 };

    BSLMF_ASSERT((bdetu_UnsetValueIsDefined<TYPE>::VALUE));

    d_result = bdetu_Unset<TYPE>::isUnset(value);

    return SUCCESS;
}

// ACCESSORS
inline
bool bdem_BdemDecoderUtil_IsNull::result() const
{
    return d_result;
}

              // ------------------------------------------------
              // private class bdem_BdemDecoderUtil_NewLevelGuard
              // ------------------------------------------------

// CREATORS
inline
bdem_BdemDecoderUtil_NewLevelGuard::bdem_BdemDecoderUtil_NewLevelGuard(
                                                                    int *level)
: d_level_p(level)
{
    BSLS_ASSERT_SAFE(d_level_p);
    ++(*d_level_p);
}

inline
bdem_BdemDecoderUtil_NewLevelGuard::~bdem_BdemDecoderUtil_NewLevelGuard()
{
    --(*d_level_p);
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2005
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
