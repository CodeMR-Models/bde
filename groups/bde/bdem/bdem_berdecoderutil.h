// bdem_berdecoderutil.h                  -*-C++-*-
#ifndef INCLUDED_BDEM_BERDECODERUTIL
#define INCLUDED_BDEM_BERDECODERUTIL

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide a BER decoder utility.
//
//@DEPRECATED: Use 'bdem_berdecoder' instead.
//
//@CLASSES:
//      bdem_BerDecoderUtil: BER decoder utility
//
//@SEE_ALSO: bdem_berencoderutil, bdem_bdemdecoderutil
//
//@AUTHOR: Rohan Bhindwale (rbhindwa), Shezan Baig (sbaig)
//
//@CONTACT: Rohan Bhindwale (rbhindwa)
//
//@DESCRIPTION:  The 'bdem_BerDecoderUtil' 'struct' provided in this component
// contains a parameterized 'decode' function that decodes a specified
// value-semantic object from a specified stream.  There are four overloaded
// versions of this function:
//..
//    o reads from an 'bsl::streambuf' and uses default options
//    o reads from an 'bsl::streambuf' and uses user-supplied options
//    o reads from an 'bsl::istream' and uses default options
//    o reads from an 'bsl::istream' and uses user-supplied options
//..
// This component decodes objects based on the X.690 BER specification.  It can
// only be used with types supported by the 'bdeat' framework.  In particular,
// types generated by the 'bas_codegen.pl' tool can be used.  Since the types
// are generated from XSD, the X.694 mappings are applied.
//
///Usage
///-----
// The following snippets of code illustrate the usage of this component.
// Suppose we have an XML schema inside a file called 'employee.xsd':
//..
//  <?xml version='1.0' encoding='UTF-8'?>
//  <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
//             xmlns:test='http://bloomberg.com/schemas/test'
//             targetNamespace='http://bloomberg.com/schemas/test'
//             elementFormDefault='unqualified'>
//
//      <xs:complexType name='Address'>
//          <xs:sequence>
//              <xs:element name='street' type='xs:string'/>
//              <xs:element name='city'   type='xs:string'/>
//              <xs:element name='state'  type='xs:string'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:complexType name='Employee'>
//          <xs:sequence>
//              <xs:element name='name'        type='xs:string'/>
//              <xs:element name='homeAddress' type='test:Address'/>
//              <xs:element name='age'         type='xs:int'/>
//          </xs:sequence>
//      </xs:complexType>
//
//  </xs:schema>
//..
// Using the 'bas_codegen.pl' tool, we can generate C++ classes for this
// schema:
//..
//  $ bas_codegen.pl -g h -g cpp -p test employee.xsd
//..
// This tool will generate the header and implementation files for the
// 'test_address' and 'test_employee' components in the current directory.
//
// Now suppose we want to encode information about a particular employee using
// the BER encoding.  Note that we will use 'bdesb' stream buffers for in-core
// buffer management:
//..
//  #include <bdesb_memoutstreambuf.h>
//  #include <bdesb_fixedmeminstreambuf.h>
//
//  #include <test_employee.h>
//
//  #include <bdem_berencoderutil.h>
//  #include <bdem_berdecoderutil.h>
//
//  using namespace BloombergLP;
//
//  void usageExample()
//  {
//      bdesb_MemOutStreamBuf osb;
//
//      test::Employee bob;
//
//      bob.name()                 = "Bob";
//      bob.homeAddress().street() = "Some Street";
//      bob.homeAddress().city()   = "Some City";
//      bob.homeAddress().state()  = "Some State";
//      bob.age()                  = 21;
//
//      int retCode = bdem_BerEncoderUtil::encode(&osb, bob);
//
//      assert(0 == retCode);
//..
// At this point, 'osb' contains a representation of 'bob' in BER format.  Now
// we will verify the contents of 'osb' using the 'bdem_berdecoderutil'
// component:
//..
//      bdesb_FixedMemInStreamBuf isb(osb.data(), osb.length());     // NO COPY
//      test::Employee            obj;
//
//      retCode = bdem_BerDecoderUtil::decode(&isb, &obj);
//
//      assert(0                          == retCode);
//      assert(bob.name()                 == obj.name());
//      assert(bob.homeAddress().street() == obj.homeAddress().street());
//      assert(bob.homeAddress().city()   == obj.homeAddress().city());
//      assert(bob.homeAddress().state()  == obj.homeAddress().state());
//      assert(bob.age()                  == obj.age());
//  }
//..

#ifndef INCLUDED_BDESCM_VERSION
#include <bdescm_version.h>
#endif

#ifndef INCLUDED_BDEM_BERDECODER
#include <bdem_berdecoder.h>
#endif

namespace BloombergLP {

                         // ==========================
                         // struct bdem_BerDecoderUtil
                         // ==========================

struct bdem_BerDecoderUtil {
    // This 'struct' contains the parameterized 'decode' functions that decode
    // data (in BER format) from an incoming stream into 'bdeat' types.

    // MANIPULATORS
    template <typename TYPE>
    static int decode(bsl::streambuf *streamBuf, TYPE *variable);

    template <typename TYPE>
    static int decode(bsl::streambuf                *streamBuf,
                      TYPE                          *variable,
                      const bdem_BerDecoderOptions&  options);
        // Decode an object of parameterized 'TYPE' from the specified
        // 'streamBuf' using the optionally specified 'options' and load the
        // result into the specified modifiable 'variable'.  Return 0 on
        // success, and a non-zero value otherwise.

    template <typename TYPE>
    static bsl::istream& decode(bsl::istream& stream, TYPE *variable);

    template <typename TYPE>
    static bsl::istream& decode(bsl::istream&                  stream,
                                TYPE                          *variable,
                                const bdem_BerDecoderOptions&  options);
        // Decode an object of parameterized 'TYPE' from the specified 'stream'
        // using the optionally specified 'options' and load the result into
        // the specified modifiable 'variable'.  Return a reference to
        // 'stream'.  Note that 'stream' will be invalidated if the decoding
        // fails.
};

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

                         // --------------------------
                         // struct bdem_BerDecoderUtil
                         // --------------------------

template <typename TYPE>
inline
int bdem_BerDecoderUtil::decode(bsl::streambuf *streamBuf, TYPE *variable)
{
    return decode(streamBuf, variable, bdem_BerDecoderOptions());
}

template <typename TYPE>
inline
int bdem_BerDecoderUtil::decode(bsl::streambuf                *streamBuf,
                                TYPE                          *variable,
                                const bdem_BerDecoderOptions&  options)
{
    bdem_BerDecoder decoder(&options);
    return decoder.decode(streamBuf, variable);
}

template <typename TYPE>
inline
bsl::istream& bdem_BerDecoderUtil::decode(bsl::istream& stream, TYPE *variable)
{
    return decode(stream, variable, bdem_BerDecoderOptions());
}

template <typename TYPE>
inline
bsl::istream& bdem_BerDecoderUtil::decode(
                                       bsl::istream&                  stream,
                                       TYPE                          *variable,
                                       const bdem_BerDecoderOptions&  options)
{
    bdem_BerDecoder decoder(&options);
    decoder.decode(stream, variable);
    return stream;
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2005
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
