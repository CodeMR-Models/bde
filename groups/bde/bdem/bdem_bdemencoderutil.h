// bdem_bdemencoderutil.h                  -*-C++-*-
#ifndef INCLUDED_BDEM_BDEMENCODERUTIL
#define INCLUDED_BDEM_BDEMENCODERUTIL

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide a 'bdem'-compatible encoder utility.
//
//@DEPRECATED: Do not use.
//
//@CLASSES:
//    bdem_BdemEncoderUtil: 'bdem'-compatible encoder utility
//
//@SEE_ALSO: bdem_bdemdecoderutil, bdem_berencoderutil
//
//@AUTHOR: Rohan Bhindwale (rbhindwa), Shezan Baig (sbaig)
//
//@CONTACT: Rohan Bhindwale (rbhindwa)
//
//@DESCRIPTION: The 'bdem_BdemEncoderUtil' 'struct' provided in this component
// contains a parameterized 'encode' function that encodes a specified
// value-semantic object into a specified stream.  There are six overloaded
// versions of this function:
//..
//    o writes to a 'bdex' stream and uses default options
//    o writes to a 'bdex' stream and uses user-supplied options
//    o writes to an 'bsl::streambuf' and uses default options
//    o writes to an 'bsl::streambuf' and uses user-supplied options
//    o writes to an 'bsl::ostream' and uses default options
//    o writes to an 'bsl::ostream' and uses user-supplied options
//..
//
// These functions encode objects in the 'bdem' wire format.  The 'options'
// argument allows clients to switch between version 1 and version 2 of the
// 'bdem' wire format.  By default, version 2 is used.  The typical use case
// for this component is to encode objects in the 'bdem' wire format at the
// sender's side, and load it into a 'bdem_List' on the receiver's side.
//
// These functions can be used with types supported by the 'bdeat' framework.
// In particular, types generated by the 'bas_codegen.pl' tool can be used.
//
///'bdem' Encoding Rules
///---------------------
// The following 'bdem' encoding rules are used by this component:
//..
//    o fundamental C++ types are cast to 'bdem' types using the mapping
//      defined in 'bdem_selectbdemtype'.
//    o an object that falls under 'bdeat_TypeCategory::Sequence' is encoded as
//      a LIST containing the attributes of the sequence.
//    o an object that falls under 'bdeat_TypeCategory::Choice' is encoded as a
//      LIST.  If the choice object has no selection, then the list will
//      contain exactly one sub-item, which must be an empty string.  If the
//      choice object has a selection, then the list will contain exactly two
//      sub-items - the first sub-item will be a string indicating the name of
//      the selection; the second sub-item will be the value of the selection.
//    o a 'bdet_DateTz' object is encoded as a LIST containing exactly two
//      sub-items - the first sub-item will be a DATE containing the value of
//      the local date; the second sub-item will be an INT containing the
//      timezone offset in minutes.
//    o a 'bdet_DatetimeTz' object is encoded as a LIST containing exactly two
//      sub-items - the first sub-item will be a DATETIME containing the value
//      of the local datetime; the second sub-item will be an INT containing
//      the timezone offset in minutes.
//    o a 'bdet_TimeTz' object is encoded as a LIST containing exactly two
//      sub-items - the first sub-item will be a TIME containing the value of
//      the local time; the second sub-item will be an INT containing the
//      timezone offset in minutes.
//..
//
///Usage
///-----
// The following snippets of code illustrate the usage of this component.
// Suppose we have an XML schema inside a file called 'employee.xsd':
//..
//  <?xml version='1.0' encoding='UTF-8'?>
//  <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
//             xmlns:test='http://bloomberg.com/schemas/test'
//             targetNamespace='http://bloomberg.com/schemas/test'
//             elementFormDefault='unqualified'>
//
//      <xs:complexType name='Address'>
//          <xs:sequence>
//              <xs:element name='street' type='xs:string'/>
//              <xs:element name='city'   type='xs:string'/>
//              <xs:element name='state'  type='xs:string'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:complexType name='Employee'>
//          <xs:sequence>
//              <xs:element name='name'        type='xs:string'/>
//              <xs:element name='homeAddress' type='test:Address'/>
//              <xs:element name='age'         type='xs:int'/>
//              <xs:element name='dateJoined'  type='date'/>
//          </xs:sequence>
//      </xs:complexType>
//
//  </xs:schema>
//..
// Using the 'bas_codegen.pl' tool, we can generate C++ classes for this
// schema:
//..
//  $ bas_codegen.pl -g h -g cpp -p test employee.xsd
//..
// This tool will generate the header and implementation files for the
// 'test_address' and 'test_employee' components in the current directory.
//
// Now suppose we want to encode information about a particular employee in a
// 'bdem' wire format.  Note that we will use 'bdesb' stream buffers for
// in-core buffer management:
//..
//  #include <bdesb_memoutstreambuf.h>
//  #include <bdesb_fixedmeminstreambuf.h>
//  #include <bdex_byteinstreamformatter.h>
//  #include <bdem_list.h>
//
//  #include <test_employee.h>
//
//  #include <bdem_bdemencoderutil.h>
//
//  using namespace BloombergLP;
//
//  void usageExample()
//  {
//      bdesb_MemOutStreamBuf osb;
//
//      test::Employee bob;
//
//      bob.name()                 = "Bob";
//      bob.homeAddress().street() = "Some Street";
//      bob.homeAddress().city()   = "Some City";
//      bob.homeAddress().state()  = "Some State";
//      bob.age()                  = 21;
//      bob.dateJoined()           = bdet_DateTz(bdet_Date(2003, 3, 20), -300);
//
//      int retCode = bdem_BdemEncoderUtil::encode(&osb, bob);
//
//      assert(0 == retCode);
//..
// At this point, 'osb' contains a representation of 'bob' in 'bdem' format
// (version 2).  Now we will load the contents of 'osb' into a 'bdem_List'
// object and verify its contents:
//..
//      bdesb_FixedMemInStreamBuf  isb(osb.data(), osb.length());    // NO COPY
//      bdex_ByteInStreamFormatter formatter(&isb);
//      bdem_List                  list;
//
//      const int BDEM_VERSION = 2;
//
//      list.bdexStreamIn(formatter, BDEM_VERSION);
//
//      assert(formatter);
//      assert(bob.name()                   == list.theString(0));
//      assert(bob.homeAddress().street()   == list.theList(1).theString(0));
//      assert(bob.homeAddress().city()     == list.theList(1).theString(1));
//      assert(bob.homeAddress().state()    == list.theList(1).theString(2));
//      assert(bob.age()                    == list.theInt(2));
//      assert(bob.dateJoined().localDate() == list.theList(3).theDate(0));
//      assert(bob.dateJoined().offset()    == list.theList(3).theInt(1));
//  }
//..

#ifndef INCLUDED_BDESCM_VERSION
#include <bdescm_version.h>
#endif

#ifndef INCLUDED_BDEM_BDEMENCODEROPTIONS
#include <bdem_bdemencoderoptions.h>
#endif

#ifndef INCLUDED_BDEM_ELEMTYPE
#include <bdem_elemtype.h>
#endif

#ifndef INCLUDED_BDEM_SELECTBDEMTYPE
#include <bdem_selectbdemtype.h>
#endif

#ifndef INCLUDED_BDEAT_ARRAYFUNCTIONS
#include <bdeat_arrayfunctions.h>
#endif

#ifndef INCLUDED_BDEAT_CHOICEFUNCTIONS
#include <bdeat_choicefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_NULLABLEVALUEFUNCTIONS
#include <bdeat_nullablevaluefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_SEQUENCEFUNCTIONS
#include <bdeat_sequencefunctions.h>
#endif

#ifndef INCLUDED_BDEAT_TYPECATEGORY
#include <bdeat_typecategory.h>
#endif

#ifndef INCLUDED_BDEF_BIND
#include <bdef_bind.h>
#endif

#ifndef INCLUDED_BDEF_FUNCTION
#include <bdef_function.h>
#endif

#ifndef INCLUDED_BDEF_MEMFN
#include <bdef_memfn.h>
#endif

#ifndef INCLUDED_BDEF_PLACEHOLDER
#include <bdef_placeholder.h>
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include <bslmf_assert.h>
#endif

#ifndef INCLUDED_BSLMF_ISSAME
#include <bslmf_issame.h>
#endif

#ifndef INCLUDED_BSLMF_SWITCH
#include <bslmf_switch.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

#ifndef INCLUDED_BSLS_PLATFORMUTIL
#include <bsls_platformutil.h>
#endif

#ifndef INCLUDED_BDET_DATETIMETZ
#include <bdet_datetimetz.h>
#endif

#ifndef INCLUDED_BDET_DATETZ
#include <bdet_datetz.h>
#endif

#ifndef INCLUDED_BDET_TIMETZ
#include <bdet_timetz.h>
#endif

#ifndef INCLUDED_BDETU_UNSET
#include <bdetu_unset.h>
#endif

#ifndef INCLUDED_BDEX_BYTEOUTSTREAMFORMATTER
#include <bdex_byteoutstreamformatter.h>
#endif

#ifndef INCLUDED_BDEX_OUTSTREAMFUNCTIONS
#include <bdex_outstreamfunctions.h>
#endif

#ifndef INCLUDED_BSL_OSTREAM
#include <bsl_ostream.h>
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include <bsl_streambuf.h>
#endif

namespace BloombergLP {

                        // ===========================
                        // struct bdem_BdemEncoderUtil
                        // ===========================

struct bdem_BdemEncoderUtil {
    // This 'struct' contains the parameterized 'encode' functions that encode
    // 'bdeat' types to an outgoing stream in a 'bdem' wire format.

    // MANIPULATORS
    template <typename STREAM, typename TYPE>
    static STREAM& encode(STREAM& stream, const TYPE& value);
    template <typename STREAM, typename TYPE>
    static STREAM& encode(STREAM&                        stream,
                          const TYPE&                    value,
                          const bdem_BdemEncoderOptions& options);
        // Encode the specified non-modifiable 'value' to the specified
        // parameterized 'bdex' 'stream' using the optionally specified
        // 'options'.  Return a reference to 'stream'.  Note that 'stream' will
        // be invalidated if the encoding fails.

    template <typename TYPE>
    static int encode(bsl::streambuf *buffer, const TYPE& value);
    template <typename TYPE>
    static int encode(bsl::streambuf                 *buffer,
                      const TYPE&                     value,
                      const bdem_BdemEncoderOptions&  options);
        // Encode the specified non-modifiable 'value' to the specified
        // 'buffer' using the optionally specified 'options'.  Return 0 on
        // success, and a non-zero value otherwise.

    template <typename TYPE>
    static bsl::ostream& encode(bsl::ostream& stream, const TYPE& value);
    template <typename TYPE>
    static bsl::ostream& encode(bsl::ostream&                  stream,
                                const TYPE&                    value,
                                const bdem_BdemEncoderOptions& options);
        // Encode the specified non-modifiable 'value' to the specified
        // 'stream' using the optionally specified 'options'.  Return a
        // reference to 'stream'.  Note that 'stream' will be invalidated if
        // the encoding fails.

};

// ---  Anything below this line is implementation specific.  Do not use.  ----

template <typename STREAM>
class bdem_BdemEncoderUtil_Encoder;

struct bdem_BdemEncoderUtil_NativeBdemArrayCategory;
struct bdem_BdemEncoderUtil_ExtendedBdemArrayCategory;
struct bdem_BdemEncoderUtil_SequenceArrayCategory;
struct bdem_BdemEncoderUtil_ChoiceArrayCategory;
struct bdem_BdemEncoderUtil_OtherArrayCategory;

           // ======================================================
           // private class bdem_BdemEncoderUtil_BindEncodeSelection
           // ======================================================

template <typename STREAM>
class bdem_BdemEncoderUtil_BindEncodeSelection {
    // This class is used to bind the 'encodeSelection' method in the
    // 'bdem_BdemEncoderUtil_Encoder' class with the visited object.

    // PRIVATE DATA MEMBERS
    bdem_BdemEncoderUtil_Encoder<STREAM> *d_encoder_p;

  private:
    // NOT IMPLEMENTED
    bdem_BdemEncoderUtil_BindEncodeSelection(
                              const bdem_BdemEncoderUtil_BindEncodeSelection&);
    bdem_BdemEncoderUtil_BindEncodeSelection& operator=(
                              const bdem_BdemEncoderUtil_BindEncodeSelection&);

  public:
    // CREATORS
    bdem_BdemEncoderUtil_BindEncodeSelection(
                                bdem_BdemEncoderUtil_Encoder<STREAM> *encoder);

    // Generated by compiler:
    // ~bdem_BdemEncoderUtil_BindEncodeSelection();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(const TYPE&      object,
                   const INFO_TYPE& info);
};

              // ===============================================
              // private class bdem_BdemEncoderUtil_BuildBitmaps
              // ===============================================

class bdem_BdemEncoderUtil_BuildBitmaps {
    // This class is used to build the bitmaps that precede every 32 elements
    // in the 'bdem' version 2 wire format.  After visiting all the attributes
    // in a sequence, the vector of bitmaps can be obtained using the 'bitmaps'
    // accessor.

    // PRIVATE DATA MEMBERS
    bsl::vector<unsigned int> d_bitmaps;
    unsigned int              d_mask;

    // PRIVATE MANIPULATORS
    template <typename TYPE>
    void addMask(const TYPE& object, bdeat_TypeCategory::NullableValue);

    template <typename TYPE, typename ANY_CATEGORY>
    void addMask(const TYPE& object, ANY_CATEGORY);

  private:
    // NOT IMPLEMENTED
    bdem_BdemEncoderUtil_BuildBitmaps(
                                     const bdem_BdemEncoderUtil_BuildBitmaps&);
    bdem_BdemEncoderUtil_BuildBitmaps& operator=(
                                     const bdem_BdemEncoderUtil_BuildBitmaps&);

  public:
    // CREATORS
    bdem_BdemEncoderUtil_BuildBitmaps();

    // Generated by compiler:
    // ~bdem_BdemEncoderUtil_BuildBitmaps();

    // MANIPULATORS
    template <typename TYPE, typename INFO>
    int operator()(const TYPE& object,
                   const INFO&);

    // ACCESSORS
    const bsl::vector<unsigned int>& bitmaps() const;
};

             // =================================================
             // private class bdem_BdemEncoderUtil_BuildElemTypes
             // =================================================

class bdem_BdemEncoderUtil_BuildElemTypes {
    // This class is used to build a vector of 'bdem' element types.  Note that
    // vector<char> is used instead of vector<bdem_ElemType::Type> because the
    // 'bdem' wire format uses vector<char> and the streaming can be optimized.

    // PRIVATE DATA MEMBERS
    bsl::vector<char> d_elemTypes;  // array of 'bdem' element types

  private:
    // NOT IMPLEMENTED
    bdem_BdemEncoderUtil_BuildElemTypes(
                                   const bdem_BdemEncoderUtil_BuildElemTypes&);
    bdem_BdemEncoderUtil_BuildElemTypes& operator=(
                                   const bdem_BdemEncoderUtil_BuildElemTypes&);

  public:
    // CREATORS
    bdem_BdemEncoderUtil_BuildElemTypes();
        // Create a 'bdem' element type builder.

    // Generated by compiler:
    // ~bdem_BdemEncoderUtil_BuildElemTypes();

    // MANIPULATORS
    template <typename TYPE, typename INFO>
    int operator()(const TYPE& value, const INFO&);
        // Append the 'bdem' element type corresponding to the specified non-
        // modifiable 'value' of parameterized 'TYPE' to the array of element
        // types built by this object and return 0.

    // ACCESSORS
    const bsl::vector<char>& elemTypes() const;
        // Return a reference to the array of non-modifiable 'bdem' element
        // types build by this object.
};

               // =============================================
               // private struct bdem_BdemEncoderUtil_Constants
               // =============================================

struct bdem_BdemEncoderUtil_Constants {
    // This 'struct' contains constants that are used throughout this
    // component.

    enum {
        BDEM_FIRST_BIT_MASK      = 0x80000000U,  // mask for first bit in a 32
                                                 // bit unsigned integer
        BDEM_FIRST_TWO_BITS_MASK = 0xC0000000U   // mask for first two bits in
                                                 // a 32 bit unsigned integer
    };
};

        // ===========================================================
        // private class bdem_BdemEncoderUtil_EncodeAttributesWithMask
        // ===========================================================

template <typename STREAM>
class bdem_BdemEncoderUtil_EncodeAttributesWithMask {
    // This class is used to encode a sequence of attributes, preceding every
    // 32 attributes with a 32-bit bitmap.  If a bit is reset, that means that
    // the corresponding attribute is null and is compressed out of the stream
    // (see 'bdem' wire format, version 2, for more details).

    // PRIVATE DATA MEMBERS
    int                                   d_attributeIndex;
    const bsl::vector<unsigned int>      *d_bitmaps_p;  // held, not owned
    bdem_BdemEncoderUtil_Encoder<STREAM> *d_encoder_p;  // held, not owned
    STREAM                               *d_stream_p;   // held, not owned

  private:
    // NOT IMPLEMENTED
    bdem_BdemEncoderUtil_EncodeAttributesWithMask(
                         const bdem_BdemEncoderUtil_EncodeAttributesWithMask&);
    bdem_BdemEncoderUtil_EncodeAttributesWithMask& operator=(
                         const bdem_BdemEncoderUtil_EncodeAttributesWithMask&);

  public:
    // CREATORS
    bdem_BdemEncoderUtil_EncodeAttributesWithMask(
                                STREAM                               *stream,
                                bdem_BdemEncoderUtil_Encoder<STREAM> *encoder,
                                const bsl::vector<unsigned int>      *bitmaps);

    // Generated by compiler:
    // ~bdem_BdemEncoderUtil_EncodeAttributesWithMask();

    // MANIPULATORS
    template <typename TYPE, typename INFO_TYPE>
    int operator()(const TYPE& object,
                   const INFO_TYPE&);

    template <typename TYPE>
    int execute(const TYPE& object);
};

                 // ==========================================
                 // private class bdem_BdemEncoderUtil_Encoder
                 // ==========================================

template <typename STREAM>
class bdem_BdemEncoderUtil_Encoder {
    // This class contains the logic for encoding each of the supported types.
    // It is parameterized with the 'bdex' stream type.

    int     d_bdemVersion;  // 'bdem' version to be used for encoding
    int     d_level;        // bitmap for 'bdem' streaming version 2 put out
                            // only at top-level
    STREAM *d_stream_p;     // stream to which 'bdem'-compliant message is
                            // encoded (held, not owned)

  private:
    // PRIVATE TYPES
    struct TypeHasBdetuNullValue   { };
    struct TypeHasNoBdetuNullValue { };

    // PRIVATE MANIPULATORS
    template <typename BDEM_TYPE>
    int encodeNullValue(TypeHasBdetuNullValue);
        // Encode the null representation of the parameterized 'BDEM_TYPE'.
        // Return 0 on success, and a non-zero value otherwise.  Note that the
        // argument is used for overloading purposes and indicates that
        // 'BDEM_TYPE' has a defined 'bdetu' null value (see 'bdetu_unset').

    template <typename BDEM_TYPE>
    int encodeNullValue(TypeHasNoBdetuNullValue);
        // Encode the null representation of the parameterized 'BDEM_TYPE'.
        // Return 0 on success, and a non-zero value otherwise.  Note that the
        // argument is used for overloading purposes and indicates that
        // 'BDEM_TYPE' does *not* have a defined 'bdetu' null value (i.e.,
        // arrays, list, and table).

    template <typename TYPE>
    int encodeImp(const TYPE& value, bdeat_TypeCategory::Array);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under 'bdeat_TypeCategory::Array'.

    template <typename TYPE>
    int encodeImp(const TYPE& value, bdeat_TypeCategory::Choice);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under 'bdeat_TypeCategory::Choice'.

    template <typename TYPE>
    int encodeImp(const TYPE& value, bdeat_TypeCategory::CustomizedType);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::CustomizedType'.

    template <typename TYPE>
    int encodeImp(const TYPE& value, bdeat_TypeCategory::Enumeration);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Enumeration'.

    template <typename TYPE>
    int encodeImp(const TYPE& value, bdeat_TypeCategory::NullableValue);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::NullableValue'.

    template <typename TYPE>
    int encodeImp(const TYPE& value, bdeat_TypeCategory::Sequence);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::Sequence'.

    template <typename TYPE>
    int encodeImp(const TYPE& value, bdeat_TypeCategory::Simple);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under 'bdeat_TypeCategory::Simple'.

    template <typename TYPE>
    int encodeArrayImp(const TYPE& value,
                       bdem_BdemEncoderUtil_NativeBdemArrayCategory);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that second argument is used for overloading purposes and
        // indicates that 'TYPE' must be a native 'bdem' array.

    template <typename TYPE>
    int encodeArrayImp(const TYPE& value,
                       bdem_BdemEncoderUtil_ChoiceArrayCategory);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under 'bdeat_TypeCategory::Array'
        // and must contain elements that fall under
        // 'bdeat_TypeCategory::Choice'.

    template <typename TYPE>
    int encodeArrayImp(const TYPE& value,
                       bdem_BdemEncoderUtil_ExtendedBdemArrayCategory);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under 'bdeat_TypeCategory::Array'
        // and must contain extended types ('bdet_DateTz', 'bdet_DatetimeTz',
        // and 'bdet_TimeTz').

    template <typename TYPE>
    int encodeArrayImp(const TYPE& value,
                       bdem_BdemEncoderUtil_SequenceArrayCategory);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under 'bdeat_TypeCategory::Array'
        // and must contain elements that fall under
        // 'bdeat_TypeCategory::Sequence'.

    template <typename TYPE>
    int encodeArrayImp(const TYPE& value,
                       bdem_BdemEncoderUtil_OtherArrayCategory);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is used for overloading purposes and
        // indicates that 'TYPE' must fall under 'bdeat_TypeCategory::Array'
        // but not fall under any of the other overloads of 'encodeArrayImp'.

    int encodeExtendedTypeElemTypes(bdet_DateTz *ignored);
    int encodeExtendedTypeElemTypes(bdet_DatetimeTz *ignored);
    int encodeExtendedTypeElemTypes(bdet_TimeTz *ignored);
        // Encode, to the stream held by this encoder, an 'bsl::vector<char>'
        // that contains the 'bdem' element types that correspond to the 'bdem'
        // element types used to compose the value of the overloaded type.
        // Return 0 on success, and a non-zero value otherwise.  Note that the
        // specified 'ignored' argument is used for overloading purposes and is
        // not used in the function definition.

    int encodeExtendedTypeValue(const bdet_DateTz& value);
    int encodeExtendedTypeValue(const bdet_DatetimeTz& value);
    int encodeExtendedTypeValue(const bdet_TimeTz& value);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.

    template <typename TYPE>
    int encodeSelectionImp(const TYPE&        value,
                           const bsl::string& name,
                           bdeat_TypeCategory::NullableValue);
        // Encode the specified 'value' as a selection with the specified
        // 'name' to the stream held by this encoder.  Return 0 on success, and
        // a non-zero value otherwise.  Note that the third argument is used
        // for overloading purposes and indicates that 'TYPE' must fall under
        // 'bdeat_TypeCategory::NullableValue'.

    template <typename TYPE, typename ANY_CATEGORY>
    int encodeSelectionImp(const TYPE&        value,
                           const bsl::string& name,
                           ANY_CATEGORY);
        // Encode the specified 'value' as a selection with the specified
        // 'name' to the stream held by this encoder.  Return 0 on success, and
        // a non-zero value otherwise.  Note that the third argument is used
        // for overloading purposes and indicates that 'TYPE' does not fall
        // under any of the other overloads of 'encodeSelectionImp'.

    template <typename TYPE>
    int encodeSequenceAttributes(const TYPE& value);
        // Encode the attributes of the specified 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that 'TYPE' must fall under 'bdeat_TypeCategory::Sequence'.

    template <typename TYPE>
    int encodeSequenceElemTypes(const TYPE& value);
        // Encode, to the stream held by this encoder, an 'bsl::vector<char>'
        // that contains the 'bdem' element types that correspond to the 'bdem'
        // element types of the attributes in the specified 'value'.  Return 0
        // on success, and a non-zero value otherwise.  Note that 'TYPE' must
        // fall under 'bdeat_TypeCategory::Sequence'.

  private:
    // NOT IMPLEMENTED
    bdem_BdemEncoderUtil_Encoder(const bdem_BdemEncoderUtil_Encoder&);
    bdem_BdemEncoderUtil_Encoder& operator=(
                                          const bdem_BdemEncoderUtil_Encoder&);

  public:
    // CREATORS
    bdem_BdemEncoderUtil_Encoder(STREAM *stream, int bdemVersion);
        // Create a 'bdem'-compatible encoder using the specified 'stream' and
        // the specified 'bdemVersion'.

    // Generated by compiler:
    // ~bdem_BdemEncoderUtil_Encoder();

    // MANIPULATORS
    template <typename TYPE, typename INFO>
    int operator()(const TYPE& value, const INFO&);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.
        // Note that the second argument is passed by the accessor methods of
        // 'bdeat' types but is ignored by this visitor.

    template <typename TYPE>
    int operator()(const TYPE& value);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.

    template <typename TYPE>
    int encode(const TYPE& value);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.

    int encode(const bdet_DateTz& value);
    int encode(const bdet_DatetimeTz& value);
    int encode(const bdet_TimeTz& value);
        // Encode the specified non-modifiable 'value' to the stream held by
        // this encoder.  Return 0 on success, and a non-zero value otherwise.

    template <typename TYPE>
    int encodeSelection(const TYPE& value, const bsl::string& name);
        // Encode the specified 'value' as a selection (of a type that falls
        // under 'bdeat_TypeCategory::Choice') using the specified 'name' to
        // the stream held by this encoder.  Return 0 on success, and a
        // non-zero value otherwise.
};

              // ================================================
              // private class bdem_BdemEncoderUtil_NewLevelGuard
              // ================================================

class bdem_BdemEncoderUtil_NewLevelGuard {
    // This guard is used to maintain a counter that indicates the current
    // nested level in the encoder.  When constructed, the level number is
    // incremented.  When destructed, the level number is decremented.

    // PRIVATE DATA MEMBERS
    int *d_level_p;

  private:
    // NOT IMPLEMENTED
    bdem_BdemEncoderUtil_NewLevelGuard(
                                    const bdem_BdemEncoderUtil_NewLevelGuard&);
    bdem_BdemEncoderUtil_NewLevelGuard& operator=(
                                    const bdem_BdemEncoderUtil_NewLevelGuard&);

  public:
    // CREATORS
    bdem_BdemEncoderUtil_NewLevelGuard(int *level);

    ~bdem_BdemEncoderUtil_NewLevelGuard();
};

         // ==========================================================
         // private class bdem_BdemEncoderUtil_SelectArrayTypeCategory
         // ==========================================================

struct bdem_BdemEncoderUtil_NativeBdemArrayCategory   { };
struct bdem_BdemEncoderUtil_ExtendedBdemArrayCategory { };
struct bdem_BdemEncoderUtil_SequenceArrayCategory     { };
struct bdem_BdemEncoderUtil_ChoiceArrayCategory       { };
struct bdem_BdemEncoderUtil_OtherArrayCategory        { };

template <typename TYPE>
struct bdem_BdemEncoderUtil_SelectArrayTypeCategory {
    // This meta-function is used to obtain the array type category for the
    // parameterized 'TYPE'.

  private:
    typedef typename
    bdem_SelectBdemType<TYPE>::Type BdemArrayType;

    typedef typename
    bdeat_ArrayFunctions::ElementType<TYPE>::Type ElementType;

    enum {
        IS_ELEMENT_NULLABLE
            = bdeat_NullableValueFunctions::IsNullableValue<ElementType>::VALUE
    };

    BSLMF_ASSERT(!IS_ELEMENT_NULLABLE);

    enum {
        IS_NATIVE_BDEM_ARRAY_TYPE = bslmf_IsSame<TYPE, BdemArrayType>::VALUE
    };

    enum {
        IS_EXTENDED_BDEM_ARRAY_TYPE
                          = bslmf_IsSame<ElementType, bdet_DateTz>::VALUE     |
                            bslmf_IsSame<ElementType, bdet_DatetimeTz>::VALUE |
                            bslmf_IsSame<ElementType, bdet_TimeTz>::VALUE
    };

    enum {
        IS_ELEMENT_SEQUENCE
                      = bdeat_SequenceFunctions::IsSequence<ElementType>::VALUE
    };

    enum {
        IS_ELEMENT_CHOICE = bdeat_ChoiceFunctions::IsChoice<ElementType>::VALUE
    };

    enum {
        SELECTOR = IS_NATIVE_BDEM_ARRAY_TYPE   ? 0 :
                   IS_EXTENDED_BDEM_ARRAY_TYPE ? 1 :
                   IS_ELEMENT_SEQUENCE         ? 2 :
                   IS_ELEMENT_CHOICE           ? 3 : 4
    };

  public:
    typedef typename
    bslmf_Switch<SELECTOR, bdem_BdemEncoderUtil_NativeBdemArrayCategory,
                           bdem_BdemEncoderUtil_ExtendedBdemArrayCategory,
                           bdem_BdemEncoderUtil_SequenceArrayCategory,
                           bdem_BdemEncoderUtil_ChoiceArrayCategory,
                           bdem_BdemEncoderUtil_OtherArrayCategory>::Type Type;
};

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

                        // ---------------------------
                        // struct bdem_BdemEncoderUtil
                        // ---------------------------

// MANIPULATORS

template <typename STREAM, typename TYPE>
inline
STREAM& bdem_BdemEncoderUtil::encode(STREAM& stream, const TYPE& value)
{
    return encode(stream, value, bdem_BdemEncoderOptions());
}

template <typename STREAM, typename TYPE>
STREAM& bdem_BdemEncoderUtil::encode(STREAM&                        stream,
                                     const TYPE&                    value,
                                     const bdem_BdemEncoderOptions& options)
{
    if (!stream) {
        return stream;
    }

    int bdemVersion = options.bdemVersion();

    if (1 != bdemVersion && 2 != bdemVersion) {
        stream.invalidate();

        return stream;
    }

    bdem_BdemEncoderUtil_Encoder<STREAM> encoder(&stream, bdemVersion);

    if (0 != encoder.encode(value)) {
        stream.invalidate();
    }

    return stream;
}

template <typename TYPE>
inline
int bdem_BdemEncoderUtil::encode(bsl::streambuf *buffer, const TYPE& value)
{
    return encode(buffer, value, bdem_BdemEncoderOptions());
}

template <typename TYPE>
inline
int bdem_BdemEncoderUtil::encode(bsl::streambuf                 *buffer,
                                 const TYPE&                     value,
                                 const bdem_BdemEncoderOptions&  options)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    bdex_ByteOutStreamFormatter formatter(buffer);

    encode(formatter, value, options);

    return formatter ? BDEM_SUCCESS : BDEM_FAILURE;
}

template <typename TYPE>
inline
bsl::ostream& bdem_BdemEncoderUtil::encode(bsl::ostream& stream,
                                           const TYPE&   value)
{
    return encode(stream, value, bdem_BdemEncoderOptions());
}

template <typename TYPE>
inline
bsl::ostream& bdem_BdemEncoderUtil::encode(
                                        bsl::ostream&                  stream,
                                        const TYPE&                    value,
                                        const bdem_BdemEncoderOptions& options)
{
    if (!stream.good()) {
        return stream;
    }

    if (0 != encode(stream.rdbuf(), value, options)) {
        stream.setstate(bsl::ios_base::failbit);
    }

    return stream;
}

           // ------------------------------------------------------
           // private class bdem_BdemEncoderUtil_BindEncodeSelection
           // ------------------------------------------------------

// CREATORS

template <typename STREAM>
inline
bdem_BdemEncoderUtil_BindEncodeSelection<STREAM>::
                                      bdem_BdemEncoderUtil_BindEncodeSelection(
                                 bdem_BdemEncoderUtil_Encoder<STREAM> *encoder)
: d_encoder_p(encoder)
{
}

// MANIPULATORS

template <typename STREAM>
template <typename TYPE, typename INFO_TYPE>
inline
int bdem_BdemEncoderUtil_BindEncodeSelection<STREAM>::operator()(
                                                       const TYPE&      object,
                                                       const INFO_TYPE& info)
{
    return d_encoder_p->encodeSelection(object, info.name());
}

              // -----------------------------------------------
              // private class bdem_BdemEncoderUtil_BuildBitmaps
              // -----------------------------------------------

// PRIVATE MANIPULATORS

template <typename TYPE>
inline
void bdem_BdemEncoderUtil_BuildBitmaps::addMask(
                                             const TYPE& object,
                                             bdeat_TypeCategory::NullableValue)
{
    BSLS_ASSERT_SAFE(0 != d_mask);

    if (!bdeat_NullableValueFunctions::isNull(object)) {
        d_bitmaps[d_bitmaps.size()-1] |= d_mask;
    }
}

template <typename TYPE, typename ANY_CATEGORY>
inline
void bdem_BdemEncoderUtil_BuildBitmaps::addMask(const TYPE&, ANY_CATEGORY)
{
    BSLS_ASSERT_SAFE(0 != d_mask);

    d_bitmaps[d_bitmaps.size()-1] |= d_mask;
}

// CREATORS

inline
bdem_BdemEncoderUtil_BuildBitmaps::bdem_BdemEncoderUtil_BuildBitmaps()
: d_mask(bdem_BdemEncoderUtil_Constants::BDEM_FIRST_BIT_MASK)
{
}

// MANIPULATORS

template <typename TYPE, typename INFO>
int bdem_BdemEncoderUtil_BuildBitmaps::operator()(const TYPE& object,
                                                  const INFO&)
{
    enum { BDEM_SUCCESS = 0 };

    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    if (bdem_BdemEncoderUtil_Constants::BDEM_FIRST_BIT_MASK == d_mask) {
        d_bitmaps.push_back(0);
    }

    addMask(object, TypeCategory());

    d_mask >>= 1;

    if (0 == d_mask) {
        d_mask = bdem_BdemEncoderUtil_Constants::BDEM_FIRST_BIT_MASK;
    }

    return BDEM_SUCCESS;
}

// ACCESSORS

inline
const bsl::vector<unsigned int>&
bdem_BdemEncoderUtil_BuildBitmaps::bitmaps() const
{
    return d_bitmaps;
}

             // -------------------------------------------------
             // private class bdem_BdemEncoderUtil_BuildElemTypes
             // -------------------------------------------------

// CREATORS

inline
bdem_BdemEncoderUtil_BuildElemTypes::bdem_BdemEncoderUtil_BuildElemTypes()
{
}

// MANIPULATORS

template <typename TYPE, typename INFO>
inline
int bdem_BdemEncoderUtil_BuildElemTypes::operator()(const TYPE&, const INFO&)
{
    enum { BDEM_SUCCESS = 0 };

    d_elemTypes.push_back(bdem_SelectBdemType<TYPE>::VALUE);

    return BDEM_SUCCESS;
}

// ACCESSORS

inline
const bsl::vector<char>& bdem_BdemEncoderUtil_BuildElemTypes::elemTypes() const
{
    return d_elemTypes;
}

        // -----------------------------------------------------------
        // private class bdem_BdemEncoderUtil_EncodeAttributesWithMask
        // -----------------------------------------------------------

// CREATORS

template <typename STREAM>
inline
bdem_BdemEncoderUtil_EncodeAttributesWithMask<STREAM>::
                                 bdem_BdemEncoderUtil_EncodeAttributesWithMask(
                                 STREAM                               *stream,
                                 bdem_BdemEncoderUtil_Encoder<STREAM> *encoder,
                                 const bsl::vector<unsigned int>      *bitmaps)
: d_attributeIndex(0)
, d_bitmaps_p(bitmaps)
, d_encoder_p(encoder)
, d_stream_p(stream)
{
}

// MANIPULATORS

template <typename STREAM>
template <typename TYPE, typename INFO_TYPE>
inline
int bdem_BdemEncoderUtil_EncodeAttributesWithMask<STREAM>::operator()(
                                                            const TYPE& object,
                                                            const INFO_TYPE&)
{
    return execute(object);
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemEncoderUtil_EncodeAttributesWithMask<STREAM>::execute(
                                                            const TYPE& object)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    enum { BITMAP_FREQUENCY = 32 };

    int bitmapIndex = d_attributeIndex / BITMAP_FREQUENCY;

    BSLS_ASSERT_SAFE(bitmapIndex < d_bitmaps_p->size());

    unsigned int bitmap = (*d_bitmaps_p)[bitmapIndex];

    int bit = d_attributeIndex % BITMAP_FREQUENCY;

    if (0 == bit) {
        if (!d_stream_p->putUint32(bitmap)) {
            return BDEM_FAILURE;
        }
    }

    ++d_attributeIndex;

    typedef unsigned int bde_uint;

    unsigned int mask
        = bde_uint(bdem_BdemEncoderUtil_Constants::BDEM_FIRST_BIT_MASK) >> bit;

    if (0 == (bitmap & mask)) {
        // Compress attribute out of the stream.

        return BDEM_SUCCESS;
    }

    return d_encoder_p->encode(object);
}

                 // ------------------------------------------
                 // private class bdem_BdemEncoderUtil_Encoder
                 // ------------------------------------------

// PRIVATE MANIPULATORS

template <typename STREAM>
template <typename BDEM_TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeNullValue(
                                                         TypeHasBdetuNullValue)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    enum { BDEX_VERSION = 1 };

    if (!bdex_OutStreamFunctions::streamOut(
                                          *d_stream_p,
                                          bdetu_Unset<BDEM_TYPE>::unsetValue(),
                                          BDEX_VERSION)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename BDEM_TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeNullValue(
                                                       TypeHasNoBdetuNullValue)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    BSLMF_ASSERT((bdeat_ArrayFunctions::IsArray<BDEM_TYPE>::VALUE
               || bslmf_IsSame<BDEM_TYPE, bdem_List>::VALUE
               || bslmf_IsSame<BDEM_TYPE, bdem_Table>::VALUE));

    if (bdeat_ArrayFunctions::IsArray<BDEM_TYPE>::VALUE
     || bslmf_IsSame<BDEM_TYPE, bdem_List>::VALUE) {
        if (!d_stream_p->putLength(0)) {
            return BDEM_FAILURE;
        }
    }
    else {
        // Must be a table.
        // Note: might be ambiguous with array with 0 elements (see
        //       encodeArrayImp for sequence arrays)

        if (d_stream_p->putLength(0) && d_stream_p->putLength(0)) {
            return BDEM_FAILURE;
        }
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeImp(const TYPE& value,
                                                    bdeat_TypeCategory::Array)
{
    typedef typename
    bdem_BdemEncoderUtil_SelectArrayTypeCategory<TYPE>::Type ArrayTypeCategory;

    return encodeArrayImp(value, ArrayTypeCategory());
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeImp(const TYPE& value,
                                                    bdeat_TypeCategory::Choice)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    const int selectionId = bdeat_ChoiceFunctions::selectionId(value);

    bdem_BdemEncoderUtil_NewLevelGuard newLevelGuard(&d_level);

    if (bdeat_ChoiceFunctions::BDEAT_UNDEFINED_SELECTION_ID == selectionId) {
        // Stream out list with 1 element containing empty string.

        enum { NUM_ELEMENTS = 1 };

        if (!d_stream_p->putLength(NUM_ELEMENTS)
         || !d_stream_p->putInt8(bdem_ElemType::BDEM_STRING)
         || ( 2 == d_bdemVersion
           && 1 == d_level
           && !d_stream_p->putUint32(
                          bdem_BdemEncoderUtil_Constants::BDEM_FIRST_BIT_MASK))
         || !d_stream_p->putString("")) {
            return BDEM_FAILURE;                                      // RETURN
        }

        return BDEM_SUCCESS;                                          // RETURN
    }

    bdem_BdemEncoderUtil_BindEncodeSelection<STREAM> encodeSelection(this);

    return bdeat_ChoiceFunctions::accessSelection(value, encodeSelection);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeImp(
                                            const TYPE& value,
                                            bdeat_TypeCategory::CustomizedType)
{
    typedef typename
    bdeat_CustomizedTypeFunctions::BaseType<TYPE>::Type BaseType;

    return encode(bdeat_CustomizedTypeFunctions::convertToBaseType(value));
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeImp(
                                               const TYPE& value,
                                               bdeat_TypeCategory::Enumeration)
{
    int intValue;

    bdeat_EnumFunctions::toInt(&intValue, value);

    return encode(intValue);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeImp(
                                             const TYPE& value,
                                             bdeat_TypeCategory::NullableValue)
{
    if (!bdeat_NullableValueFunctions::isNull(value)) {
        return bdeat_NullableValueFunctions::accessValue(value, *this);
    }

    // If 2 == d_bdemVersion and 1 == d_level, we should never arrive here!

    BSLS_ASSERT_SAFE(2 != d_bdemVersion || 1 != d_level);

    typedef typename
    bdem_SelectBdemType<TYPE>::Type BdemType;

    typedef typename
    bslmf_If<bdetu_UnsetValueIsDefined<BdemType>::VALUE,
             TypeHasBdetuNullValue,
             TypeHasNoBdetuNullValue>::Type Toggle;

    return encodeNullValue<BdemType>(Toggle());
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeImp(
                                                  const TYPE& value,
                                                  bdeat_TypeCategory::Sequence)
{
    enum { BDEM_FAILURE = -1 };

    // Note: ambiguous with null sequence if numAttributes = 0
    if (0 != encodeSequenceElemTypes(value)) {
        return BDEM_FAILURE;
    }

    return encodeSequenceAttributes(value);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeImp(const TYPE& value,
                                                    bdeat_TypeCategory::Simple)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    // Using static_cast<BdemType> ensures that unsigned types will be
    // correctly cast to signed types when streamed out.  Also, enums will be
    // cast to int.

    typedef typename bdem_SelectBdemType<TYPE>::Type BdemType;

    enum { BDEX_VERSION = 1 };

#if defined(BSLS_PLATFORM__CMP_SUN) && (BSLS_PLATFORM__CMP_VER_MAJOR == 0x520)
    const TYPE otherValue = value;
    if (!bdex_OutStreamFunctions::streamOut(*d_stream_p,
                                            static_cast<BdemType>(otherValue),
                                            BDEX_VERSION)) {
        return BDEM_FAILURE;
    }
#else
    if (!bdex_OutStreamFunctions::streamOut(*d_stream_p,
                                            static_cast<BdemType>(value),
                                            BDEX_VERSION)) {
        return BDEM_FAILURE;
    }
#endif

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeArrayImp(
                                  const TYPE& value,
                                  bdem_BdemEncoderUtil_NativeBdemArrayCategory)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    enum { BDEX_VERSION = 1 };

    if (!bdex_OutStreamFunctions::streamOut(*d_stream_p,
                                            value,
                                            BDEX_VERSION)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeArrayImp(
                                      const TYPE& value,
                                      bdem_BdemEncoderUtil_ChoiceArrayCategory)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    const int numRows = static_cast<int>(bdeat_ArrayFunctions::size(value));

    if (!d_stream_p->putLength(1)
     || !d_stream_p->putInt8(bdem_ElemType::BDEM_LIST)
     || !d_stream_p->putLength(numRows)) {
        return BDEM_FAILURE;                                          // RETURN
    }

    bdem_BdemEncoderUtil_NewLevelGuard newLevelGuard(&d_level);

    for (int i = 0; i < numRows; ++i) {
        if (( 2 == d_bdemVersion
           && 1 == d_level
           && !d_stream_p->putUint32(
                          bdem_BdemEncoderUtil_Constants::BDEM_FIRST_BIT_MASK))
         || 0 != bdeat_ArrayFunctions::accessElement(value, *this, i)) {
            return BDEM_FAILURE;
        }
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeArrayImp(
                                const TYPE& value,
                                bdem_BdemEncoderUtil_ExtendedBdemArrayCategory)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    const int numRows = bdeat_ArrayFunctions::size(value);

    typedef typename
    bdeat_ArrayFunctions::ElementType<TYPE>::Type ElementType;

    bdem_BdemEncoderUtil_NewLevelGuard newLevelGuard(&d_level);

    // Encode type information.

    if (0 != encodeExtendedTypeElemTypes((ElementType*)0)
     || !d_stream_p->putLength(numRows)) {
        return BDEM_FAILURE;
    }

    typedef bdem_BdemEncoderUtil_Encoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(const ElementType&),
                               ThisClass*>       MemFn;

    // Encode elements.

    MemFn encodeValuesMemFn(&ThisClass::encodeExtendedTypeValue, this);

    for (int i = 0; i < numRows; ++i) {
        if (0 != bdeat_ArrayFunctions::accessElement(value,
                                                     encodeValuesMemFn,
                                                     i)) {
            return BDEM_FAILURE;                                      // RETURN
        }
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeArrayImp(
                                    const TYPE& value,
                                    bdem_BdemEncoderUtil_SequenceArrayCategory)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    const int numRows = static_cast<int>(bdeat_ArrayFunctions::size(value));

    // If there are no rows, then there is no Sequence object to traverse for
    // type information.  Put out [0, 0] representing an empty table with no
    // type information.
    // Note: this might be ambiguous with a null table (see encodeNullValue)

    if (0 == numRows) {
        if (!d_stream_p->putLength(0) || !d_stream_p->putLength(0)) {
            return BDEM_FAILURE;                                      // RETURN
        }
        return BDEM_SUCCESS;                                          // RETURN
    }

    // Encode type information.

    typedef typename
    bdeat_ArrayFunctions::ElementType<TYPE>::Type ElementType;

    typedef bdem_BdemEncoderUtil_Encoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(const ElementType&),
                               ThisClass*>       MemFn;

    MemFn encodeElemTypesMemFn(&ThisClass::encodeSequenceElemTypes, this);

    if (0 != bdeat_ArrayFunctions::accessElement(value,
                                                 encodeElemTypesMemFn,
                                                 0)
     || !d_stream_p->putLength(numRows)) {
        return BDEM_FAILURE;                                          // RETURN
    }

    // Encode elements.

    MemFn encodeAttributesMemFn(&ThisClass::encodeSequenceAttributes, this);

    for (int i = 0; i < numRows; ++i) {
        if (0 != bdeat_ArrayFunctions::accessElement(value,
                                                     encodeAttributesMemFn,
                                                     i)) {
            return BDEM_FAILURE;                                      // RETURN
        }
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeArrayImp(
                                       const TYPE& value,
                                       bdem_BdemEncoderUtil_OtherArrayCategory)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    const int length = static_cast<int>(bdeat_ArrayFunctions::size(value));

    if (!d_stream_p->putLength(static_cast<int>(value.size()))) {
        return BDEM_FAILURE;                                          // RETURN
    }

    for (int i = 0; i < length; ++i) {
        if (0 != bdeat_ArrayFunctions::accessElement(value, *this, i)) {
            return BDEM_FAILURE;                                      // RETURN
        }
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeExtendedTypeElemTypes(
                                                                 bdet_DateTz *)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    const char ELEM_TYPES[] = { bdem_ElemType::BDEM_DATE,
                                bdem_ElemType::BDEM_INT };
    const int  NUM_ELEMENTS = sizeof ELEM_TYPES / sizeof *ELEM_TYPES;

    if (!d_stream_p->putLength(NUM_ELEMENTS)
     || !d_stream_p->putArrayInt8(ELEM_TYPES, NUM_ELEMENTS)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeExtendedTypeElemTypes(
                                                             bdet_DatetimeTz *)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    const char ELEM_TYPES[] = { bdem_ElemType::BDEM_DATETIME,
                                bdem_ElemType::BDEM_INT };
    const int  NUM_ELEMENTS = sizeof ELEM_TYPES / sizeof *ELEM_TYPES;

    if (!d_stream_p->putLength(NUM_ELEMENTS)
     || !d_stream_p->putArrayInt8(ELEM_TYPES, NUM_ELEMENTS)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeExtendedTypeElemTypes(
                                                                 bdet_TimeTz *)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    const char ELEM_TYPES[] = { bdem_ElemType::BDEM_TIME,
                                bdem_ElemType::BDEM_INT };
    const int  NUM_ELEMENTS = sizeof ELEM_TYPES / sizeof *ELEM_TYPES;

    if (!d_stream_p->putLength(NUM_ELEMENTS)
     || !d_stream_p->putArrayInt8(ELEM_TYPES, NUM_ELEMENTS)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeExtendedTypeValue(
                                                      const bdet_DateTz& value)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    if (2 == d_bdemVersion && 1 == d_level) {
        if (!d_stream_p->putUint32(
                   bdem_BdemEncoderUtil_Constants::BDEM_FIRST_TWO_BITS_MASK)) {
            return BDEM_FAILURE;
        }
    }

    if (0 != encode(value.localDate())
     || 0 != encode(value.offset())) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeExtendedTypeValue(
                                                  const bdet_DatetimeTz& value)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    if (2 == d_bdemVersion && 1 == d_level) {
        if (!d_stream_p->putUint32(
                   bdem_BdemEncoderUtil_Constants::BDEM_FIRST_TWO_BITS_MASK)) {
            return BDEM_FAILURE;
        }
    }

    if (0 != encode(value.localDatetime())
     || 0 != encode(value.offset())) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeExtendedTypeValue(
                                                      const bdet_TimeTz& value)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    if (2 == d_bdemVersion && 1 == d_level) {
        if (!d_stream_p->putUint32(
                   bdem_BdemEncoderUtil_Constants::BDEM_FIRST_TWO_BITS_MASK)) {
            return BDEM_FAILURE;
        }
    }

    if (0 != encode(value.localTime())
     || 0 != encode(value.offset())) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeSelectionImp(
                                             const TYPE&        value,
                                             const bsl::string& name,
                                             bdeat_TypeCategory::NullableValue)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    if (2 == d_bdemVersion
     && 1 == d_level
     && bdeat_NullableValueFunctions::isNull(value)) {
        enum { NUM_ELEMENTS = 1 };

        if (!d_stream_p->putLength(NUM_ELEMENTS)
         || !d_stream_p->putInt8(bdem_ElemType::BDEM_STRING)
         || !d_stream_p->putUint32(
                           bdem_BdemEncoderUtil_Constants::BDEM_FIRST_BIT_MASK)
         || !d_stream_p->putString(name)) {
            return BDEM_FAILURE;
        }

        return BDEM_SUCCESS;
    }

    // If control flows here, that means 2 != d_bdemVersion OR 1 != d_level OR
    // (1 == d_level and selection != null).  So, always output 2 elements.

    typedef typename
    bdeat_NullableValueFunctions::ValueType<TYPE>::Type ValueType;
    typedef bdef_Function<int (*)(const ValueType&)>    Functor;

    typedef bdem_BdemEncoderUtil_Encoder<STREAM> ThisClass;
    typedef bdef_MemFnInstance<int (ThisClass::*)(const ValueType&,
                                                  const bsl::string&),
                               ThisClass*>               MemFn;

    MemFn memFn(&ThisClass::encodeSelection, this);

    using bdef_PlaceHolders::_1;

    Functor encodeFunctor = bdef_BindUtil::bind(memFn, _1, name);

    return bdeat_NullableValueFunctions::accessValue(value, encodeFunctor);
}

template <typename STREAM>
template <typename TYPE, typename ANY_CATEGORY>
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeSelectionImp(
                                                      const TYPE&        value,
                                                      const bsl::string& name,
                                                      ANY_CATEGORY)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    enum { NUM_ELEMENTS = 2 };

    if (!d_stream_p->putLength(NUM_ELEMENTS)
     || !d_stream_p->putInt8(bdem_ElemType::BDEM_STRING)
     || !d_stream_p->putInt8(bdem_SelectBdemType<TYPE>::VALUE)
     || ( 2 == d_bdemVersion
       && 1 == d_level
       && !d_stream_p->putUint32(
                     bdem_BdemEncoderUtil_Constants::BDEM_FIRST_TWO_BITS_MASK))
     || !d_stream_p->putString(name)
     || 0 != encode(value)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeSequenceAttributes(
                                                             const TYPE& value)
{
    enum { BDEM_FAILURE = -1 };

    bdem_BdemEncoderUtil_NewLevelGuard newLevelGuard(&d_level);

    bdem_BdemEncoderUtil_BuildBitmaps buildBitmaps;

    if (2 == d_bdemVersion && 1 == d_level) {
        if (0 != bdeat_SequenceFunctions::accessAttributes(value,
                                                           buildBitmaps)) {
            return BDEM_FAILURE;
        }
        const bsl::vector<unsigned int>& bitmaps = buildBitmaps.bitmaps();

        bdem_BdemEncoderUtil_EncodeAttributesWithMask<STREAM>
                                           encodeAttributesWithMask(d_stream_p,
                                                                    this,
                                                                    &bitmaps);

        return bdeat_SequenceFunctions::accessAttributes(
                                                     value,
                                                     encodeAttributesWithMask);
    }
    else {
        return bdeat_SequenceFunctions::accessAttributes(value, *this);
    }
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeSequenceElemTypes(
                                                             const TYPE& value)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    bdem_BdemEncoderUtil_BuildElemTypes buildElemTypes;

    if (0 != bdeat_SequenceFunctions::accessAttributes(value,
                                                       buildElemTypes)) {
        return BDEM_FAILURE;
    }

    if (0 != encode(buildElemTypes.elemTypes())) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

// CREATORS

template <typename STREAM>
inline
bdem_BdemEncoderUtil_Encoder<STREAM>::bdem_BdemEncoderUtil_Encoder(
                                                           STREAM *stream,
                                                           int     bdemVersion)
: d_bdemVersion(bdemVersion)
, d_level(0)
, d_stream_p(stream)
{
}

// MANIPULATORS

template <typename STREAM>
template <typename TYPE, typename INFO>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::operator()(const TYPE& value,
                                                     const INFO&)
{
    return encode(value);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::operator()(const TYPE& value)
{
    return encode(value);
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encode(const TYPE& value)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return encodeImp(value, TypeCategory());
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encode(const bdet_DateTz& value)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    bdem_BdemEncoderUtil_NewLevelGuard newLevelGuard(&d_level);

    if (0 != encodeExtendedTypeElemTypes((bdet_DateTz*)0)
     || 0 != encodeExtendedTypeValue(value)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encode(const bdet_DatetimeTz& value)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    bdem_BdemEncoderUtil_NewLevelGuard newLevelGuard(&d_level);

    if (0 != encodeExtendedTypeElemTypes((bdet_DatetimeTz*)0)
     || 0 != encodeExtendedTypeValue(value)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encode(const bdet_TimeTz& value)
{
    enum { BDEM_SUCCESS = 0, BDEM_FAILURE = -1 };

    bdem_BdemEncoderUtil_NewLevelGuard newLevelGuard(&d_level);

    if (0 != encodeExtendedTypeElemTypes((bdet_TimeTz*)0)
     || 0 != encodeExtendedTypeValue(value)) {
        return BDEM_FAILURE;
    }

    return BDEM_SUCCESS;
}

template <typename STREAM>
template <typename TYPE>
inline
int bdem_BdemEncoderUtil_Encoder<STREAM>::encodeSelection(
                                                      const TYPE&        value,
                                                      const bsl::string& name)
{
    typedef typename
    bdeat_TypeCategory::Select<TYPE>::Type TypeCategory;

    return encodeSelectionImp(value, name, TypeCategory());
}

              // ------------------------------------------------
              // private class bdem_BdemEncoderUtil_NewLevelGuard
              // ------------------------------------------------

// CREATORS

inline
bdem_BdemEncoderUtil_NewLevelGuard::bdem_BdemEncoderUtil_NewLevelGuard(
                                                                    int *level)
: d_level_p(level)
{
    BSLS_ASSERT_SAFE(d_level_p);
    ++(*d_level_p);
}

inline
bdem_BdemEncoderUtil_NewLevelGuard::~bdem_BdemEncoderUtil_NewLevelGuard()
{
    --(*d_level_p);
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2005
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
