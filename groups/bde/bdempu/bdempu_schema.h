// bdempu_schema.h              -*-C++-*-
#ifndef INCLUDED_BDEMPU_SCHEMA
#define INCLUDED_BDEMPU_SCHEMA

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Convert 'bdem' schema objects to/from textual representations.
//
//@DEPRECATED: Use 'bdem_schema' and 'baexml_schemaparser' instead.
//
//@CLASSES:
//  bdempu_Schema: namespace for 'bdem' schema parser/generator functions
//
//@SEE_ALSO: bdem_schema
//
//@AUTHOR: John Lakos (jlakos)
//
//@DESCRIPTION: This component provides utility functions for parsing and
// generating textual representations of objects of type 'bdem_Schema'.  C- and
// C++-style comments along with character-string-literal escape sequences are
// fully supported.  Whitespace, except within quoted strings, is ignored.
//
// NOTE: The nullability attribute of all fields of 'bdem_Schema' objects that
// are generated by this component is determined as follows:
//..
//  field type          nullability attribute
//  ---------------     ---------------------
//  'BDEM_LIST'         'false'
//  all other types     'true'
//..
// This corresponds to the behavior of 'bdem_schema' prior to BDE 1.19.  That
// legacy behavior is preserved here as it is expected of the (very few) legacy
// applications that use this component.
//
// The following two subsections describe the grammar defining the parsing
// rules.
//
///DEFINITION OF SYMBOLS USED IN PRODUCTION RULES
///----------------------------------------------
//
// The following grammar is used to specify regular expressions:
//..
//   .     A period (.) is a one-character RE (Regular Expression) that matches
//         any character except new-line.
//
//   []    A non-empty string of characters enclosed in square brackets ([]) is
//         a one-character RE that matches any single character in that string.
//         If, however, the first character of the string is a circumflex (^),
//         the one-character RE matches any character *except* new-line and the
//         remaining characters in the string.  The ^ has this special meaning
//         only if it occurs first in the string.  The minus (-) may be used
//         to indicate a range of consecutive characters; for example, [0-9]
//         is equivalent to [0123456789].  The - loses this special meaning if
//         it occurs first (after an initial ^, if any) or last in the string.
//         The right square bracket (]) does not terminate such a string when
//         it is the first character within it (after an initial ^, if any);
//         for example, []a-f] matches either a right square bracket (]) or
//         one of the ASCII letters a through f inclusive.
//
//   ^     Matches the beginning of the string.  See the paragraph above for
//         special interpretation of the '^' when it is inside a "[]".
//
//   $     Matches the end of the string.
//
//   \n    Matches a newline.
//
//   -     Within brackets the minus means through.  For example, [a-z] is
//         equivalent to [abcd...xyz].  The - can appear as itself only if used
//         as the first or last character.  For example, the character class
//         expression []-] matches the characters ] and -.
//
//   *     A regular expression followed by * means zero or more times.
//
//   +     A regular expression followed by + means one or more times.  For
//         example, [0-9]+ is equivalent to [0-9][0-9]*.
//
//   ?     A regular expression followed by ? means zero times or one time.
//
//   |     Logical OR between two expressions means one must be present.
//
//   {m} {m,} {m, u} Integer values enclosed in {} indicate the number of times
//         the preceding regular expression is to be applied.  The value m is
//         the minimum number and u is the maximum.  If only m is present (that
//         is, {m}), it indicates the exact number of times the regular
//         expression is to be applied.  The value {m,} is analogous to
//         {m, infinity}.  The plus (+) and star (*) operations are
//         equivalent to {1,} and {0,} respectively.
//
//   ( ... ) Parentheses are used for grouping.  An operator, for example, *,
//         +, {}, can work on a single character or on a regular expression
//         enclosed in parentheses.  For example, (a*(cb+)*)$.
//
//    \    Backslash can escape any of the symbols defined above, as well as
//         single characters that would be escaped in a C-style string.
//..
///PRODUCTION RULES FOR PARSING FUNCTIONS
///--------------------------------------
//..
// <WHITESPACE>  ::= any character for which isspace(char) returns 'true', or
//                   any legal C- or C++-style comment.
// <NONWHITESPACE> ::= any character for which isspace(char) returns 'false'.
// <EOL>          ::= End of line, or ASCII 0.
// <SCHEMA_VALUE>   ::= '{' (<WHITESPACE>*<RECORD>)*<WHITESPACE>* '}'
// <RECORD>         ::= "RECORD" <WHITESPACE>* <NAME>? <WHITESPACE>*
//                    '{' (<WHITESPACE>* <FIELD>)* <WHITESPACE>* '}'
// <FIELD>          ::= <ELEMENT_TYPE> <WHITESPACE>* <NAME>? <WHITESPACE)* ';'
//                    | "RECORD" <WHITESPACE>* <CONSTRAINT> <WHITESPACE>*
//                      <NAME>? <WHITESPACE>* ';'
//                    | "RECORD_ARRAY" <WHITESPACE>* <CONSTRAINT> <WHITESPACE>*
//                      <NAME>? <WHITESPACE>* ';'
// <CONSTRAINT>     ::=  '<' <WHITESPACE>* <RTYPE_LOCATOR> <WHITESPACE>* '>'
// <RTYPE_LOCATOR>  ::= <STRING> | <INTEGER_LOCATOR>
// <INTEGER_LOCATOR>::= '{' <WHITESPACE>* <INDEX> <WHITESPACE>* '}'
// <INDEX>          ::= non-negative integer <= INT_MAX: "[0-9]+"
// <ELEMENT_TYPE>   ::=     "CHAR"        |     "CHAR_ARRAY"
//                    |    "SHORT"        |    "SHORT_ARRAY"
//                    |      "INT"        |      "INT_ARRAY"
//                    |    "INT64"        |    "INT64_ARRAY"
//                    |    "FLOAT"        |    "FLOAT_ARRAY"
//                    |   "DOUBLE"        |   "DOUBLE_ARRAY"
//                    |   "STRING"        |   "STRING_ARRAY"
//                    | "DATETIME"        | "DATETIME_ARRAY"
//                    |     "DATE"        |     "DATE_ARRAY"
//                    |     "TIME"        |     "TIME_ARRAY"
//                    |     "LIST"        |          "TABLE"
//..
///EXAMPLE
///-------
// A schema ('bdem_Schema') is a value-semantic description of a hierarchical
// collection of record definitions; each record definition contains a
// sequence of field definitions, and each field definition specifies one of
// the 22 'bdem' element types defined in the 'bdem_elemtype' component plus
// an optional constraint if the 'bdem' type is either LIST or TABLE.  An
// empty schema is represented textually as { }.  The following schema
// illustrates common syntactic features of the textual representation.
//..
//  {
//      RECORD "Point" {                        // record definition {0}
//          INT "x";
//          INT "y";
//      }
//      RECORD Rectangle {                      // record definition {1}
//          RECORD<"Point"> "lowerLeft";
//          RECORD< Point >  upperRight;
//          STRING color;
//      }
//      RECORD Polygon {                        // record definition {2}
//          RECORD_ARRAY<Point> vertices;
//          STRING color;
//      }
//      RECORD {                                // record definition {3}
//          INT ;
//          INT ;
//      }
//      RECORD "Rectangle 2" {                  // record definition {4}
//          RECORD<{3}> "lower left";
//          RECORD<{3}> "upper right";
//          INT "color code";
//      }
//      RECORD {                                // record definition {5}
//          RECORD_ARRAY < { 0 } > vertices ;
//          STRING
//            "color"
//          ;
//      }
//      RECORD {                                // record definition {6}
//          RECORD_ARRAY<{0}> vertices;
//          STRING "color";
//      }
//  }
//..
// In this example, the first record definition (labeled '{0}') identifies a
// (user-defined) construct named "Point" as two integer fields named "x"
// and "y", respectively.  The strings representing a name can be either
// quoted or unquoted (unless they contain embedded whitespace, in which case
// they *must* be quoted).
//
// Record definition '{1}' illustrates the way a record definition may be
// defined hierarchically.  This definition, named "Rectangle", is defined as
// having two fields (named "lowerLeft" and "upperRight") of type defined by
// the record definition in this schema whose name is "Point" (i.e., record
// definition '{0}') and a third field named "color" of type STRING.  A field
// of type RECORD<"Point"> corresponds to the LIST data type; we say that the
// elements in the LIST are "constrained" to conform to the field definitions
// of "Point".
//
// Record definition '{2}' also illustrates the way in which to define one
// record definition using another, this time for an array.  This record
// definition, named "Polygon", contains a field named "vertices" of a type
// that is conceptually an array of (zero or more) instances of the record
// type whose name is "Point".  Like Rectangle, Polygon also contains a field
// named "color" of type STRING.  (Notice that none of the names -- including
// the constraint-name "Point" -- needs to be quoted.) A field of type
// RECORD_ARRAY<Point> corresponds to the TABLE data type; we say that the
// columns in the TABLE are constrained to conform to the field types of
// "Point".
//
// Record definition '{3}' illustrates that all record-definition and
// field-definition names are optional.  The structure of record definition
// '{3}' is, however, identical to that of record definition '{0}'.  We cannot
// refer to record definition '{3}' by name, but we can refer to it by its
// integer locator (i.e., '{3}').
//
// Record definition '{4}' demonstrates how to refer to an unnamed record via
// its integer locator.  Notice that names with embedded spaces are permitted
// if quoted.
//
// Record definition '{5}', apart from its (missing) name, is defined
// identically to record definition '{2}'; the additional white space is
// irrelevant.  Note that record-definition names within schemas (as well as
// field names within record definitions) must be unique.
//
// Record definition '{6}' is defined identically to record definition '{2}'.
// Note that each record definition within a schema has unique identity (e.g.,
// its index).

#ifndef INCLUDED_BDESCM_VERSION
#include <bdescm_version.h>
#endif

#ifndef INCLUDED_BDEM_SCHEMA
#include <bdem_schema.h>
#endif

#ifndef INCLUDED_BDEPU_NTYPESPARSER
#include <bdepu_ntypesparser.h>
#endif

#ifndef INCLUDED_BDEPU_PARSERIMPUTIL
#include <bdepu_parserimputil.h>
#endif

#ifndef INCLUDED_BDEPU_TYPESPARSER
#include <bdepu_typesparser.h>
#endif

#ifndef INCLUDED_BSL_VECTOR
#include <bsl_vector.h>
#endif


namespace BloombergLP {

class bdem_FieldDef;
class bdem_RecordDef;

                        // ====================
                        // struct bdempu_Schema
                        // ====================

struct bdempu_Schema {
    // This struct provides a namespace for pure procedures that parse and
    // generate textual representations of 'bdem_Schema' objects.  C- and
    // C++-style comments and character-string-literal escape sequences are
    // recognized.  Whitespace, except within quoted strings, is ignored.

  private:
    // PRIVATE CLASS METHODS

                        //--- Parse Functions ---

    static
    int parseField(const char         **endPos,
                   bdem_RecordDef      *result,
                   const char          *inputString,
                   const bdem_Schema&   schema);
        // Parse the specified 'inputString' for a sequence of characters
        // matching the EBNF description of <FIELD> and place in the
        // specified 'result' the corresponding value.  Store in the
        // specified '*endPos' the address of the non-modifiable character
        // (in 'inputString') immediately following the successfully
        // parsed text, or the position at which the parse failure was
        // detected.  Return zero on success, and a non-zero value otherwise.
        // The value of '*result' is undefined if a parse failure occurs.
        // For constrained fields, the parse will fail if the locator in the
        // field's constraint refers to a record at an index position that
        // is not at or below the record in which the field's definition
        // is found.  The behavior is undefined if any argument is 0.

    static
    int parseRecord(const char  **endPos,
                    bdem_Schema  *result,
                    const char   *inputString);
        // Parse the specified 'inputString' for a sequence of characters
        // matching the EBNF description of <RECORD> and place in the
        // specified 'result' the corresponding value.  Store in the
        // specified '*endPos' the address of the non-modifiable character
        // (in 'inputString') immediately following the successfully parsed
        // test, or the position at which the parse failure was detected.
        // Return zero on success, and a non-zero value otherwise.  It is a
        // parse failure if (1) any field name in the record is not unique,
        // or (2) any locator in a constrained field in this record refers to
        // a record of same-schema index not less than or equal to the index
        // of this record, or a record not defined in the same schema.

                        //--- Generate Functions ---

    static
    void generateRecordDef(bsl::vector<char>  *buffer,
                           const bdem_Schema&  value,
                           int                 index,
                           int                 level,
                           int                 spacesPerLevel);
        // Format the record definition in the specified 'value' at the
        // specified index and append the result to the specified 'buffer'.
        // Indent the value by number of spaces calculated by the product of
        // the specified 'level' and specified 'spaces'.  The behavior is
        // undefined unless 0 <= 'level' and 0 <= 'spaces'.

  public:
    // CLASS METHODS

                        //--- Parse Functions ---

    static
    int parseSchema(const char  **endPos,
                    bdem_Schema  *result,
                    const char   *inputString);
        // Parse the specified 'inputString' for a sequence of characters
        // matching the EBNF description of <SCHEMA_VALUE> and place in
        // the specified 'result' the corresponding value.  Store in the
        // specified '*endPos' the address of the non-modifiable character (in
        // 'inputString') immediately following the successfully parsed text,
        // or the position at which the parse failure was detected.  Return
        // zero on success, and a non-zero value otherwise.  The value of
        // '*result' is undefined if a parse failure occurs.  The behavior
        // is undefined if any argument is 0.  Note that it is a parse
        // failure unless (1) all field definition names within a given
        // record type as well as all record type names within a given schema
        // are unique, (2) each locator in a constrained field refers to a
        // record type at an index position that is at or below the current
        // record type, and (3) each integer value is within the range
        // representable on the target platform.

                        //--- Generate Functions ---

    static
    void generateSchema(bsl::vector<char>  *buffer,
                        const bdem_Schema&  value,
                        int                 level = 0,
                        int                 spacesPerLevel = 4);
        // Format the specified schema 'value' using the (absolute value of)
        // the optionally specified indentation 'level' and append the result
        // to the specified 'buffer' while maintaining null-character
        // termination.  If 'level' is specified, optionally specify
        // 'spacesPerLevel', the non-negative number of spaces per indentation
        // level for this object.  Making 'level' negative suppresses
        // indentation for the first line only.  The behavior is undefined
        // unless 0 <= spacesPerLevel.  Note that 'value' is output as a
        // textual representation that is parsable by the corresponding
        // 'parseSchema' function.

    static
    void generateSchemaRaw(bsl::vector<char>  *buffer,
                           const bdem_Schema&  value,
                           int                 level = 0,
                           int                 spacesPerLevel = 4);
        // Format the specified schema 'value' using the (absolute value of)
        // the optionally specified indentation 'level' and append the result
        // to the specified 'buffer'.  If 'level' is specified, optionally
        // specify 'spacesPerLevel', the non-negative number of spaces per
        // indentation level for this object.  Making 'level' negative
        // suppresses indentation for the first line only.  The behavior is
        // undefined unless 0 <= spacesPerLevel.  Note that this method is
        // similar to 'generateSchema' except that no trailing null is ever
        // removed or supplied.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2002
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
