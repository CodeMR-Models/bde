// bdetu_time.t.cpp                                                   -*-C++-*-
#include <bdetu_time.h>

#include <bsl_cstdlib.h>
#include <bsl_iostream.h>
#include <bsl_strstream.h>

using namespace BloombergLP;
using namespace bsl;  // automatically added by script

//=============================================================================
//                             TEST PLAN
//-----------------------------------------------------------------------------
//                              Overview
//                              --------
// The component under test consists of a static member function (pure
// procedure) that computes a hash value for 'time's.  The general plan is that
// the method is tested against a set of tabulated test vectors.
//-----------------------------------------------------------------------------
// [ 3] static bdet_Time convertFromHHMM(int timeValue);
// [ 4] static bdet_Time convertFromHHMMSS(int timeValue);
// [ 5] static bdet_Time convertFromHHMMSSmmm(int timeValue);
// [ 6] static int convertToHHMM(const bdet_Time& timeValue);
// [ 6] static int convertToHHMMSS(const bdet_Time& timeValue);
// [ 6] static int convertToHHMMSSmmm(const bdet_Time& timeValue);
// [ 3] static bool isValidHHMM(int timeValue);
// [ 4] static bool isValidHHMMSS(int timeValue);
// [ 5] static bool isValidHHMMSSmmm(int timeValue);
// [ 1] static int hash(const bdet_Time& value, int size);  CONCERN: value
// [ 2] static int hash(const bdet_Time& value, int size);  CONCERN:
//                                                                 distribution
//-----------------------------------------------------------------------------
// [ 8] USAGE EXAMPLE
//-----------------------------------------------------------------------------

//=============================================================================
//                      STANDARD BDE ASSERT TEST MACRO
//-----------------------------------------------------------------------------
static int testStatus = 0;

static void aSsErT(int c, const char *s, int i)
{
    if (c) {
        cout << "Error " << __FILE__ << "(" << i << "): " << s
             << "    (failed)" << endl;
        if (0 <= testStatus && testStatus <= 100) ++testStatus;
    }
}

#define ASSERT(X) { aSsErT(!(X), #X, __LINE__); }

//=============================================================================
//                  STANDARD BDE LOOP-ASSERT TEST MACROS
//-----------------------------------------------------------------------------
#define LOOP_ASSERT(I,X) { \
   if (!(X)) { cout << #I << ": " << I << "\n"; aSsErT(1, #X, __LINE__); }}

#define LOOP2_ASSERT(I,J,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " \
              << J << "\n"; aSsErT(1, #X, __LINE__); } }

#define LOOP3_ASSERT(I,J,K,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" \
              << #K << ": " << K << "\n"; aSsErT(1, #X, __LINE__); } }

#define LOOP4_ASSERT(I,J,K,L,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" << \
       #K << ": " << K << "\t" << #L << ": " << L << "\n"; \
       aSsErT(1, #X, __LINE__); } }

#define LOOP5_ASSERT(I,J,K,L,M,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" << \
       #K << ": " << K << "\t" << #L << ": " << L << "\t" << \
       #M << ": " << M << "\n"; \
       aSsErT(1, #X, __LINE__); } }

#define LOOP6_ASSERT(I,J,K,L,M,N,X) { \
   if (!(X)) { cout << #I << ": " << I << "\t" << #J << ": " << J << "\t" << \
       #K << ": " << K << "\t" << #L << ": " << L << "\t" << \
       #M << ": " << M << "\t" << #N << ": " << N << "\n"; \
       aSsErT(1, #X, __LINE__); } }

//=============================================================================
//                  SEMI-STANDARD TEST OUTPUT MACROS
//-----------------------------------------------------------------------------
#define P(X) cout << #X " = " << (X) << endl; // Print identifier and value.
#define Q(X) cout << "<| " #X " |>" << endl;  // Quote identifier literally.
#define P_(X) cout << #X " = " << (X) << ", "<< flush; // P(X) without '\n'
#define L_ __LINE__                           // current Line number
#define T_ cout << "\t" << flush;             // Print a tab (w/o newline)

//=============================================================================
//                  GLOBAL TYPEDEFS/CONSTANTS FOR TESTING
//-----------------------------------------------------------------------------

typedef bdetu_Time Util;

//=============================================================================
//                              MAIN PROGRAM
//-----------------------------------------------------------------------------

int main(int argc, char *argv[])
{
    int test = argc > 1 ? atoi(argv[1]) : 0;
    int verbose = argc > 2;
    int veryVerbose = argc > 3;
    // int veryVeryVerbose = argc > 4;

    cout << "TEST " << __FILE__ << " CASE " << test << endl;;

    switch (test) { case 0:  // Zero is always the leading case.
      case 7: {
        // --------------------------------------------------------------------
        // TESTING USAGE EXAMPLE
        //   This will test the usage examples provided in the component header
        //   file.
        //
        // Concerns:
        //   The usage examples provided in the component header file must
        //   compile, link, and run on all platforms as shown.
        //
        // Plan:
        //   Incorporate usage example from header into driver, remove leading
        //   comment characters, and replace 'assert' with 'ASSERT'.
        //
        // Testing:
        //   Usage example.
        // --------------------------------------------------------------------

        if (verbose) cout << "\nTesting Usage Example"
                          << "\n=====================" << endl;

///Usage
///------
// Following are examples illustrating basic use of this component.
//

if (verbose) bsl::cout << "\nUsage Example 1" << endl;

///Example 1
///- - - - -
// The following snippet of code demonstrates how to use 'bdetu_Time' to
// convert from an integer representation of time in "HHMMSSmmm" format to a
// 'bdet_Time':
//..
    //      format: HHMMSSmmm
    int timeValue =  34502789;

    bdet_Time result = bdetu_Time::convertFromHHMMSSmmm(timeValue);

if (veryVerbose)
    bsl::cout << result << bsl::endl;
//..
// The code above produces the following on 'stdout':
//..
//  03:45:02.789
//..
// Note that 'bdetu_Time' provides methods that can be used to validate
// integral time values before passing them to the various "convert" methods.
// For example:
//..
    ASSERT( bdetu_Time::isValidHHMMSSmmm(timeValue));

    //         format: HHMMSSmmm
    int badTimeValue =  36102789;

    ASSERT(!bdetu_Time::isValidHHMMSSmmm(badTimeValue));
//..
//

if (verbose) bsl::cout << "\nUsage Example 2" << endl;

///Example 2
///- - - - -
// The following snippet of code demonstrates how to use 'bdetu_Time' to
// convert from a 'bdet_Time' to an integer representation of time in "HHMM",
// "HHMMSS", and "HHMMSSmmm" formats:
//..
    bdet_Time time(3, 45, 2, 789);
    int       timeHHMM      = bdetu_Time::convertToHHMM(time);
    int       timeHHMMSS    = bdetu_Time::convertToHHMMSS(time);
    int       timeHHMMSSmmm = bdetu_Time::convertToHHMMSSmmm(time);

if (veryVerbose) {
    bsl::cout << "Time in HHMM:      " << timeHHMM      << bsl::endl;
    bsl::cout << "Time in HHMMSS:    " << timeHHMMSS    << bsl::endl;
    bsl::cout << "Time in HHMMSSmmm: " << timeHHMMSSmmm << bsl::endl;
}
//..
// The code above produces the following on 'stdout':
//..
//  Time in HHMM:      345
//  Time in HHMMSS:    34502
//  Time in HHMMSSmmm: 34502789
//..
// Note that the millisecond and/or second fields of 'bdet_Time' are ignored
// depending on the conversion method that is called.

      } break;
      case 6: {
        // --------------------------------------------------------------------
        // TESTING convertToHHMMSS, convertToHHMMSSmmm, convertToHHMM:
        //   Verify the conversion is correct
        //
        // Plan:
        //   Specify a set of test vectors and verify the return value.
        //
        // Testing:
        //   static int convertToHHMM(const bdet_Time& timeValue);
        //   static int convertToHHMMSS(const bdet_Time& timeValue);
        //   static int convertToHHMMSSmmm(const bdet_Time& timeValue);
        // --------------------------------------------------------------------

        if (verbose) {
            cout << endl
                 << "Testing 'convertToHHMMSS', 'convertToHHMMSSmmm', "
                 << "'convertToHHMM'" << endl
                 << "================================================="
                 << "===============" << endl;
        }

        static const struct {
            int d_lineNum;  // source line number
            int d_hr;       // input hour field
            int d_min;      // input min field
            int d_sec;      // input sec field
            int d_ms;       // input ms field
            int d_hhmm;     // expected hhmm output
            int d_hhmmss;   // expected hhmmss output
            int d_hhmmssmmm;// expected hhmmssmmm output

        } DATA[] = {
            //      <----- input ---->    <------- result ------>
            //lin   hr  min  sec    ms    HHMM  HHMMSS  HHMMSSmmm
            //---   --  ---  ---  ----    ----  ------  ---------
            { L_,    0,   0,   0,    0,      0,      0,         0 },
            { L_,    0,   0,   0,    1,      0,      0,         1 },
            { L_,    0,   0,   0,    2,      0,      0,         2 },
            { L_,    0,   0,   0,    9,      0,      0,         9 },
            { L_,    0,   0,   0,   10,      0,      0,        10 },
            { L_,    0,   0,   0,   11,      0,      0,        11 },
            { L_,    0,   0,   0,   99,      0,      0,        99 },
            { L_,    0,   0,   0,  100,      0,      0,       100 },
            { L_,    0,   0,   0,  101,      0,      0,       101 },
            { L_,    0,   0,   0,  998,      0,      0,       998 },
            { L_,    0,   0,   0,  999,      0,      0,       999 },
            { L_,    0,   0,   1,    0,      0,      1,      1000 },
            { L_,    0,   0,   1,    1,      0,      1,      1001 },
            { L_,    0,   0,   1,    2,      0,      1,      1002 },
            { L_,    0,   0,   1,    9,      0,      1,      1009 },
            { L_,    0,   0,   1,   10,      0,      1,      1010 },
            { L_,    0,   0,   1,   11,      0,      1,      1011 },
            { L_,    0,   0,   1,   99,      0,      1,      1099 },
            { L_,    0,   0,   1,  100,      0,      1,      1100 },
            { L_,    0,   0,   1,  101,      0,      1,      1101 },
            { L_,    0,   0,   1,  998,      0,      1,      1998 },
            { L_,    0,   0,   1,  999,      0,      1,      1999 },
            { L_,    0,   0,  59,    0,      0,     59,     59000 },
            { L_,    0,   0,  59,    1,      0,     59,     59001 },
            { L_,    0,   0,  59,    2,      0,     59,     59002 },
            { L_,    0,   0,  59,    9,      0,     59,     59009 },
            { L_,    0,   0,  59,   10,      0,     59,     59010 },
            { L_,    0,   0,  59,   11,      0,     59,     59011 },
            { L_,    0,   0,  59,   99,      0,     59,     59099 },
            { L_,    0,   0,  59,  100,      0,     59,     59100 },
            { L_,    0,   0,  59,  101,      0,     59,     59101 },
            { L_,    0,   0,  59,  998,      0,     59,     59998 },
            { L_,    0,   0,  59,  999,      0,     59,     59999 },
            { L_,    0,   1,   0,    0,      1,    100,    100000 },
            { L_,    0,   1,   0,    1,      1,    100,    100001 },
            { L_,    0,   1,   0,    2,      1,    100,    100002 },
            { L_,    0,   1,   0,    9,      1,    100,    100009 },
            { L_,    0,   1,   0,   10,      1,    100,    100010 },
            { L_,    0,   1,   0,   11,      1,    100,    100011 },
            { L_,    0,   1,   0,   99,      1,    100,    100099 },
            { L_,    0,   1,   0,  100,      1,    100,    100100 },
            { L_,    0,   1,   0,  101,      1,    100,    100101 },
            { L_,    0,   1,   0,  998,      1,    100,    100998 },
            { L_,    0,   1,   0,  999,      1,    100,    100999 },
            { L_,    0,   1,   1,    0,      1,    101,    101000 },
            { L_,    0,   1,   1,    1,      1,    101,    101001 },
            { L_,    0,   1,   1,    2,      1,    101,    101002 },
            { L_,    0,   1,   1,    9,      1,    101,    101009 },
            { L_,    0,   1,   1,   10,      1,    101,    101010 },
            { L_,    0,   1,   1,   11,      1,    101,    101011 },
            { L_,    0,   1,   1,   99,      1,    101,    101099 },
            { L_,    0,   1,   1,  100,      1,    101,    101100 },
            { L_,    0,   1,   1,  101,      1,    101,    101101 },
            { L_,    0,   1,   1,  998,      1,    101,    101998 },
            { L_,    0,   1,   1,  999,      1,    101,    101999 },
            { L_,    0,   1,  59,    0,      1,    159,    159000 },
            { L_,    0,   1,  59,    1,      1,    159,    159001 },
            { L_,    0,   1,  59,    2,      1,    159,    159002 },
            { L_,    0,   1,  59,    9,      1,    159,    159009 },
            { L_,    0,   1,  59,   10,      1,    159,    159010 },
            { L_,    0,   1,  59,   11,      1,    159,    159011 },
            { L_,    0,   1,  59,   99,      1,    159,    159099 },
            { L_,    0,   1,  59,  100,      1,    159,    159100 },
            { L_,    0,   1,  59,  101,      1,    159,    159101 },
            { L_,    0,   1,  59,  998,      1,    159,    159998 },
            { L_,    0,   1,  59,  999,      1,    159,    159999 },
            { L_,    0,  59,   0,    0,     59,   5900,   5900000 },
            { L_,    0,  59,   0,    1,     59,   5900,   5900001 },
            { L_,    0,  59,   0,    2,     59,   5900,   5900002 },
            { L_,    0,  59,   0,    9,     59,   5900,   5900009 },
            { L_,    0,  59,   0,   10,     59,   5900,   5900010 },
            { L_,    0,  59,   0,   11,     59,   5900,   5900011 },
            { L_,    0,  59,   0,   99,     59,   5900,   5900099 },
            { L_,    0,  59,   0,  100,     59,   5900,   5900100 },
            { L_,    0,  59,   0,  101,     59,   5900,   5900101 },
            { L_,    0,  59,   0,  998,     59,   5900,   5900998 },
            { L_,    0,  59,   0,  999,     59,   5900,   5900999 },
            { L_,    0,  59,   1,    0,     59,   5901,   5901000 },
            { L_,    0,  59,   1,    1,     59,   5901,   5901001 },
            { L_,    0,  59,   1,    2,     59,   5901,   5901002 },
            { L_,    0,  59,   1,    9,     59,   5901,   5901009 },
            { L_,    0,  59,   1,   10,     59,   5901,   5901010 },
            { L_,    0,  59,   1,   11,     59,   5901,   5901011 },
            { L_,    0,  59,   1,   99,     59,   5901,   5901099 },
            { L_,    0,  59,   1,  100,     59,   5901,   5901100 },
            { L_,    0,  59,   1,  101,     59,   5901,   5901101 },
            { L_,    0,  59,   1,  998,     59,   5901,   5901998 },
            { L_,    0,  59,   1,  999,     59,   5901,   5901999 },
            { L_,    0,  59,  59,    0,     59,   5959,   5959000 },
            { L_,    0,  59,  59,    1,     59,   5959,   5959001 },
            { L_,    0,  59,  59,    2,     59,   5959,   5959002 },
            { L_,    0,  59,  59,    9,     59,   5959,   5959009 },
            { L_,    0,  59,  59,   10,     59,   5959,   5959010 },
            { L_,    0,  59,  59,   11,     59,   5959,   5959011 },
            { L_,    0,  59,  59,   99,     59,   5959,   5959099 },
            { L_,    0,  59,  59,  100,     59,   5959,   5959100 },
            { L_,    0,  59,  59,  101,     59,   5959,   5959101 },
            { L_,    0,  59,  59,  998,     59,   5959,   5959998 },
            { L_,    0,  59,  59,  999,     59,   5959,   5959999 },
            { L_,   12,   0,   0,    0,   1200, 120000, 120000000 },
            { L_,   12,   0,   0,    1,   1200, 120000, 120000001 },
            { L_,   12,   0,   0,    2,   1200, 120000, 120000002 },
            { L_,   12,   0,   0,    9,   1200, 120000, 120000009 },
            { L_,   12,   0,   0,   10,   1200, 120000, 120000010 },
            { L_,   12,   0,   0,   11,   1200, 120000, 120000011 },
            { L_,   12,   0,   0,   99,   1200, 120000, 120000099 },
            { L_,   12,   0,   0,  100,   1200, 120000, 120000100 },
            { L_,   12,   0,   0,  101,   1200, 120000, 120000101 },
            { L_,   12,   0,   0,  998,   1200, 120000, 120000998 },
            { L_,   12,   0,   0,  999,   1200, 120000, 120000999 },
            { L_,   12,   0,   1,    0,   1200, 120001, 120001000 },
            { L_,   12,   0,   1,    1,   1200, 120001, 120001001 },
            { L_,   12,   0,   1,    2,   1200, 120001, 120001002 },
            { L_,   12,   0,   1,    9,   1200, 120001, 120001009 },
            { L_,   12,   0,   1,   10,   1200, 120001, 120001010 },
            { L_,   12,   0,   1,   11,   1200, 120001, 120001011 },
            { L_,   12,   0,   1,   99,   1200, 120001, 120001099 },
            { L_,   12,   0,   1,  100,   1200, 120001, 120001100 },
            { L_,   12,   0,   1,  101,   1200, 120001, 120001101 },
            { L_,   12,   0,   1,  998,   1200, 120001, 120001998 },
            { L_,   12,   0,   1,  999,   1200, 120001, 120001999 },
            { L_,   12,   0,  59,    0,   1200, 120059, 120059000 },
            { L_,   12,   0,  59,    1,   1200, 120059, 120059001 },
            { L_,   12,   0,  59,    2,   1200, 120059, 120059002 },
            { L_,   12,   0,  59,    9,   1200, 120059, 120059009 },
            { L_,   12,   0,  59,   10,   1200, 120059, 120059010 },
            { L_,   12,   0,  59,   11,   1200, 120059, 120059011 },
            { L_,   12,   0,  59,   99,   1200, 120059, 120059099 },
            { L_,   12,   0,  59,  100,   1200, 120059, 120059100 },
            { L_,   12,   0,  59,  101,   1200, 120059, 120059101 },
            { L_,   12,   0,  59,  998,   1200, 120059, 120059998 },
            { L_,   12,   0,  59,  999,   1200, 120059, 120059999 },
            { L_,   12,   1,   0,    0,   1201, 120100, 120100000 },
            { L_,   12,   1,   0,    1,   1201, 120100, 120100001 },
            { L_,   12,   1,   0,    2,   1201, 120100, 120100002 },
            { L_,   12,   1,   0,    9,   1201, 120100, 120100009 },
            { L_,   12,   1,   0,   10,   1201, 120100, 120100010 },
            { L_,   12,   1,   0,   11,   1201, 120100, 120100011 },
            { L_,   12,   1,   0,   99,   1201, 120100, 120100099 },
            { L_,   12,   1,   0,  100,   1201, 120100, 120100100 },
            { L_,   12,   1,   0,  101,   1201, 120100, 120100101 },
            { L_,   12,   1,   0,  998,   1201, 120100, 120100998 },
            { L_,   12,   1,   0,  999,   1201, 120100, 120100999 },
            { L_,   12,   1,   1,    0,   1201, 120101, 120101000 },
            { L_,   12,   1,   1,    1,   1201, 120101, 120101001 },
            { L_,   12,   1,   1,    2,   1201, 120101, 120101002 },
            { L_,   12,   1,   1,    9,   1201, 120101, 120101009 },
            { L_,   12,   1,   1,   10,   1201, 120101, 120101010 },
            { L_,   12,   1,   1,   11,   1201, 120101, 120101011 },
            { L_,   12,   1,   1,   99,   1201, 120101, 120101099 },
            { L_,   12,   1,   1,  100,   1201, 120101, 120101100 },
            { L_,   12,   1,   1,  101,   1201, 120101, 120101101 },
            { L_,   12,   1,   1,  998,   1201, 120101, 120101998 },
            { L_,   12,   1,   1,  999,   1201, 120101, 120101999 },
            { L_,   12,   1,  59,    0,   1201, 120159, 120159000 },
            { L_,   12,   1,  59,    1,   1201, 120159, 120159001 },
            { L_,   12,   1,  59,    2,   1201, 120159, 120159002 },
            { L_,   12,   1,  59,    9,   1201, 120159, 120159009 },
            { L_,   12,   1,  59,   10,   1201, 120159, 120159010 },
            { L_,   12,   1,  59,   11,   1201, 120159, 120159011 },
            { L_,   12,   1,  59,   99,   1201, 120159, 120159099 },
            { L_,   12,   1,  59,  100,   1201, 120159, 120159100 },
            { L_,   12,   1,  59,  101,   1201, 120159, 120159101 },
            { L_,   12,   1,  59,  998,   1201, 120159, 120159998 },
            { L_,   12,   1,  59,  999,   1201, 120159, 120159999 },
            { L_,   12,  59,   0,    0,   1259, 125900, 125900000 },
            { L_,   12,  59,   0,    1,   1259, 125900, 125900001 },
            { L_,   12,  59,   0,    2,   1259, 125900, 125900002 },
            { L_,   12,  59,   0,    9,   1259, 125900, 125900009 },
            { L_,   12,  59,   0,   10,   1259, 125900, 125900010 },
            { L_,   12,  59,   0,   11,   1259, 125900, 125900011 },
            { L_,   12,  59,   0,   99,   1259, 125900, 125900099 },
            { L_,   12,  59,   0,  100,   1259, 125900, 125900100 },
            { L_,   12,  59,   0,  101,   1259, 125900, 125900101 },
            { L_,   12,  59,   0,  998,   1259, 125900, 125900998 },
            { L_,   12,  59,   0,  999,   1259, 125900, 125900999 },
            { L_,   12,  59,   1,    0,   1259, 125901, 125901000 },
            { L_,   12,  59,   1,    1,   1259, 125901, 125901001 },
            { L_,   12,  59,   1,    2,   1259, 125901, 125901002 },
            { L_,   12,  59,   1,    9,   1259, 125901, 125901009 },
            { L_,   12,  59,   1,   10,   1259, 125901, 125901010 },
            { L_,   12,  59,   1,   11,   1259, 125901, 125901011 },
            { L_,   12,  59,   1,   99,   1259, 125901, 125901099 },
            { L_,   12,  59,   1,  100,   1259, 125901, 125901100 },
            { L_,   12,  59,   1,  101,   1259, 125901, 125901101 },
            { L_,   12,  59,   1,  998,   1259, 125901, 125901998 },
            { L_,   12,  59,   1,  999,   1259, 125901, 125901999 },
            { L_,   12,  59,  59,    0,   1259, 125959, 125959000 },
            { L_,   12,  59,  59,    1,   1259, 125959, 125959001 },
            { L_,   12,  59,  59,    2,   1259, 125959, 125959002 },
            { L_,   12,  59,  59,    9,   1259, 125959, 125959009 },
            { L_,   12,  59,  59,   10,   1259, 125959, 125959010 },
            { L_,   12,  59,  59,   11,   1259, 125959, 125959011 },
            { L_,   12,  59,  59,   99,   1259, 125959, 125959099 },
            { L_,   12,  59,  59,  100,   1259, 125959, 125959100 },
            { L_,   12,  59,  59,  101,   1259, 125959, 125959101 },
            { L_,   12,  59,  59,  998,   1259, 125959, 125959998 },
            { L_,   12,  59,  59,  999,   1259, 125959, 125959999 },
            { L_,   23,   0,   0,    0,   2300, 230000, 230000000 },
            { L_,   23,   0,   0,    1,   2300, 230000, 230000001 },
            { L_,   23,   0,   0,    2,   2300, 230000, 230000002 },
            { L_,   23,   0,   0,    9,   2300, 230000, 230000009 },
            { L_,   23,   0,   0,   10,   2300, 230000, 230000010 },
            { L_,   23,   0,   0,   11,   2300, 230000, 230000011 },
            { L_,   23,   0,   0,   99,   2300, 230000, 230000099 },
            { L_,   23,   0,   0,  100,   2300, 230000, 230000100 },
            { L_,   23,   0,   0,  101,   2300, 230000, 230000101 },
            { L_,   23,   0,   0,  998,   2300, 230000, 230000998 },
            { L_,   23,   0,   0,  999,   2300, 230000, 230000999 },
            { L_,   23,   0,   1,    0,   2300, 230001, 230001000 },
            { L_,   23,   0,   1,    1,   2300, 230001, 230001001 },
            { L_,   23,   0,   1,    2,   2300, 230001, 230001002 },
            { L_,   23,   0,   1,    9,   2300, 230001, 230001009 },
            { L_,   23,   0,   1,   10,   2300, 230001, 230001010 },
            { L_,   23,   0,   1,   11,   2300, 230001, 230001011 },
            { L_,   23,   0,   1,   99,   2300, 230001, 230001099 },
            { L_,   23,   0,   1,  100,   2300, 230001, 230001100 },
            { L_,   23,   0,   1,  101,   2300, 230001, 230001101 },
            { L_,   23,   0,   1,  998,   2300, 230001, 230001998 },
            { L_,   23,   0,   1,  999,   2300, 230001, 230001999 },
            { L_,   23,   0,  59,    0,   2300, 230059, 230059000 },
            { L_,   23,   0,  59,    1,   2300, 230059, 230059001 },
            { L_,   23,   0,  59,    2,   2300, 230059, 230059002 },
            { L_,   23,   0,  59,    9,   2300, 230059, 230059009 },
            { L_,   23,   0,  59,   10,   2300, 230059, 230059010 },
            { L_,   23,   0,  59,   11,   2300, 230059, 230059011 },
            { L_,   23,   0,  59,   99,   2300, 230059, 230059099 },
            { L_,   23,   0,  59,  100,   2300, 230059, 230059100 },
            { L_,   23,   0,  59,  101,   2300, 230059, 230059101 },
            { L_,   23,   0,  59,  998,   2300, 230059, 230059998 },
            { L_,   23,   0,  59,  999,   2300, 230059, 230059999 },
            { L_,   23,   1,   0,    0,   2301, 230100, 230100000 },
            { L_,   23,   1,   0,    1,   2301, 230100, 230100001 },
            { L_,   23,   1,   0,    2,   2301, 230100, 230100002 },
            { L_,   23,   1,   0,    9,   2301, 230100, 230100009 },
            { L_,   23,   1,   0,   10,   2301, 230100, 230100010 },
            { L_,   23,   1,   0,   11,   2301, 230100, 230100011 },
            { L_,   23,   1,   0,   99,   2301, 230100, 230100099 },
            { L_,   23,   1,   0,  100,   2301, 230100, 230100100 },
            { L_,   23,   1,   0,  101,   2301, 230100, 230100101 },
            { L_,   23,   1,   0,  998,   2301, 230100, 230100998 },
            { L_,   23,   1,   0,  999,   2301, 230100, 230100999 },
            { L_,   23,   1,   1,    0,   2301, 230101, 230101000 },
            { L_,   23,   1,   1,    1,   2301, 230101, 230101001 },
            { L_,   23,   1,   1,    2,   2301, 230101, 230101002 },
            { L_,   23,   1,   1,    9,   2301, 230101, 230101009 },
            { L_,   23,   1,   1,   10,   2301, 230101, 230101010 },
            { L_,   23,   1,   1,   11,   2301, 230101, 230101011 },
            { L_,   23,   1,   1,   99,   2301, 230101, 230101099 },
            { L_,   23,   1,   1,  100,   2301, 230101, 230101100 },
            { L_,   23,   1,   1,  101,   2301, 230101, 230101101 },
            { L_,   23,   1,   1,  998,   2301, 230101, 230101998 },
            { L_,   23,   1,   1,  999,   2301, 230101, 230101999 },
            { L_,   23,   1,  59,    0,   2301, 230159, 230159000 },
            { L_,   23,   1,  59,    1,   2301, 230159, 230159001 },
            { L_,   23,   1,  59,    2,   2301, 230159, 230159002 },
            { L_,   23,   1,  59,    9,   2301, 230159, 230159009 },
            { L_,   23,   1,  59,   10,   2301, 230159, 230159010 },
            { L_,   23,   1,  59,   11,   2301, 230159, 230159011 },
            { L_,   23,   1,  59,   99,   2301, 230159, 230159099 },
            { L_,   23,   1,  59,  100,   2301, 230159, 230159100 },
            { L_,   23,   1,  59,  101,   2301, 230159, 230159101 },
            { L_,   23,   1,  59,  998,   2301, 230159, 230159998 },
            { L_,   23,   1,  59,  999,   2301, 230159, 230159999 },
            { L_,   23,  59,   0,    0,   2359, 235900, 235900000 },
            { L_,   23,  59,   0,    1,   2359, 235900, 235900001 },
            { L_,   23,  59,   0,    2,   2359, 235900, 235900002 },
            { L_,   23,  59,   0,    9,   2359, 235900, 235900009 },
            { L_,   23,  59,   0,   10,   2359, 235900, 235900010 },
            { L_,   23,  59,   0,   11,   2359, 235900, 235900011 },
            { L_,   23,  59,   0,   99,   2359, 235900, 235900099 },
            { L_,   23,  59,   0,  100,   2359, 235900, 235900100 },
            { L_,   23,  59,   0,  101,   2359, 235900, 235900101 },
            { L_,   23,  59,   0,  998,   2359, 235900, 235900998 },
            { L_,   23,  59,   0,  999,   2359, 235900, 235900999 },
            { L_,   23,  59,   1,    0,   2359, 235901, 235901000 },
            { L_,   23,  59,   1,    1,   2359, 235901, 235901001 },
            { L_,   23,  59,   1,    2,   2359, 235901, 235901002 },
            { L_,   23,  59,   1,    9,   2359, 235901, 235901009 },
            { L_,   23,  59,   1,   10,   2359, 235901, 235901010 },
            { L_,   23,  59,   1,   11,   2359, 235901, 235901011 },
            { L_,   23,  59,   1,   99,   2359, 235901, 235901099 },
            { L_,   23,  59,   1,  100,   2359, 235901, 235901100 },
            { L_,   23,  59,   1,  101,   2359, 235901, 235901101 },
            { L_,   23,  59,   1,  998,   2359, 235901, 235901998 },
            { L_,   23,  59,   1,  999,   2359, 235901, 235901999 },
            { L_,   23,  59,  59,    0,   2359, 235959, 235959000 },
            { L_,   23,  59,  59,    1,   2359, 235959, 235959001 },
            { L_,   23,  59,  59,    2,   2359, 235959, 235959002 },
            { L_,   23,  59,  59,    9,   2359, 235959, 235959009 },
            { L_,   23,  59,  59,   10,   2359, 235959, 235959010 },
            { L_,   23,  59,  59,   11,   2359, 235959, 235959011 },
            { L_,   23,  59,  59,   99,   2359, 235959, 235959099 },
            { L_,   23,  59,  59,  100,   2359, 235959, 235959100 },
            { L_,   23,  59,  59,  101,   2359, 235959, 235959101 },
            { L_,   23,  59,  59,  998,   2359, 235959, 235959998 },
            { L_,   23,  59,  59,  999,   2359, 235959, 235959999 },
        };
        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        for (int i = 0; i < NUM_DATA; ++i) {
            const int LINE        = DATA[i].d_lineNum;
            const int HOUR        = DATA[i].d_hr;
            const int MINUTE      = DATA[i].d_min;
            const int SECOND      = DATA[i].d_sec;
            const int MILLISECOND = DATA[i].d_ms;
            const int HHMM        = DATA[i].d_hhmm;
            const int HHMMSS      = DATA[i].d_hhmmss;
            const int HHMMSSmmm   = DATA[i].d_hhmmssmmm;

            if (veryVerbose) {
                T_ P_(LINE) P_(HOUR) P_(MINUTE) P_(SECOND) P_(MILLISECOND)
                   P_(HHMM) P_(HHMMSS) P(HHMMSSmmm)
            }

            const bdet_Time timeValue(HOUR, MINUTE, SECOND, MILLISECOND);
            const int hhmm      = Util::convertToHHMM(timeValue);
            const int hhmmss    = Util::convertToHHMMSS(timeValue);
            const int hhmmssmmm = Util::convertToHHMMSSmmm(timeValue);

            if (veryVerbose) {
                T_ P_(hhmm) P_(hhmmss) P(hhmmssmmm)
            }

            ASSERT(hhmm      == HHMM);
            ASSERT(hhmmss    == HHMMSS);
            ASSERT(hhmmssmmm == HHMMSSmmm);
        }

      } break;
      case 5: {
        // --------------------------------------------------------------------
        // TESTING convertFromHHMMSSmmm:
        //   Verify the conversion is correct
        //
        // Plan:
        //   Specify a set of test vectors and verify the return value.
        //
        // Testing:
        //   static bdet_Time convertFromHHMMSSmmm(int value);
        //   static bool isValidHHMMSSmmm(int value);
        // --------------------------------------------------------------------

        if (verbose) {
            cout << endl
              << "Testing 'convertFromHHMMSSmmm' & 'isValidHHMMSSmmm'" << endl
              << "===================================================" << endl;
        }

        static const struct {
            int d_lineNum;      // source line number
            int d_hour;         // hour field
            int d_minute;       // minute field
            int d_second;       // second field
            int d_millisecond;  // millisecond field
            int d_valid;        // are time fields valid?
        } DATA[] = {
            //line   hr   min   sec    ms   valid
            //----   --   ---   ---   ---   -----
            { L_,     0,    0,    0,    0,     1 },
            { L_,     0,    0,    0,    1,     1 },
            { L_,     0,    0,    0,    2,     1 },
            { L_,     0,    0,    0,    9,     1 },
            { L_,     0,    0,    0,   10,     1 },
            { L_,     0,    0,    0,   11,     1 },
            { L_,     0,    0,    0,   99,     1 },
            { L_,     0,    0,    0,  100,     1 },
            { L_,     0,    0,    0,  101,     1 },
            { L_,     0,    0,    0,  998,     1 },
            { L_,     0,    0,    0,  999,     1 },

            { L_,     0,    0,    1,    0,     1 },
            { L_,     0,    0,    1,    1,     1 },
            { L_,     0,    0,    1,    2,     1 },
            { L_,     0,    0,    1,    9,     1 },
            { L_,     0,    0,    1,   10,     1 },
            { L_,     0,    0,    1,   11,     1 },
            { L_,     0,    0,    1,   99,     1 },
            { L_,     0,    0,    1,  100,     1 },
            { L_,     0,    0,    1,  101,     1 },
            { L_,     0,    0,    1,  998,     1 },
            { L_,     0,    0,    1,  999,     1 },

            { L_,     0,    0,   59,    0,     1 },
            { L_,     0,    0,   59,    1,     1 },
            { L_,     0,    0,   59,    2,     1 },
            { L_,     0,    0,   59,    9,     1 },
            { L_,     0,    0,   59,   10,     1 },
            { L_,     0,    0,   59,   11,     1 },
            { L_,     0,    0,   59,   99,     1 },
            { L_,     0,    0,   59,  100,     1 },
            { L_,     0,    0,   59,  101,     1 },
            { L_,     0,    0,   59,  998,     1 },
            { L_,     0,    0,   59,  999,     1 },
            { L_,     0,    0,   60,    0,     0 },
            { L_,     0,    0,   61,   11,     0 },
            { L_,     0,    0,   99,  999,     0 },

            { L_,     0,    1,    0,    0,     1 },
            { L_,     0,    1,    0,    1,     1 },
            { L_,     0,    1,    0,    2,     1 },
            { L_,     0,    1,    0,    9,     1 },
            { L_,     0,    1,    0,   10,     1 },
            { L_,     0,    1,    0,   11,     1 },
            { L_,     0,    1,    0,   99,     1 },
            { L_,     0,    1,    0,  100,     1 },
            { L_,     0,    1,    0,  101,     1 },
            { L_,     0,    1,    0,  998,     1 },
            { L_,     0,    1,    0,  999,     1 },

            { L_,     0,    1,    1,    0,     1 },
            { L_,     0,    1,    1,    1,     1 },
            { L_,     0,    1,    1,    2,     1 },
            { L_,     0,    1,    1,    9,     1 },
            { L_,     0,    1,    1,   10,     1 },
            { L_,     0,    1,    1,   11,     1 },
            { L_,     0,    1,    1,   99,     1 },
            { L_,     0,    1,    1,  100,     1 },
            { L_,     0,    1,    1,  101,     1 },
            { L_,     0,    1,    1,  998,     1 },
            { L_,     0,    1,    1,  999,     1 },

            { L_,     0,    1,   59,    0,     1 },
            { L_,     0,    1,   59,    1,     1 },
            { L_,     0,    1,   59,    2,     1 },
            { L_,     0,    1,   59,    9,     1 },
            { L_,     0,    1,   59,   10,     1 },
            { L_,     0,    1,   59,   11,     1 },
            { L_,     0,    1,   59,   99,     1 },
            { L_,     0,    1,   59,  100,     1 },
            { L_,     0,    1,   59,  101,     1 },
            { L_,     0,    1,   59,  998,     1 },
            { L_,     0,    1,   59,  999,     1 },
            { L_,     0,    1,   60,    0,     0 },
            { L_,     0,    1,   61,   11,     0 },
            { L_,     0,    1,   99,  999,     0 },

            { L_,     0,   59,    0,    0,     1 },
            { L_,     0,   59,    0,    1,     1 },
            { L_,     0,   59,    0,    2,     1 },
            { L_,     0,   59,    0,    9,     1 },
            { L_,     0,   59,    0,   11,     1 },
            { L_,     0,   59,    0,   99,     1 },
            { L_,     0,   59,    0,  100,     1 },
            { L_,     0,   59,    0,  101,     1 },
            { L_,     0,   59,    0,  998,     1 },
            { L_,     0,   59,    0,  999,     1 },

            { L_,     0,   59,    1,    0,     1 },
            { L_,     0,   59,    1,    1,     1 },
            { L_,     0,   59,    1,    2,     1 },
            { L_,     0,   59,    1,    9,     1 },
            { L_,     0,   59,    1,   10,     1 },
            { L_,     0,   59,    1,   11,     1 },
            { L_,     0,   59,    1,   99,     1 },
            { L_,     0,   59,    1,  100,     1 },
            { L_,     0,   59,    1,  101,     1 },
            { L_,     0,   59,    1,  998,     1 },
            { L_,     0,   59,    1,  999,     1 },

            { L_,     0,   59,   59,    0,     1 },
            { L_,     0,   59,   59,    1,     1 },
            { L_,     0,   59,   59,    2,     1 },
            { L_,     0,   59,   59,    9,     1 },
            { L_,     0,   59,   59,   10,     1 },
            { L_,     0,   59,   59,   11,     1 },
            { L_,     0,   59,   59,   99,     1 },
            { L_,     0,   59,   59,  100,     1 },
            { L_,     0,   59,   59,  101,     1 },
            { L_,     0,   59,   59,  998,     1 },
            { L_,     0,   59,   59,  999,     1 },
            { L_,     0,   59,   60,    0,     0 },
            { L_,     0,   59,   61,   11,     0 },
            { L_,     0,   59,   99,  999,     0 },

            { L_,    12,    0,    0,    0,     1 },
            { L_,    12,    0,    0,    1,     1 },
            { L_,    12,    0,    0,    2,     1 },
            { L_,    12,    0,    0,    9,     1 },
            { L_,    12,    0,    0,   10,     1 },
            { L_,    12,    0,    0,   11,     1 },
            { L_,    12,    0,    0,   99,     1 },
            { L_,    12,    0,    0,  100,     1 },
            { L_,    12,    0,    0,  101,     1 },
            { L_,    12,    0,    0,  998,     1 },
            { L_,    12,    0,    0,  999,     1 },

            { L_,    12,    0,    1,    0,     1 },
            { L_,    12,    0,    1,    1,     1 },
            { L_,    12,    0,    1,    2,     1 },
            { L_,    12,    0,    1,    9,     1 },
            { L_,    12,    0,    1,   10,     1 },
            { L_,    12,    0,    1,   11,     1 },
            { L_,    12,    0,    1,   99,     1 },
            { L_,    12,    0,    1,  100,     1 },
            { L_,    12,    0,    1,  101,     1 },
            { L_,    12,    0,    1,  998,     1 },
            { L_,    12,    0,    1,  999,     1 },

            { L_,    12,    0,   59,    0,     1 },
            { L_,    12,    0,   59,    1,     1 },
            { L_,    12,    0,   59,    2,     1 },
            { L_,    12,    0,   59,    9,     1 },
            { L_,    12,    0,   59,   10,     1 },
            { L_,    12,    0,   59,   11,     1 },
            { L_,    12,    0,   59,   99,     1 },
            { L_,    12,    0,   59,  100,     1 },
            { L_,    12,    0,   59,  101,     1 },
            { L_,    12,    0,   59,  998,     1 },
            { L_,    12,    0,   59,  999,     1 },
            { L_,    12,    0,   60,    0,     0 },
            { L_,    12,    0,   61,   11,     0 },
            { L_,    12,    0,   99,  999,     0 },
            { L_,   120,    0,    0,    0,     0 },

            { L_,    12,    1,    0,    0,     1 },
            { L_,    12,    1,    0,    1,     1 },
            { L_,    12,    1,    0,    2,     1 },
            { L_,    12,    1,    0,    9,     1 },
            { L_,    12,    1,    0,   10,     1 },
            { L_,    12,    1,    0,   11,     1 },
            { L_,    12,    1,    0,   99,     1 },
            { L_,    12,    1,    0,  100,     1 },
            { L_,    12,    1,    0,  101,     1 },
            { L_,    12,    1,    0,  998,     1 },
            { L_,    12,    1,    0,  999,     1 },

            { L_,    12,    1,    1,    0,     1 },
            { L_,    12,    1,    1,    1,     1 },
            { L_,    12,    1,    1,    2,     1 },
            { L_,    12,    1,    1,    9,     1 },
            { L_,    12,    1,    1,   10,     1 },
            { L_,    12,    1,    1,   11,     1 },
            { L_,    12,    1,    1,   99,     1 },
            { L_,    12,    1,    1,  100,     1 },
            { L_,    12,    1,    1,  101,     1 },
            { L_,    12,    1,    1,  998,     1 },
            { L_,    12,    1,    1,  999,     1 },

            { L_,    12,    1,   59,    0,     1 },
            { L_,    12,    1,   59,    1,     1 },
            { L_,    12,    1,   59,    2,     1 },
            { L_,    12,    1,   59,    9,     1 },
            { L_,    12,    1,   59,   10,     1 },
            { L_,    12,    1,   59,   11,     1 },
            { L_,    12,    1,   59,   99,     1 },
            { L_,    12,    1,   59,  100,     1 },
            { L_,    12,    1,   59,  101,     1 },
            { L_,    12,    1,   59,  998,     1 },
            { L_,    12,    1,   59,  999,     1 },
            { L_,    12,    1,   60,    0,     0 },
            { L_,    12,    1,   61,   11,     0 },
            { L_,    12,    1,   99,  999,     0 },

            { L_,    12,   59,    0,    0,     1 },
            { L_,    12,   59,    0,    1,     1 },
            { L_,    12,   59,    0,    2,     1 },
            { L_,    12,   59,    0,    9,     1 },
            { L_,    12,   59,    0,   10,     1 },
            { L_,    12,   59,    0,   11,     1 },
            { L_,    12,   59,    0,   99,     1 },
            { L_,    12,   59,    0,  100,     1 },
            { L_,    12,   59,    0,  101,     1 },
            { L_,    12,   59,    0,  998,     1 },
            { L_,    12,   59,    0,  999,     1 },

            { L_,    12,   59,    1,    0,     1 },
            { L_,    12,   59,    1,    1,     1 },
            { L_,    12,   59,    1,    2,     1 },
            { L_,    12,   59,    1,    9,     1 },
            { L_,    12,   59,    1,   10,     1 },
            { L_,    12,   59,    1,   11,     1 },
            { L_,    12,   59,    1,   99,     1 },
            { L_,    12,   59,    1,  100,     1 },
            { L_,    12,   59,    1,  101,     1 },
            { L_,    12,   59,    1,  998,     1 },
            { L_,    12,   59,    1,  999,     1 },

            { L_,    12,   59,   59,    0,     1 },
            { L_,    12,   59,   59,    1,     1 },
            { L_,    12,   59,   59,    2,     1 },
            { L_,    12,   59,   59,    9,     1 },
            { L_,    12,   59,   59,   10,     1 },
            { L_,    12,   59,   59,   11,     1 },
            { L_,    12,   59,   59,   99,     1 },
            { L_,    12,   59,   59,  100,     1 },
            { L_,    12,   59,   59,  101,     1 },
            { L_,    12,   59,   59,  998,     1 },
            { L_,    12,   59,   59,  999,     1 },
            { L_,    12,   59,   60,    0,     0 },
            { L_,    12,   59,   61,   11,     0 },
            { L_,    12,   59,   99,  999,     0 },

            { L_,    23,    0,    0,    0,     1 },
            { L_,    23,    0,    0,    1,     1 },
            { L_,    23,    0,    0,    2,     1 },
            { L_,    23,    0,    0,    9,     1 },
            { L_,    23,    0,    0,   10,     1 },
            { L_,    23,    0,    0,   11,     1 },
            { L_,    23,    0,    0,   99,     1 },
            { L_,    23,    0,    0,  100,     1 },
            { L_,    23,    0,    0,  101,     1 },
            { L_,    23,    0,    0,  998,     1 },
            { L_,    23,    0,    0,  999,     1 },

            { L_,    23,    0,    1,    0,     1 },
            { L_,    23,    0,    1,    1,     1 },
            { L_,    23,    0,    1,    2,     1 },
            { L_,    23,    0,    1,    9,     1 },
            { L_,    23,    0,    1,   10,     1 },
            { L_,    23,    0,    1,   11,     1 },
            { L_,    23,    0,    1,   99,     1 },
            { L_,    23,    0,    1,  100,     1 },
            { L_,    23,    0,    1,  101,     1 },
            { L_,    23,    0,    1,  998,     1 },
            { L_,    23,    0,    1,  999,     1 },

            { L_,    23,    0,   59,    0,     1 },
            { L_,    23,    0,   59,    1,     1 },
            { L_,    23,    0,   59,    2,     1 },
            { L_,    23,    0,   59,    9,     1 },
            { L_,    23,    0,   59,   10,     1 },
            { L_,    23,    0,   59,   11,     1 },
            { L_,    23,    0,   59,   99,     1 },
            { L_,    23,    0,   59,  100,     1 },
            { L_,    23,    0,   59,  101,     1 },
            { L_,    23,    0,   59,  998,     1 },
            { L_,    23,    0,   59,  999,     1 },
            { L_,    23,    0,   60,    0,     0 },
            { L_,    23,    0,   61,   11,     0 },
            { L_,    23,    0,   99,  999,     0 },

            { L_,    23,    1,    0,    0,     1 },
            { L_,    23,    1,    0,    1,     1 },
            { L_,    23,    1,    0,    2,     1 },
            { L_,    23,    1,    0,    9,     1 },
            { L_,    23,    1,    0,   10,     1 },
            { L_,    23,    1,    0,   11,     1 },
            { L_,    23,    1,    0,   99,     1 },
            { L_,    23,    1,    0,  100,     1 },
            { L_,    23,    1,    0,  101,     1 },
            { L_,    23,    1,    0,  998,     1 },
            { L_,    23,    1,    0,  999,     1 },

            { L_,    23,    1,    1,    0,     1 },
            { L_,    23,    1,    1,    1,     1 },
            { L_,    23,    1,    1,    2,     1 },
            { L_,    23,    1,    1,    9,     1 },
            { L_,    23,    1,    1,   10,     1 },
            { L_,    23,    1,    1,   11,     1 },
            { L_,    23,    1,    1,   99,     1 },
            { L_,    23,    1,    1,  100,     1 },
            { L_,    23,    1,    1,  101,     1 },
            { L_,    23,    1,    1,  998,     1 },
            { L_,    23,    1,    1,  999,     1 },

            { L_,    23,    1,   59,    0,     1 },
            { L_,    23,    1,   59,    1,     1 },
            { L_,    23,    1,   59,    2,     1 },
            { L_,    23,    1,   59,    9,     1 },
            { L_,    23,    1,   59,   10,     1 },
            { L_,    23,    1,   59,   11,     1 },
            { L_,    23,    1,   59,   99,     1 },
            { L_,    23,    1,   59,  100,     1 },
            { L_,    23,    1,   59,  101,     1 },
            { L_,    23,    1,   59,  998,     1 },
            { L_,    23,    1,   59,  999,     1 },
            { L_,    23,    1,   60,    0,     0 },
            { L_,    23,    1,   61,   11,     0 },
            { L_,    23,    1,   99,  999,     0 },

            { L_,    23,   59,    0,    0,     1 },
            { L_,    23,   59,    0,    1,     1 },
            { L_,    23,   59,    0,    2,     1 },
            { L_,    23,   59,    0,    9,     1 },
            { L_,    23,   59,    0,   10,     1 },
            { L_,    23,   59,    0,   11,     1 },
            { L_,    23,   59,    0,   99,     1 },
            { L_,    23,   59,    0,  100,     1 },
            { L_,    23,   59,    0,  101,     1 },
            { L_,    23,   59,    0,  998,     1 },
            { L_,    23,   59,    0,  999,     1 },

            { L_,    23,   59,    1,    0,     1 },
            { L_,    23,   59,    1,    1,     1 },
            { L_,    23,   59,    1,    2,     1 },
            { L_,    23,   59,    1,    9,     1 },
            { L_,    23,   59,    1,   10,     1 },
            { L_,    23,   59,    1,   11,     1 },
            { L_,    23,   59,    1,   99,     1 },
            { L_,    23,   59,    1,  100,     1 },
            { L_,    23,   59,    1,  101,     1 },
            { L_,    23,   59,    1,  998,     1 },
            { L_,    23,   59,    1,  999,     1 },

            { L_,    23,   59,   59,    0,     1 },
            { L_,    23,   59,   59,    1,     1 },
            { L_,    23,   59,   59,    2,     1 },
            { L_,    23,   59,   59,    9,     1 },
            { L_,    23,   59,   59,   10,     1 },
            { L_,    23,   59,   59,   11,     1 },
            { L_,    23,   59,   59,   99,     1 },
            { L_,    23,   59,   59,  100,     1 },
            { L_,    23,   59,   59,  101,     1 },
            { L_,    23,   59,   59,  998,     1 },
            { L_,    23,   59,   59,  999,     1 },
            { L_,    23,   59,   60,    0,     0 },
            { L_,    23,   59,   61,   11,     0 },
            { L_,    23,   59,   99,  999,     0 },
            { L_,   230,    0,    0,    0,     0 },

            { L_,    24,    0,    0,    0,     1 },
            { L_,    24,    0,    0,    6,     0 },
            { L_,    24,    0,    6,    0,     0 },
            { L_,    24,    6,    0,    0,     0 },
            { L_,    24,    0,    6,    6,     0 },
            { L_,    24,    6,    0,    6,     0 },
            { L_,    24,    6,    6,    0,     0 },
            { L_,    24,    6,    6,    6,     0 },
            { L_,   240,    0,    0,    0,     0 },
        };
        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        for (int ti = 0; ti < NUM_DATA; ++ti) {
            const int LINE        = DATA[ti].d_lineNum;
            const int HOUR        = DATA[ti].d_hour;
            const int MINUTE      = DATA[ti].d_minute;
            const int SECOND      = DATA[ti].d_second;
            const int MILLISECOND = DATA[ti].d_millisecond;
            const int VALID       = DATA[ti].d_valid;

            const int VALUE =   HOUR * 10000000
                            + MINUTE * 100000
                            + SECOND * 1000
                            + MILLISECOND;

            if (veryVerbose) {
                T_ P_(LINE) P_(HOUR) P_(MINUTE) P_(SECOND) P_(MILLISECOND)
                   P(VALID) P(VALUE)
            }

            ASSERT(VALID == Util::isValidHHMMSSmmm(VALUE));

            if (VALID) {
                bdet_Time result = Util::convertFromHHMMSSmmm(VALUE);

                if (veryVerbose) {
                    T_  P_(result.hour())   P_(result.minute())
                        P_(result.second())  P(result.millisecond())
                }

                ASSERT(HOUR        == result.hour());
                ASSERT(MINUTE      == result.minute());
                ASSERT(SECOND      == result.second());
                ASSERT(MILLISECOND == result.millisecond());
            }
        }

      } break;
      case 4: {
        // --------------------------------------------------------------------
        // TESTING convertFromHHMMSS:
        //   Verify the conversion is correct
        //
        // Plan:
        //   Specify a set of test vectors and verify the return value.
        //
        // Testing:
        //   static bdet_Time convertFromHHMMSS(int value);
        //   static bool isValidHHMMSS(int value);
        // --------------------------------------------------------------------

        if (verbose) {
            cout << endl
                 << "Testing 'convertFromHHMMSS' & 'isValidHHMMSS'" << endl
                 << "=============================================" << endl;
        }

        static const struct {
            int d_lineNum;  // source line number
            int d_hour;     // hour field
            int d_minute;   // minute field
            int d_second;   // second field
            int d_valid;    // are time fields valid?
        } DATA[] = {
            //line   hr   min   sec   valid
            //----   --   ---   ---   -----
            { L_,     0,    0,    0,     1 },
            { L_,     0,    0,    1,     1 },
            { L_,     0,    0,   59,     1 },
            { L_,     0,    0,   60,     0 },
            { L_,     0,    0,   61,     0 },
            { L_,     0,    0,   99,     0 },

            { L_,     0,    1,    0,     1 },
            { L_,     0,    1,    1,     1 },
            { L_,     0,    1,   59,     1 },
            { L_,     0,    1,   60,     0 },
            { L_,     0,    1,   61,     0 },
            { L_,     0,    1,   99,     0 },

            { L_,     0,   59,    0,     1 },
            { L_,     0,   59,    1,     1 },
            { L_,     0,   59,    59,    1 },
            { L_,     0,   59,    60,    0 },
            { L_,     0,   59,    60,    0 },
            { L_,     0,   59,    99,    0 },

            { L_,     1,    0,    0,     1 },
            { L_,     1,    0,    1,     1 },
            { L_,     1,    0,   59,     1 },
            { L_,     1,    0,   60,     0 },
            { L_,     1,    0,   61,     0 },
            { L_,     1,    0,   99,     0 },

            { L_,     1,    1,    0,     1 },
            { L_,     1,    1,    1,     1 },
            { L_,     1,    1,   59,     1 },
            { L_,     1,    1,   60,     0 },
            { L_,     1,    1,   61,     0 },
            { L_,     1,    1,   99,     0 },

            { L_,     1,   59,    0,     1 },
            { L_,     1,   59,    1,     1 },
            { L_,     1,   59,    59,    1 },
            { L_,     1,   59,    60,    0 },
            { L_,     1,   59,    60,    0 },
            { L_,     1,   59,    99,    0 },

            { L_,    12,    0,    0,     1 },
            { L_,    12,    0,    1,     1 },
            { L_,    12,    0,   59,     1 },
            { L_,    12,    0,   60,     0 },
            { L_,    12,    0,   61,     0 },
            { L_,    12,    0,   99,     0 },

            { L_,    12,    1,    0,     1 },
            { L_,    12,    1,    1,     1 },
            { L_,    12,    1,   59,     1 },
            { L_,    12,    1,   60,     0 },
            { L_,    12,    1,   61,     0 },
            { L_,    12,    1,   99,     0 },

            { L_,    12,   59,    0,     1 },
            { L_,    12,   59,    1,     1 },
            { L_,    12,   59,    1,     1 },
            { L_,    12,   59,   59,     1 },
            { L_,    12,   59,   60,     0 },
            { L_,    12,   59,   61,     0 },
            { L_,    12,   59,   99,     0 },

            { L_,    23,    0,    0,     1 },
            { L_,    23,    0,    1,     1 },
            { L_,    23,    0,   59,     1 },
            { L_,    23,    0,   60,     0 },
            { L_,    23,    0,   61,     0 },
            { L_,    23,    0,   99,     0 },

            { L_,    23,    1,    0,     1 },
            { L_,    23,    1,    1,     1 },
            { L_,    23,    1,   59,     1 },
            { L_,    23,    1,   60,     0 },
            { L_,    23,    1,   61,     0 },
            { L_,    23,    1,   99,     0 },

            { L_,    23,   59,    0,     1 },
            { L_,    23,   59,    1,     1 },
            { L_,    23,   59,   59,     1 },
            { L_,    23,   59,   60,     0 },
            { L_,    23,   59,   61,     0 },
            { L_,    23,   59,   99,     0 },

            { L_,    24,    0,    0,     1 },
            { L_,    24,    0,    1,     0 },
            { L_,    24,    2,    0,     0 },
            { L_,    24,   24,   24,     0 },
            { L_,   240,    0,    0,     0 },
        };
        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        for (int ti = 0; ti < NUM_DATA; ++ti) {
            const int LINE   = DATA[ti].d_lineNum;
            const int HOUR   = DATA[ti].d_hour;
            const int MINUTE = DATA[ti].d_minute;
            const int SECOND = DATA[ti].d_second;
            const int VALID  = DATA[ti].d_valid;

            const int VALUE = HOUR * 10000 + MINUTE * 100 + SECOND;

            if (veryVerbose) {
                T_ P_(LINE) P_(HOUR) P_(MINUTE) P_(SECOND) P(VALID)
                   P(VALUE)
            }

            ASSERT(VALID == Util::isValidHHMMSS(VALUE));

            if (VALID) {
                bdet_Time result = Util::convertFromHHMMSS(VALUE);

                if (veryVerbose) {
                    T_ P_(result.hour())  P_(result.minute())
                       P_(result.second()) P(result.millisecond())
                }

                ASSERT(HOUR   == result.hour());
                ASSERT(MINUTE == result.minute());
                ASSERT(SECOND == result.second());
                ASSERT(0      == result.millisecond());
            }
        }

      } break;
      case 3: {
        // --------------------------------------------------------------------
        // TESTING convertFromHHMM:
        //   Verify the conversion is correct
        //
        // Plan:
        //   Specifying a set of test vectors and verify the return value.
        //
        // Testing:
        //   static bdet_Time convertFromHHMM(int value);
        //   static bool isValidHHMM(int value);
        // --------------------------------------------------------------------

        if (verbose) {
            cout << endl
                 << "Testing 'convertFromHHMM' & 'isValidHHMM'" << endl
                 << "=========================================" << endl;
        }

        static const struct {
            int d_lineNum;  // source line number
            int d_hour;     // hour field
            int d_minute;   // minute field
            int d_valid;    // are time fields valid?
        } DATA[] = {
            //line   hr   min   valid
            //----   --   ---   -----
            { L_,     0,    0,     1 },
            { L_,     0,    1,     1 },
            { L_,     0,    2,     1 },
            { L_,     0,   58,     1 },
            { L_,     0,   59,     1 },
            { L_,     0,   60,     0 },
            { L_,     0,   61,     0 },
            { L_,     0,   99,     0 },

            { L_,     1,    0,     1 },
            { L_,     1,    1,     1 },
            { L_,     1,    2,     1 },
            { L_,     1,   58,     1 },
            { L_,     1,   59,     1 },
            { L_,     1,   60,     0 },
            { L_,     1,   61,     0 },
            { L_,     1,   99,     0 },
            { L_,   100,    0,     0 },

            { L_,    11,    0,     1 },
            { L_,    11,    1,     1 },
            { L_,    11,    2,     1 },
            { L_,    11,   58,     1 },
            { L_,    11,   59,     1 },
            { L_,    11,   60,     0 },
            { L_,    11,   61,     0 },
            { L_,    11,   99,     0 },
            { L_,   110,    0,     0 },

            { L_,    12,    0,     1 },
            { L_,    12,    1,     1 },
            { L_,    12,    2,     1 },
            { L_,    12,   58,     1 },
            { L_,    12,   59,     1 },
            { L_,    12,   60,     0 },
            { L_,    12,   61,     0 },
            { L_,    12,   99,     0 },
            { L_,   120,    0,     0 },

            { L_,    13,    0,     1 },
            { L_,    13,    1,     1 },
            { L_,    13,    2,     1 },
            { L_,    13,   58,     1 },
            { L_,    13,   59,     1 },
            { L_,    13,   60,     0 },
            { L_,    13,   61,     0 },
            { L_,    13,   99,     0 },
            { L_,   130,    0,     0 },

            { L_,    23,    0,     1 },
            { L_,    23,    1,     1 },
            { L_,    23,    2,     1 },
            { L_,    23,   58,     1 },
            { L_,    23,   59,     1 },
            { L_,    23,   60,     0 },
            { L_,    23,   61,     0 },
            { L_,    23,   99,     0 },
            { L_,   230,    0,     0 },

            { L_,    24,    0,     1 },
            { L_,    24,    1,     0 },
            { L_,    24,   59,     0 },
            { L_,    24,   99,     0 },
            { L_,   240,    0,     0 },
        };
        const int NUM_DATA = sizeof DATA / sizeof *DATA;

        for (int ti = 0; ti < NUM_DATA; ++ti) {
            const int LINE   = DATA[ti].d_lineNum;
            const int HOUR   = DATA[ti].d_hour;
            const int MINUTE = DATA[ti].d_minute;
            const int VALID  = DATA[ti].d_valid;

            const int VALUE = HOUR * 100 + MINUTE;

            if (veryVerbose) {
                T_ P_(LINE) P_(HOUR) P_(MINUTE) P(VALID)
                   P(VALUE)
            }

            ASSERT(VALID == Util::isValidHHMM(VALUE));

            if (VALID) {
                bdet_Time result = Util::convertFromHHMM(VALUE);

                if (veryVerbose) {
                    T_ P_(result.hour())  P_(result.minute())
                       P_(result.second()) P(result.millisecond())
                }

                ASSERT(HOUR   == result.hour());
                ASSERT(MINUTE == result.minute());
                ASSERT(0      == result.second());
                ASSERT(0      == result.millisecond());
            }
        }

      } break;
      case 2: {
        // --------------------------------------------------------------------
        // TESTING HASH OPERATOR (DISTRIBUTION) :
        //   Verify the hash function generates a good distribution of return
        //   values over a wide range of 'size' values.  Specifically, verify
        //   that for all x such that 0 <= x < size, x * 2^k for a fixed 'k' is
        //   perfectly distributed (every hash value is returned exactly once).
        //
        // Plan:
        //   Perform a large number of hashes and verifying the distribution.
        //
        // Testing:
        //   static int hash(const bdet_Time& value, int size);
        // --------------------------------------------------------------------

        if (verbose)
            cout << endl
                 << "Testing 'hash'" << endl
                 << "==============" << endl;

        if (verbose) cout << "\nTesting 'hash(const bdet_Time& value,"
                             "int size)' "
                          << "distribution." << endl;
        {
            { // test distribution for shifted bits
                const int size = 257;
                int *hit = new int[size];
                int i;
                for (i = 0; i < size; ++i) {
                    hit[i] = 0;
                }
                for (int k = 0; k <= 18; ++k) {
                    // Outside valid range for time if 'k > 18 && i > 164',
                    // since '165 * 2^19 > 24 * 60 * 60 * 1000 - 1'.
                    for (i = 0; i < size; ++i) {
                        bdet_Time time(0, 0, 0);
                        time.addMilliseconds(i << k);
                        ++hit[Util::hash(time, size)];
                    }
                    for (i = 0; i < size; ++i) {
                        LOOP3_ASSERT(k, i, hit[i], k + 1 == hit[i]);
                    }
                }
                delete [] hit;
            }
            { // test distribution for varying sizes
                static const int DATA[] = { 1, 5, 23, 257, 65537 };
                static const int NUM_DATA = sizeof DATA / sizeof *DATA;
                int i;
                for (int m = 1; m <= 4; m++) {
                    for (int si = 0; si < NUM_DATA; ++si) {
                        int size = DATA[si];
                        int *hit = new int[size];
                        for (i = 0; i < size; ++i) {
                            hit[i] = 0;
                        }
                        for (i = 0; i < m*size; ++i) {
                            bdet_Time time(0, 0, 0);
                            time.addMilliseconds(i);
                            ++hit[Util::hash(time, size)];
                        }
                        for (i = 0; i < size; ++i) {
                            LOOP4_ASSERT(m, size, i, hit[i], m == hit[i]);
                        }
                        delete [] hit;
                    }
                }
            }
        }

      } break;
      case 1: {
        // --------------------------------------------------------------------
        // TESTING HASH OPERATOR (VALUE):
        //   Verify the hash return value is constant across all platforms for
        //   a given input.
        //
        // Plan:
        //   Specifying a set of test vectors and verify the return value.
        //
        // Testing:
        //   static int hash(const bdet_Time& value, int size);  CONCERN: value
        // --------------------------------------------------------------------

        if (verbose)
            cout << endl
                 << "Testing 'hash'" << endl
                 << "==============" << endl;

        if (verbose) cout << "\nTesting 'hash(const bdet_Time& value,"
                             "int size)' "
                          << "return value." << endl;
        {
            static const struct {
                int d_lineNum;     // source line number
                int d_hour;        // value to hash
                int d_minute;      // value to hash
                int d_second;      // value to hash
                int d_size;        // size of target hash table
                int d_exp;         // expected return value
            } DATA[] = {
                //line  hour  minute  second   size    exp
                //----  ----  ------  ------  ------  ------
                { L_,      0,      0,      0,    257,      0 },
                { L_,      1,      1,      1,    257,     35 },
                { L_,      1,      1,     10,    257,     40 },
                { L_,      1,      1,     31,    257,    223 },
                { L_,      1,      2,      1,    257,    154 },
                { L_,      1,      2,     17,    257,    220 },
                { L_,      1,      2,     28,    257,    169 },
                { L_,      1,     12,      1,    257,     59 },
                { L_,      1,     12,      9,    257,     92 },
                { L_,      1,     12,     31,    257,    247 },
            };
            const int NUM_DATA = sizeof DATA / sizeof *DATA;

            for (int ti = 0; ti < NUM_DATA ; ++ti) {
                const int LINE  = DATA[ti].d_lineNum;
                const int HOUR  = DATA[ti].d_hour;
                const int MINUTE = DATA[ti].d_minute;
                const int SECOND   = DATA[ti].d_second;
                const int SIZE  = DATA[ti].d_size;
                const int EXP   = DATA[ti].d_exp;

                bdet_Time time(HOUR, MINUTE, SECOND);

                if (veryVerbose) {
                    P_(time);
                    P_(SIZE);
                    P(EXP);
                    P(Util::hash(time, SIZE));
                    cout << endl;
                }
                LOOP_ASSERT(LINE, EXP == Util::hash(time, SIZE));
            }
        }

      } break;
      default: {
        cerr << "WARNING: CASE `" << test << "' NOT FOUND." << endl;
        testStatus = -1;
      }
    }

    if (testStatus > 0) {
        cerr << "Error, non-zero test status = " << testStatus << "." << endl;
    }
    return testStatus;
}

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2002
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
