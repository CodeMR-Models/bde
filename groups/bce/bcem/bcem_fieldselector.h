// bcem_fieldselector.h                                               -*-C++-*-
#ifndef INCLUDED_BCEM_FIELDSELECTOR
#define INCLUDED_BCEM_FIELDSELECTOR

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide a class specifying a field selector.
//
//@CLASSES:
//  bcem_FieldSelector: selector for a single field
//
//@AUTHOR: Rohan Bhindwale (rbhindwa)
//
//@SEE_ALSO: bcem_aggregate, bcem_aggregateraw
//
//@DESCRIPTION: This component provides a single, simply constrained
// value-semantic class, 'bcem_FieldSelector', that is used to provide a
// selector for a field.  'bcem_FieldSelector' can be used to represent either
// a string or an index.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
// First, consider the following interface that accepts either the name of an
// employee or their employee identification number:
//..
//  int processPayroll(const bcem_FieldSelector& employee);
//      // Process the payroll for the specified 'employee'.  Return 0 on
//      // success, and a non-zero value otherwise.  Note that an employee can
//      // be identified by either their full name or their employee
//      // identification number.
//..
// Then, we define two 'bcem_FieldSelector' objects to represents two
// employees in the firm.  The first employee is referred to by their name and
// the second by their identification number:
//..
//  const char *employeeName = "John Smith";
//  const int   employeeId   = 124356;
//..
// Next, we create two 'bcem_FieldSelector' objects to identify these
// employees:
//..
//  bcem_FieldSelector employee1(employeeName);
//  assert(!employee1.isEmpty());
//  assert( employee1.isName());
//  assert(!employee1.isIndex());
//  assert(!bsl::strcmp(employeeName, employee1.name()));
//
//  bcem_FieldSelector employee2(employeeId);
//  assert(!employee2.isEmpty());
//  assert(!employee2.isName());
//  assert( employee2.isIndex());
//  assert( employeeId == employee2.index());
//..
// Now, we can pass these objects to the 'processPayroll' function so these
// employees can get their money.
//..
//  assert(!processPayroll(employee1));
//  assert(!processPayroll(employee2));
//..

#ifndef INCLUDED_BCESCM_VERSION
#include <bcescm_version.h>
#endif

#ifndef INCLUDED_BDEM_RECORDDEF
#include <bdem_recorddef.h>
#endif

#ifndef INCLUDED_BSL_STRING
#include <bsl_string.h>
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include <bsl_cstdlib.h>
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include <bsl_iosfwd.h>
#endif

namespace BloombergLP {

                        // ========================
                        // class bcem_FieldSelector
                        // ========================

class bcem_FieldSelector {
    // This class holds a *temporary* name string, an integer index, or neither
    // (the "empty" state).  It has conversion constructors from 'bsl::string',
    // 'const char *', and 'int'.  It does not own its string data.  This class
    // has in-core value semantics, except that it lacks printing support.

    enum {
        // Select name, index, or neither ('BCEM_EMPTY').

        BCEM_EMPTY,
        BCEM_NAME,
        BCEM_INDEX
    } d_state;

    union {
        const char *d_name_p; // set if 'BCEM_NAME' (held, *not* owned)
        int         d_index;  // set if 'BCEM_INDEX'
    };

  public:
    // CREATORS
    bcem_FieldSelector();
        // Create an empty field selector having no name or index.

    bcem_FieldSelector(const char *name);
        // Create a field selector having the specified 'name'.  The behavior
        // is undefined unless the character array pointed to by 'name' is
        // unchanged and remains valid during the lifetime of this object.

    bcem_FieldSelector(const bsl::string& name);
        // Create a field selector having the specified 'name'.  The behavior
        // is undefined unless 'name' is unchanged during the lifetime of this
        // object.

    bcem_FieldSelector(int index);
        // Create a field selector having the specified 'index'.  The behavior
        // is undefined unless 'index >= 0'.

    // bcem_FieldSelector(const bcem_FieldSelector& original) = default;
        // Create a 'bcem_FieldSelector' object having the same value
        // as the specified 'original' object.  Note that this trivial
        // constructor is generated by the compiler.

    //! ~bcem_FieldSelector() = default;
        // Destroy this object.  Note that this trivial destructor is generated
        // by the compiler.

    // MANIPULATORS
    // bcem_FieldSelector& operator=(const bcem_FieldSelector& rhs);
        // Assign to this object the value of the specified 'rhs' object, and
        // return a reference providing modifiable access to this object.
        // Note that this trivial operator is generated by the compiler.

    // ACCESSORS
    bool isEmpty() const;
        // Return 'true' if this is an empty field selector, and 'false'
        // otherwise.  An empty field selector has neither a name nor an index.

    bool isName() const;
        // Return 'true' if this field selector has a name, and 'false'
        // otherwise.

    bool isIndex() const;
        // Return 'true' if this field selector has an integral index, and
        // 'false' otherwise.

    const char *name() const;
        // Return the name of this field selector if 'isName() == true', and 0
        // otherwise.

    int index() const;
        // Return the integral index of this field selector if
        // 'isIndex() == true', and 'bdem_RecordDef::BDEM_NULL_FIELD_ID'
        // otherwise.

    bsl::ostream& print(bsl::ostream& stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Write the value of this object to the specified output 'stream' in a
        // human-readable format, and return a reference providing modifiable
        // access to 'stream'.  Optionally specify an initial indentation
        // 'level', whose absolute value is incremented recursively for nested
        // objects.  If 'level' is specified, optionally specify
        // 'spacesPerLevel', whose absolute value indicates the number of
        // spaces per indentation level for this and all of its nested objects.
        // If 'level' is negative, suppress indentation of the first line.  If
        // 'spacesPerLevel' is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // 'level').  If 'stream' is not valid on entry, this operation has no
        // effect.  Note that the format is not fully specified, and can change
        // without notice.
};

// FREE OPERATORS
bool operator==(const bcem_FieldSelector& lhs, const bcem_FieldSelector& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'bcem_FieldSelector' objects
    // have the same value if they both refer to either a name or an index,
    // and their name or index values are the same.

bool operator!=(const bcem_FieldSelector& lhs, const bcem_FieldSelector& rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have the
    // same value, and 'false' otherwise.  Two 'bcem_FieldSelector' objects do
    // not have the same value if either one object refers to a name and the
    // other to an index, or if both refer to a name or an index then their
    // referred to values are not the same.

bsl::ostream& operator<<(bsl::ostream&             stream,
                         const bcem_FieldSelector& object);
    // Write the value of the specified 'object' to the specified
    // output 'stream' in a single-line format, and return a reference to
    // 'stream'.  If 'stream' is not valid on entry, this operation has no
    // effect.  Note that this human-readable format is not fully specified
    // and can change without notice.  Also note that this method has the same
    // behavior as 'object.print(stream, 0, -1)', but with the attribute names
    // elided.

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                     //-------------------------
                     // class bcem_FieldSelector
                     //-------------------------

// CREATORS
inline
bcem_FieldSelector::bcem_FieldSelector()
: d_state(BCEM_EMPTY)
, d_name_p(0)
{
}

inline
bcem_FieldSelector::bcem_FieldSelector(const char *name)
: d_state(BCEM_NAME)
, d_name_p(name)
{
}

inline
bcem_FieldSelector::bcem_FieldSelector(const bsl::string& name)
: d_state(BCEM_NAME)
, d_name_p(name.c_str())
{
}

inline
bcem_FieldSelector::bcem_FieldSelector(int index)
: d_state(BCEM_INDEX)
, d_index(index)
{
}

// ACCESSORS
inline
bool bcem_FieldSelector::isEmpty() const
{
    return BCEM_EMPTY == d_state;
}

inline
bool bcem_FieldSelector::isName() const
{
    return BCEM_NAME == d_state;
}

inline
bool bcem_FieldSelector::isIndex() const
{
    return BCEM_INDEX == d_state;
}

inline
const char *bcem_FieldSelector::name() const
{
    return BCEM_NAME == d_state ? d_name_p : 0;
}

inline
int bcem_FieldSelector::index() const
{
    return BCEM_INDEX == d_state
                       ? d_index
                       : bdem_RecordDef::BDEM_NULL_FIELD_ID;
}

// FREE OPERATORS
inline
bool operator!=(const bcem_FieldSelector& lhs, const bcem_FieldSelector& rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream& operator<<(bsl::ostream& stream, const bcem_FieldSelector& rhs)
{
    return rhs.print(stream, 0, -1);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2012
//      All Rights Reserved.
//      Property of Bloomberg L.P.  (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ----------------------------------
