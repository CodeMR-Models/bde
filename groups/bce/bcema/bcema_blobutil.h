// bcema_blobutil.h   -*-C++-*-
#ifndef INCLUDED_BCEMA_BLOBUTIL
#define INCLUDED_BCEMA_BLOBUTIL

#ifndef INCLUDED_BDES_IDENT
#include <bdes_ident.h>
#endif
BDES_IDENT("$Id: $")

//@PURPOSE: Provide a suite of utilities for I/O operations on 'bcema_Blob'.
//
//@CLASSES:
//  bcema_BlobUtil: suite of utilities on 'bcema_Blob'
//
//@SEE_ALSO: bcema_blob
//
//@AUTHOR: Shezan Baig (sbaig)
//
//@CONTACT: Rohan Bhindwale (rbhindwa)
//
//@DESCRIPTION: This component provides a variety of utilities for 'bcema_Blob'
// objects, such as I/O functions, comparison functions, and streaming
// functions.
//
///Usage
///-----
//
///xxd compatible hexdump
///- - - - - - - - - - -
// The output generated by the 'hexDump' functions are easier to read but also
// not xxd compatible.  The following perl script is provided that will convert
// 'hexDump' output into xxd compatible hexdump.  Run the script with a file
// containing the 'hexDump' output as the first argument.
//..
//#!/usr/bin/perl -w
//
//use strict;
//
//my $num = 0;
//while (<>) {
//    next if (!$_);
//    my $str = $_;
//    next if !($str =~ s/^[^:]*?:\s*//);
//    my $h = sprintf("%08X",$num);
//    $str =~ s/(\S{4})([\S\W]{4})\s?([\S\W]{4})([\S\W]{4})\s?([\S\W]{4})?
//            ([\S\W]{4})?\s?([\S\W]{4})?([\S\W]{4})?/$1 $2 $3 $4 $5 $6 $7 $8/;
//    $str =~ s/\s \|([^|]+)\|.*$/ $1/;
//    print "$h: ";
//    print $str;
//    $num = $num + 16;
//}
//..

#ifndef INCLUDED_BCESCM_VERSION
#include <bcescm_version.h>
#endif

#ifndef INCLUDED_BCEMA_BLOB
#include <bcema_blob.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include <bsls_performancehint.h>
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include <bsl_algorithm.h>
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include <bsl_iosfwd.h>
#endif

#ifndef INCLUDED_CSTRING
#include <cstring>          // for 'memcpy'
#define INCLUDED_CSTRING
#endif

#ifndef BDE_DONT_ALLOW_TRANSITIVE_INCLUDES

#ifndef INCLUDED_BDES_ASSERT
#include <bdes_assert.h>
#endif

#ifndef INCLUDED_IOSFWD
#include <iosfwd>
#define INCLUDED_IOSFWD
#endif

#endif

namespace BloombergLP {

class bslma_Allocator;

                           // =====================
                           // struct bcema_BlobUtil
                           // =====================

struct bcema_BlobUtil {
    // TBD: doc

    // CLASS METHODS
    static void append(bcema_Blob        *dest,
                       const bcema_Blob&  source,
                       int                offset,
                       int                length);
        // Append the specified 'length' bytes from the specified 'offset' in
        // the specified 'source' to the specified 'dest'.

    static void append(bcema_Blob        *dest,
                       const bcema_Blob&  source,
                       int                offset);
        // Append from the specified 'offset' in the specified 'source' to the
        // specified 'dest'.

    static void append(bcema_Blob *dest, const bcema_Blob& source);
        // Append the specified 'source' to the specified 'dest'.

    static void append(bcema_Blob *dest,
                       const char *source,
                       int         offset,
                       int         length);
        // Append the specified 'length' bytes starting from the specified
        // 'offset' from the specified 'source' address to the specified
        // 'dest'.  The behavior of this function is undefined unless the
        // range [source + offset, source + offset + length) represents a
        // readable sequence of memory.

    static void append(bcema_Blob *dest,
                       const char *source,
                       int         length);
        // Append the specified 'length' bytes starting from the specified
        // 'source' address to the specified 'dest'.  The behavior is undefined
        // unless the range '[ source, source + length )' is valid memory.

    static void erase(bcema_Blob *blob, int offset, int length);
        // Erase the specified 'length' bytes starting at the specified
        // 'offset' from the specified 'blob'.  The behavior is undefined
        // unless 'offset >= 0', 'length >= 0', and
        // 'offset + length <= blob->length()'.

    static void insert(bcema_Blob        *dest,
                       int                destOffset,
                       const bcema_Blob&  source,
                       int                sourceOffset,
                       int                sourceLength);
        // Insert the specified 'sourceLength' bytes from the specified
        // 'sourceOffset' in the specified 'source' to the specified
        // 'destOffset' in the specified 'dest'.

    static void insert(bcema_Blob        *dest,
                       int                destOffset,
                       const bcema_Blob&  source,
                       int                sourceOffset);
        // Insert from the specified 'sourceOffset' in the specified 'source'
        // to the specified 'destOffset' in the specified 'dest'.

    static void insert(bcema_Blob        *dest,
                       int                destOffset,
                       const bcema_Blob&  source);
        // Insert the specified 'source' to the specified 'destOffset' in the
        // specified 'dest'.

    static bsl::ostream& asciiDump(bsl::ostream&     stream,
                                   const bcema_Blob& source);
        // Write to the specified 'ostream' an ascii dump of the specified
        // 'source' and return a reference to the modifiable 'stream'.

    static bsl::ostream& hexDump(bsl::ostream&     stream,
                                 const bcema_Blob& source);
        // Write to the specified 'ostream' a hexdump of the specified
        // 'source' and return a reference to the modifiable 'stream'.

    static bsl::ostream& hexDump(bsl::ostream&     stream,
                                 const bcema_Blob& source,
                                 int               offset,
                                 int               length);
        // Write to the specified 'ostream' a hexdump of the specified 'length'
        // bytes of the specified 'source' starting at the specified 'offset'
        // and return a reference to the modifiable 'stream'.

    template <typename STREAM>
    static STREAM& read(STREAM& stream, bcema_Blob *dest, int numBytes);
        // Read the specified 'numBytes' from the specified 'stream' and load
        // it into the specified 'dest'.

    template <typename STREAM>
    static STREAM& write(STREAM& stream, const bcema_Blob& source);
        // Write the specified 'source' to the specified 'stream'.

    template <typename STREAM>
    static int write(STREAM&           stream,
                     const bcema_Blob& source,
                     int               sourcePosition,
                     int               numBytes);
        // Write to the specified 'stream' the specified 'numBytes'
        // starting at the specified 'sourcePosition' in the specified 'source'
        // blob.  Return 0 on success or a non-zero value otherwise.  Note that
        // this function will fail (immediately) if the length of 'source' is
        // less than 'numBytes'; or if there is any error writing to 'stream'.

    static int compare(const bcema_Blob& blob1, const bcema_Blob& blob2);
        // Compare the data from 'blob1' to the data in 'blob2'.  Return
        // 0 if blob1 and blob2 are logically equivalent -- i.e. the length
        // and bytes contained in the blob are the same.  The blobs
        // 'totalSize()' is not a factor in logical equivalence.  Return
        // a negative integer if 'blob1' is less than 'blob2' and a
        // positive integer if 'blob1' is greater than 'blob2.

    // ---------- DEPRECATED FUNCTIONS ------------- //

    // DEPRECATED FUNCTIONS: basicAllocator is no longer used
    static void append(bcema_Blob        *dest,
                       const bcema_Blob&  source,
                       int                offset,
                       int                length,
                       bslma_Allocator   *);

    static void append(bcema_Blob        *dest,
                       const bcema_Blob&  source,
                       int                offset,
                       bslma_Allocator   *);

    static void append(bcema_Blob        *dest,
                       const bcema_Blob&  source,
                       bslma_Allocator   *);
};

                      // ================================
                      // struct bcema_BlobUtilAsciiDumper
                      // ================================

struct bcema_BlobUtilAsciiDumper {
    // Utility for ascii dumping a blob to standard output streams.  This class
    // has 'operator<<' defined for it, so it can be used, for example, in
    // 'bael' logs.

    // DATA
    const bcema_Blob *d_blob_p;

    // CREATORS
    explicit bcema_BlobUtilAsciiDumper(const bcema_Blob *blob);
        // Create a hex dumper for the specified 'blob'.
};

// FREE OPERATORS
inline
bsl::ostream& operator<<(bsl::ostream&                    stream,
                         const bcema_BlobUtilAsciiDumper& rhs);
    // Ascii dump the blob referenced by the specified 'rhs' to the specified
    // 'stream'.

                       // ==============================
                       // struct bcema_BlobUtilHexDumper
                       // ==============================

struct bcema_BlobUtilHexDumper {
    // Utility for hex dumping a blob to standard output streams.  This class
    // has 'operator<<' defined for it, so it can be used, for example, in
    // 'bael' logs.

    // DATA
    const bcema_Blob *d_blob_p;
    int               d_offset;
    int               d_length;

    // CREATORS
    explicit bcema_BlobUtilHexDumper(const bcema_Blob *blob);
        // Create a hex dumper for the specified 'blob'.

    bcema_BlobUtilHexDumper(const bcema_Blob *blob, int offset, int length);
        // Create a hex dumper for the specified 'blob' that dumps the
        // specified 'length' bytes starting at the specified 'offset'.
};

// FREE OPERATORS
inline
bsl::ostream& operator<<(bsl::ostream&                  stream,
                         const bcema_BlobUtilHexDumper& rhs);
    // Hex dump the blob referenced by the specified 'rhs' to the specified
    // 'stream'.

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                              // ---------------------
                              // struct bcema_BlobUtil
                              // ---------------------

// CLASS METHODS
inline
void bcema_BlobUtil::append(bcema_Blob        *dest,
                            const bcema_Blob&  source,
                            int                offset)
{
    append(dest, source, offset, source.length() - offset);
}

inline
void bcema_BlobUtil::append(bcema_Blob *dest, const bcema_Blob& source)
{
    append(dest, source, 0, source.length());
}

inline
void bcema_BlobUtil::append(bcema_Blob        *dest,
                            const bcema_Blob&  source,
                            int                offset,
                            int                length,
                            bslma_Allocator   *)
{
    return append(dest, source, offset, length);
}

inline
void bcema_BlobUtil::append(bcema_Blob        *dest,
                            const bcema_Blob&  source,
                            int                offset,
                            bslma_Allocator   *)
{
    return append(dest, source, offset);
}

inline
void bcema_BlobUtil::append(bcema_Blob        *dest,
                            const bcema_Blob&  source,
                            bslma_Allocator   *)
{
    return append(dest, source);
}

inline
void bcema_BlobUtil::append(bcema_Blob *dest,
                            const char *source,
                            int         length)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(dest->numDataBuffers())) {
        const int lastDataBufIdx = dest->numDataBuffers() - 1;
        const bcema_BlobBuffer& lastBuf = dest->buffer(lastDataBufIdx);
        const int offsetInBuf = dest->lastDataBufferLength();
        if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(
                                     lastBuf.size() - offsetInBuf >= length)) {
            dest->setLength(dest->length() + length);
            std::memcpy(lastBuf.buffer().ptr() + offsetInBuf, source, length);
            return;
        }
    }
    BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
    append(dest, source, 0, length);
}

inline
void bcema_BlobUtil::insert(bcema_Blob        *dest,
                            int                destOffset,
                            const bcema_Blob&  source,
                            int                sourceOffset)
{
    insert(dest,
           destOffset,
           source,
           sourceOffset,
           source.length() - sourceOffset);
}

inline
void bcema_BlobUtil::insert(bcema_Blob        *dest,
                            int                destOffset,
                            const bcema_Blob&  source)
{
    insert(dest, destOffset, source, 0, source.length());
}

inline
bsl::ostream& bcema_BlobUtil::hexDump(bsl::ostream&     stream,
                                      const bcema_Blob& source)
{
    return hexDump(stream, source, 0, source.length());
}

template <typename STREAM>
STREAM& bcema_BlobUtil::read(STREAM& stream, bcema_Blob *dest, int numBytes)
{
    dest->setLength(numBytes);

    for (int numBytesRemaining = numBytes, i = 0; 0 < numBytesRemaining; ++i) {
        BSLS_ASSERT_SAFE(i < dest->numBuffers());

        bcema_BlobBuffer buffer = dest->buffer(i);

        const int bytesToRead = numBytesRemaining < buffer.size()
                              ? numBytesRemaining
                              : buffer.size();

        stream.getArrayInt8(buffer.data(), bytesToRead);

        numBytesRemaining -= bytesToRead;
    }

    return stream;
}

template <typename STREAM>
STREAM& bcema_BlobUtil::write(STREAM& stream, const bcema_Blob& source)
{
    int numBytes = source.length();

    for (int numBytesRemaining = numBytes, i = 0; 0 < numBytesRemaining; ++i) {
        BSLS_ASSERT_SAFE(i < source.numBuffers());

        bcema_BlobBuffer buffer = source.buffer(i);

        const int bytesToWrite = numBytesRemaining < buffer.size()
                               ? numBytesRemaining
                               : buffer.size();

        stream.putArrayInt8(buffer.data(), bytesToWrite);

        numBytesRemaining -= bytesToWrite;
    }

    return stream;
}

template <typename STREAM>
int bcema_BlobUtil::write(STREAM&           stream,
                          const bcema_Blob& source,
                          int               sourcePosition,
                          int               numBytes)
{
    BSLS_ASSERT(0 <= sourcePosition);
    BSLS_ASSERT(0 <= numBytes);

    if (sourcePosition + numBytes > source.length()) {
        return -1;
    }

    int bufferIndex  = 0;
    int bytesSkipped = 0;
    while (bytesSkipped + source.buffer(bufferIndex).size() <= sourcePosition)
    {
        bytesSkipped += source.buffer(bufferIndex).size();
        ++bufferIndex;
    }

    int bytesRemaining = numBytes;
    while (0 < bytesRemaining) {
        const bcema_BlobBuffer& buffer = source.buffer(bufferIndex);

        const int startingIndex = 0 < bytesSkipped || 0 == bufferIndex
                                ? sourcePosition - bytesSkipped
                                : 0;

        const int bytesToCopy = bytesRemaining > buffer.size() - startingIndex
                              ? buffer.size() - startingIndex
                              : bytesRemaining;

        stream.putArrayInt8(buffer.data() + startingIndex, bytesToCopy);
        if (!stream) {
            return -1;
        }

        bytesRemaining -= bytesToCopy;
        bytesSkipped = 0;
        ++bufferIndex;
    }

    BSLS_ASSERT(bytesRemaining == 0);
    return 0;
}

                      // --------------------------------
                      // struct bcema_BlobUtilAsciiDumper
                      // --------------------------------

// CREATORS
inline
bcema_BlobUtilAsciiDumper::bcema_BlobUtilAsciiDumper(const bcema_Blob *blob)
: d_blob_p(blob)
{
}

// FREE OPERATORS
inline
bsl::ostream& operator<<(bsl::ostream&                    stream,
                         const bcema_BlobUtilAsciiDumper& rhs)
{
    return bcema_BlobUtil::asciiDump(stream, *rhs.d_blob_p);
}

                       // ------------------------------
                       // struct bcema_BlobUtilHexDumper
                       // ------------------------------

// CREATORS
inline
bcema_BlobUtilHexDumper::bcema_BlobUtilHexDumper(const bcema_Blob *blob)
: d_blob_p(blob)
, d_offset(0)
, d_length(blob->length())
{
}

inline
bcema_BlobUtilHexDumper::bcema_BlobUtilHexDumper(const bcema_Blob *blob,
                                                 int               offset,
                                                 int               length)
: d_blob_p(blob)
, d_offset(offset)
, d_length(bsl::min(length, blob->length() - offset))
{
}

// FREE OPERATORS
inline
bsl::ostream& operator<<(bsl::ostream&                  stream,
                         const bcema_BlobUtilHexDumper& rhs)
{
    return bcema_BlobUtil::hexDump(stream,
                                   *rhs.d_blob_p,
                                   rhs.d_offset,
                                   rhs.d_length);
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2005
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
