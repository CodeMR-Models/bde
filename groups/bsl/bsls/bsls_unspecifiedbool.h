// bsls_unspecifiedbool.h                                             -*-C++-*-
#ifndef INCLUDED_BSLS_UNSPECIFIEDBOOL
#define INCLUDED_BSLS_UNSPECIFIEDBOOL

#ifndef INCLUDED_BSLS_IDENT
#include <bsls_ident.h>
#endif
BSLS_IDENT("$Id: $")

//@PURPOSE: Provide a utility class supporting the unspecified 'bool' idiom.
//
//@CLASSES:
//  bslsl_UnspecifiedBool: utility class template 
//
//@AUTHOR: Alisdair Meredith (ameredith1@bloomberg.net)
//
//@DESCRIPTION: This component provides a class template that can be used to
// manufacture an "unspecified boolean type" that is distinct for each class
// that instantiates it.  Note that classes supplying an implicit conversion
// to an unspecified bool type will be equality comparable (using 'operator=='
// and 'operator!=') through this conversion.  Private equality and inequality
// operators should be added to the class definition unless this comparison is
// desired.  It is important that each class produces a distinct unspecified
// bool type, as otherwise objects of different class types would compare equal
// through this same conversion.  Note that this component should become
// redundant when all of our compilers support "explicit conversion operators",
// a new feature of C++11.  An 'explicit operator bool()' conversion operator
// is superior to this C++98 idiom in all ways.
//
// NOTE THAT THIS COMPONENT IS A PRIVATE IMPLEMENTATION DETAIL FOR BDE AND NOT
// SUPPORTED FOR GENERAL USE.
//
///Usage
///-----
// In this section we show intended usage of this component.
//
///Example 1: ....
///- - - - - - - -
// A common requirement for "smart pointer" types is to emulate the native
// pointer types, and in particular support testing for "null" or "empty" 
// pointer values as a simple boolean conversion in 'if' and 'while' clauses.
// We will demonstrate with a simple smart pointer type, 'SimplePtr', that
// holds a pointer value but does not claim ownership or any responsibility for
// the lifetime of the pointed-to object.  It will act as a "simple" native
// pointer.
//..
//  template <class T>
//  class SimplePtr
//  {
//      // This class holds a pointer to a single object, and provides a subset
//      // of the regular pointer operatiors.  For example, it can be
//      // dereferenced with 'operator*' and tested as a boolean value to see
//      // if it is null.  Conversely, it does not support pointer arithmetic.
//    private:
//      // DATA
//      T *d_ptr;  // address of the referenced object
//
//    public:
//      // CREATORS
//      explicit SimplePtr(T *ptr = 0) : d_ptr(ptr) {}
//          // Create a 'SimplePtr' what the value of the specified 'ptr'.
//
//      //! ~SimplePtr() = default;
//          // Destroy this object.  Note that this trivial destructor is
//          // generated by the compiler.
//
//      // ACCESSORS
//      T & operator*() const  { return *d_ptr; }
//          // Return a reference to the object pointed to by this
//          // 'SimplePtr'.
//
//      T * operator->() const { return d_ptr; }
//          // Return the held 'd_ptr'.
//..
// Next we define, for conventience, an alias for a unique type that is
// implcititly convertible to bool.  Note that we pass the current template
// instantiation to the 'bsls_UnspecefiedBool' template in order to guarantee
// a unique name, even for different instantiation of this same 'SimplePtr'
// template.
//..
//      typedef typename bsls_UnspecifiedBool<SimplePtr>::BoolType BoolType;
//..
// Now we can define a boolean conversion operator that tests whether or not
// this 'SimplePtr' object is holding a null pointer, or a valid address.  Note
// that we do not need to define 'operator!' as this single boolean conversion
// operator will be invoked with the correct semantics when the user tries that
// operator.
//..
//      operator BoolType() const {
//          return d_ptr
//               ? bsls_UnspecifiedBool<SimplePtr>::trueValue()
//               : bsls_UnspecifiedBool<SimplePtr>::falseValue();
//      }
//  }; // class simple_pointer
//..
// Next we will write a simple test function, creating a couple of 'SimplePtr'
// objects, one "null" and the other with a well-defined address.
//..
//  void runTests() {
//      int i = 3;
//      SimplePtr<int> p1;
//      SimplePtr<int> p2(&i);
//..
// Finally we test each 'SimplePtr' value, as if they were raw pointers.
//..
//      assert(!p1);
//      assert(p2);
//      if (p2) {
//          assert(3 == *p2);
//      }
//  }
//..

namespace BloombergLP {

            // =====================================================
            // struct blsl_UnspecifiedBoolHelper
            // =====================================================

template<class BSLS_HOST_TYPE>
struct bsls_UnspecifiedBool {
    // This 'struct' provides a member, 'd_member', whose pointer-to-member may
    // be used as an "unspecified boolean type" for implicit conversion
    // operators.

private:
    int d_member;
        // This data member is used solely for taking its address to return a
        // non-null pointer-to-member.  Note that the *value* of 'd_member' is
        // not used.

public:
    typedef int bsls_UnspecifiedBool::* BoolType;
        // Alias of a distinct type that is implicitly convertible to 'bool',
        // but does not promote to 'int'.

    static BoolType falseValue();
        // Return a value that converts to the 'bool' value 'false'.

    static BoolType trueValue();
        // Return a value that converts to the 'bool' value 'true'.
};


// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

template<class BSLS_HOST_TYPE>
inline int bsls_UnspecifiedBool<BSLS_HOST_TYPE>::* 
bsls_UnspecifiedBool<BSLS_HOST_TYPE>::falseValue()
{
    return false;
}

template<class BSLS_HOST_TYPE>
inline int bsls_UnspecifiedBool<BSLS_HOST_TYPE>::* 
bsls_UnspecifiedBool<BSLS_HOST_TYPE>::trueValue()
{
    return &bsls_UnspecifiedBool::d_member;
}

}  // close namespace BloombergLP

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2011
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
