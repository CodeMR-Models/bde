// bsls_unspecifiedbool.h                                             -*-C++-*-
#ifndef INCLUDED_BSLS_UNSPECIFIEDBOOL
#define INCLUDED_BSLS_UNSPECIFIEDBOOL

#ifndef INCLUDED_BSLS_IDENT
#include <bsls_ident.h>
#endif
BSLS_IDENT("$Id: $")

//@PURPOSE: Provide a utility class supporting the unspecified 'bool' idiom.
//
//@CLASSES:
//  bsls_UnspecifiedBool: utility class template
//
//@AUTHOR: Alisdair Meredith (ameredith1@bloomberg.net)
//
//@DESCRIPTION: This component should *not* be used outside of the 'bsl'
// package at this time.
//
// This component provides a class template that can be used to manufacture an
// "unspecified boolean type" that is distinct for each class that instantiates
// it.  Note that classes supplying an implicit conversion to an unspecified
// bool type will be equality comparable (using 'operator==' and 'operator!=')
// through this conversion.  Private equality and inequality operators should
// be added to the class definition unless this comparison is desired.  It is
// important that each class produces a distinct unspecified bool type, as
// otherwise objects of different class types would compare equal through this
// same conversion.  Note that this component should become redundant when all
// of our compilers support "explicit conversion operators", a new feature of
// C++11.  An 'explicit operator bool()' conversion operator is superior to
// this C++98 idiom in all ways.
//
///Usage
///-----
// In this section we show intended usage of this component.
//
///Example 1: A Simple Smart Pointer
///- - - - - - - - - - - - - - - - -
// A common requirement for "smart pointer" types is to emulate the native
// pointer types, and in particular support testing for "null" or "empty"
// pointer values as a simple boolean conversion in 'if' and 'while' clauses.
// We here demonstrate how implement a simple smart pointer type, 'SimplePtr',
// using this component to safely implement the boolean conversion.
// 'SimplePtr' objects hold a pointer value but do not claim ownership or any
// responsibility for the lifetime of the pointed-to object.  They act as a
// "simple" native pointer.
//..
//  template <class TYPE>
//  class SimplePtr
//  {
//      // This class holds a pointer to a single object, and provides a subset
//      // of the regular pointer operators.  For example, it can be
//      // dereferenced with 'operator*' and tested as a boolean value to see
//      // if it is null.  Conversely, it does not support pointer arithmetic.
//
//    private:
//      // DATA
//      TYPE *d_ptr;  // address of the referenced object
//
//    public:
//      // CREATORS
//      explicit SimplePtr(TYPE *ptr = 0) : d_ptr(ptr) {}
//          // Create a 'SimplePtr' having the value of the specified 'ptr'.
//
//      //! ~SimplePtr() = default;
//          // Destroy this object.  Note that this trivial destructor is
//          // generated by the compiler.
//
//      // ACCESSORS
//      TYPE& operator*() const  { return *d_ptr; }
//          // Return a reference to the object pointed to by this
//          // 'SimplePtr'.
//
//      TYPE *operator->() const { return d_ptr; }
//          // Return the held 'd_ptr'.
//..
// Next we define, for convenience, an alias for a unique type that is
// implicitly convertible to 'bool'.  Note that we pass the current template
// instantiation to the 'bsls_UnspecifiedBool' template to guarantee
// a unique name, even for different instantiations of this same 'SimplePtr'
// template.
//..
//      typedef typename bsls_UnspecifiedBool<SimplePtr>::BoolType BoolType;
//..
// Now we can define a boolean conversion operator that tests whether or not
// this 'SimplePtr' object is holding a null pointer, or a valid address.  Note
// that we do not need to define 'operator!' as this single boolean conversion
// operator is invoked with the correct semantics when the user tries that
// operator.
//..
//      operator BoolType() const {
//          return d_ptr
//               ? bsls_UnspecifiedBool<SimplePtr>::trueValue()
//               : bsls_UnspecifiedBool<SimplePtr>::falseValue();
//      }
//  }; // class SimplePtr
//..
// Finally, we write a simple test function, creating a couple of 'SimplePtr'
// objects, one "null", and the other with a well-defined address.
//..
//  void runTests() {
//
//      SimplePtr<int> p1;  // default ctor sets to null
//      assert(!p1);
//
//      int            i = 3;
//      SimplePtr<int> p2(&i);
//
//      if (p2) {
//          assert(3 == *p2);
//      }
//  }
//..
// Notice that 'SimplePtr' objects behave as native pointers.  They should
// be tested before dereferencing (as they could be null).

namespace BloombergLP {

                        // ===========================
                        // struct bsls_UnspecifiedBool
                        // ===========================

template<class BSLS_HOST_TYPE>
struct bsls_UnspecifiedBool {
    // This 'struct' provides a member, 'd_member', whose pointer-to-member may
    // be used as an "unspecified boolean type" for implicit conversion
    // operators.

  private:
    int d_member;
        // This data member is used solely for taking its address to return a
        // non-null pointer-to-member.  Note that the *value* of 'd_member' is
        // not used.

  public:
    typedef int bsls_UnspecifiedBool::* BoolType;
        // Alias of a distinct type that is implicitly convertible to 'bool',
        // but does not promote to 'int'.

    static BoolType falseValue();
        // Return a value that converts to the 'bool' value 'false'.

    static BoolType trueValue();
        // Return a value that converts to the 'bool' value 'true'.
};


// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

template<class BSLS_HOST_TYPE>
inline
int bsls_UnspecifiedBool<BSLS_HOST_TYPE>::*
bsls_UnspecifiedBool<BSLS_HOST_TYPE>::falseValue()
{
    return false;
}

template<class BSLS_HOST_TYPE>
inline
int bsls_UnspecifiedBool<BSLS_HOST_TYPE>::*
bsls_UnspecifiedBool<BSLS_HOST_TYPE>::trueValue()
{
    return &bsls_UnspecifiedBool::d_member;
}

}  // close enterprise namespace

#endif

// ---------------------------------------------------------------------------
// NOTICE:
//      Copyright (C) Bloomberg L.P., 2011
//      All Rights Reserved.
//      Property of Bloomberg L.P. (BLP)
//      This software is made available solely pursuant to the
//      terms of a BLP license agreement which governs its use.
// ----------------------------- END-OF-FILE ---------------------------------
