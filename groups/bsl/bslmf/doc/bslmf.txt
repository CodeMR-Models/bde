 bslmf.txt

@PURPOSE: Provide meta-function versions of useful coding constructs.

@MNEMONIC: Basic Standard Library Meta-Functions (bslmf)

@AUTHOR: Herve Bronnimann (hbronnim)

@DESCRIPTION: The 'bdemf' package provides meta-function equivalents of 
 certain useful coding constructs.  A meta-function is a template-based,
 compile-time construct that behaves like a (runtime) function in that it
 "evaluates" arguments and does something different based on the input
 it is passed (in the case of templates, the input it is instantiated with).
 'bslmf' provides metafunctions to evaluate (at compile time) constructs such
 as the following: an 'if'-statement equivalent, whether a (template) argument
 is a fundamental type, whether an argument is an 'enum' type, whether two
 arguments have the same type, and more.

 The "return value" of that function is generally a compile-time constant under
 the form of a nested 'enum' 'VALUE', or in some cases a nested 'Type', or
 both.  For instance, in order to evaluate whether two types are the same, one
 could write a meta-function predicate (evaluating to 0 or 1) as follows:
..
    template <class U, class V>
    struct IsSame {
        // This 'struct' provides a meta function parameterized by two types
        // 'U' and 'V', that takes 'VALUE == 0' unless 'U' and 'V' are the same
        // type, in which case it takes 'VALUE == 1'.

        // PUBLIC TYPES
        enum { VALUE = 0 };
        typedef bslmf_MetaInt<VALUE>  Type;
    };

    // SPECIALIZATIONS
    template <class T>
    struct IsSame<T, T> {
        // This specialization of the 'IsSame' meta function is parameterized
        // by a single type 'T' and is selected if the two parameters of
        // 'IsSame', 'U' and 'V', are both equal to 'T'.  It takes
        // 'VALUE == 1'.

        // PUBLIC TYPES
        enum { VALUE = 1 };
        typedef bslmf_MetaInt<VALUE>  Type;
    };
..
 Note the use of a 'bslmf_MetaInt' nested type usually employed for function
 dispatching.  See the 'bslmf_issame' component-level documentation for a more
 thorough usage example.

 Other meta-functions don't have a 'VALUE', but apply some type transformation
 (e.g., removing top-level 'const' qualifiers, decaying array and function
 types to pointer types).  Those usually have a nested 'Type'.

/Hierarchical Synopsis
/---------------------
 'bslmf' currently has 26 components having 8 levels of physical dependency.
..
  8. bslmf_enableif
  
  7. bslmf_forwardingtype
     bslmf_ispolymorphic
  
  6. bslmf_functionpointertraits
     bslmf_isclass
     bslmf_isenum
     bslmf_memberfunctionpointertraits
  
  5. bslmf_addreference
     bslmf_arraytopointer
     bslmf_if
     bslmf_isconvertible
     bslmf_removereference
     bslmf_switch
     bslmf_typelist
  
  4. bslmf_isarray
     bslmf_isfundamental
     bslmf_ispointer
     bslmf_ispointertomember
     bslmf_issame
     bslmf_isvoid
     bslmf_nil
  
  3. bslmf_metaint
  
  2. bslmf_tag
  
  1. bslmf_anytype
     bslmf_assert
     bslmf_removecvq
..

/Component Synopsis
/------------------
 The following is a brief synopsis of the components in 'bslmf'.  For the sake
 of brevity, we sometimes blur the distinction between a component and the
 primary types that the component provides.  We remind the reader that, in
 general, the distinction between a component and a class is important.
..
  'bslmf_addreference'      - add "reference-ness" to a type
  'bslmf_anytype'           - a type convertible from any type
  'bslmf_arraytopointer'    - type transformation decaying arrays to pointers
  'bslmf_assert'            - compile-time assertion
  'bslmf_forwardingtype'    - type transformation 
  'bslmf_enableif'          - remove candiate from overload sets
  'bslmf_functionpointertraits'
                            - extracting return and argument types from a
                              function type
  'bslmf_if'                - compile-time selection of types
  'bslmf_isarray'           - identifying array types
  'bslmf_isclass'           - identifying class types
  'bslmf_isconvertible'     - determining if one type can be converted into
                              another (without raising compiler errors if not)
  'bslmf_isenum'            - identifying enumeration types
  'bslmf_isfundamental'     - identifying fundamental types
  'bslmf_ispointer'         - identifying pointer types
  'bslmf_ispointertomember' - identifying pointer-to-member types
  'bslmf_ispolymorphic'     - identifying polymorphic types
  'bslmf_issame'            - testing whether two types are the same
  'bslmf_isvoid'            - compile-time test for 'void' types
  'bslmf_memberfunctionpointertraits'
                            - extracting class, return, and argument types from
                              a member function type
  'bslmf_metaint'           - provide distinct types for each integral value
  'bslmf_nil'               - a type distinct from any other type, to indicate
                              the absence of a type
  'bslmf_removecvq'         - removing top-level 'const' and 'volatile'
                              qualifiers
  'bslmf_removereference'   - removing top-level '&'
  'bslmf_switch'            - compile-time selection of type based on integral
                              value
  'bslmf_tag'               - provide distinct types for each integral value
  'bslmf_typelist'          - bundle several types into a single type
..
