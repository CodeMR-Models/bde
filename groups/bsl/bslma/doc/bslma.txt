 bslma.txt

@PURPOSE: Provide allocators, guards, and other memory-management tools.

@MNEMONIC: Basic Standard Library Memory Allocators (bslma)

@AUTHOR: Tom Marshall (tmarshal), Herve Bronnimann (hbronnim)

@DESCRIPTION: The 'bslma' package provides an allocator protocol (i.e., a pure
 abstract interface) and a variety of concrete allocators derived from this
 protocol, as well as other memory-dispensing mechanisms and various guard
 constructs to prevent loss in case of exceptions.  In addition, 'bslma' also
 provides a mechanism for installing a "default allocator" that will then be
 visible to all BDE and BDE-compliant code throughout that process.  If this
 mechanism is not invoked explicitly, then an allocator that uses global 'new'
 and 'delete' is the BDE default allocator.  This topic is discussed in more
 detail below.

/Hierarchical Synopsis
/---------------------
 The 'bslma' package currently has 19 components having 6 levels of physical
 dependency.  The table below shows the hierarchical ordering of the
 components.  The order of components within each level is not architecturally
 significant, just alphabetical.
..
  7. bslma_sequentialallocator             [DEPRECATED]

  6. bslma_autorawdeleter
     bslma_destructorproctor
     bslma_sequentialpool                  [DEPRECATED]
     bslma_testallocatormonitor

  5. bslma_autodeallocator
     bslma_autodestructor
     bslma_defaultallocatorguard
     bslma_deallocatorguard
     bslma_destructorguard
     bslma_infrequentdeleteblocklist       [DEPRECATED]
     bslma_rawdeleterguard
     bslma_deallocatorproctor
     bslma_rawdeleterproctor

  4. bslma_default
     bslma_testallocator

  3. bslma_bufferallocator                 [DEPRECATED]   
     bslma_mallocfreeallocator
     bslma_managedallocator
     bslma_newdeleteallocator
     bslma_usesbslmaallocator
     bslma_testallocatorexception

  2. bslma_allocator

  1. bslma_deleterhelper
..

/Component Synopsis
/------------------
: o 'bslma_allocator':
:      Provide a pure abstract interface for memory-allocation mechanisms.
:
: o 'bslma_autodeallocator':
:      Provide a range proctor to managed a block of memory.
:
: o 'bslma_autodestructor':
:      Provide a range proctor to manage an array of objects.
:
: o 'bslma_autorawdeleter':
:      Provide a range proctor to manage a sequence objects.
:
: o 'bslma_bufferallocator':                                       [DEPRECATED]
:      Provide an efficient memory allocator that uses a user-supplied buffer.
:
: o 'bslma_deallocatorguard':
:      Provide a guard to unconditionally manage a block of memory.
:
: o 'bslma_deallocatorproctor':
:      Provide a proctor to conditionally manage a block memory.
:
: o 'bslma_default':
:      Provide utilities to set/fetch the default and global allocators.
:
: o 'bslma_defaultallocatorguard':
:      Provide scoped guard to temporarily change the default allocator.
:
: o 'bslma_deleterhelper':
:      Provide namespace for functions used to delete objects.
:
: o 'bslma_destructorguard':
:      Provide a guard to unconditionally manage an object.
:
: o 'bslma_destructorproctor':
:      Provide a proctor to conditionally manage an object.
:
: o 'bslma_infrequentdeleteblocklist':                             [DEPRECATED]
:      Provide a manager supporting fast memory allocations of varying sizes.
:
: o 'bslma_mallocfreeallocator':
:      Provide malloc/free adaptor to 'bslma::Allocator' protocol.
:
: o 'bslma_managedallocator':
:      Provide a protocol for memory allocators that support 'release'.
:
: o 'bslma_newdeleteallocator':
:      Provide singleton new/delete adaptor to 'bslma::Allocator' protocol.
:
: o 'bslma_rawdeleterguard':
:      Provide a guard to unconditionally manage an object.
:
: o 'bslma_rawdeleterproctor':
:      Provide a proctor to conditionally manage an object.
:
: o 'bslma_sequentialallocator':                                   [DEPRECATED]
:      Provide an allocator supporting fast memory allocations of varied sizes.
:
: o 'bslma_sequentialpool':                                        [DEPRECATED]
:      Provide a pool supporting fast memory allocations of varied sizes.
:
: o 'bslma_testallocator':
:      Provide instrumented malloc/free allocator to track memory usage.
:
: o 'bslma_testallocatorexception':
:      Provide an exception class for memory allocation operations.
:
: o 'bslma_testallocatormonitor':
:      Provide a mechanism to summarize 'bslma::TestAllocator' object use.
:
: o 'bslma_usesbslmaallocator':
:      Provide a metafunction that indicates the use of bslma allocators.

/Component Overview
/------------------
 This section summarizes the components that are available in 'bslma'.
 Subsequent sections provide more detail on component selection, performance,
 and usage.

/'bslma_allocator'
/- - - - - - - - -
 'bslma_allocator' defines a protocol (i.e., an abstract base class) requiring
 the following interface: 'allocate' for memory allocation, and 'deallocate',
 for allocation and deallocation of individual memory blocks.

/'bslma_autodeallocator'
/- - - - - - - - - - - -
 'bslma_autodeallocator' provides a range proctor class to manage a sequence
 of blocks of (otherwise-unmanaged) memory of a parameterized 'TYPE' supplied
 at construction.  If not explicitly released, the sequence of managed memory
 blocks are deallocated automatically when the range proctor goes out of scope
 by freeing the memory using the parameterized 'ALLOCATOR' (allocator or pool)
 supplied at construction.  This proctor mechanism is useful in guarding
 against memory leaks, e.g., when additional allocations may throw an
 exception.

/'bslma_autodestructor'
/ - - - - - - - - - - -
 'bslma_autodestructor' provides a range proctor class to manage a sequence
 of blocks of (otherwise-unmanaged) memory of a parameterized 'TYPE' supplied
 at construction.  If not explicitly released, the sequence of managed memory
 blocks are destroyed automatically when the range proctor goes out of scope
 by calling each (managed) object's destructor.  This proctor mechanism is
 useful in guarding against memory leaks, e.g., when additional allocations
 may throw an exception.

/'bslma_autorawdeleter'
/ - - - - - - - - - - -
 'bslma_autorawdeleter' provides a range proctor class template to manage a
 sequence of (otherwise-unmanaged) objects of parameterized 'TYPE' supplied at
 construction.  If not explicitly released, the sequence of managed objects are
 deleted automatically when the range proctor goes out of scope by iterating
 over each object, first calling the (managed) object's destructor, and then
 freeing its memory footprint by invoking the 'deallocate' method of an
 allocator (or pool) of parameterized 'ALLOCATOR' type also supplied at
 construction.  This proctor mechanism is useful in guarding against memory
 leaks, e.g., when additional allocations may throw an exception.

/'bslma_bufferallocator'
/ - - - - - - - - - - -
 'bslma_bufferallocator' provides an allocator that implements the
 'bslma::Allocator' protocol and sequentially allocates memory blocks from a
 fixed-size buffer that is supplied by the user at construction.  If an
 allocation request exceeds the remaining space in the buffer, the return
 value is the result of invoking an optional callback function that was
 supplied at construction, or zero if no callback was specified.  This
 component also provides static utility methods for allocating memory directly
 from a user-specified buffer.  This component is *deprecated* and clients
 should use 'bdema_bufferedsequentialallocator' instead.

/'bslma_deallocatorguard'
/ - - - - - - - - - - - -
 'bslma_deallocatorguard' provides a guard class template to *unconditionally*
 manage a block of (otherwise-unmanaged) memory.  The managed memory is
 deallocated automatically when the guard object goes out of scope using the
 'deallocate' method of the parameterized 'ALLOCATOR' (allocator or pool)
 supplied at construction.  This guard mechanism is useful in ensuring that a
 dynamically allocated raw memory resource is safely deallocated in the
 presense of multiple return satements or exceptions.

/'bslma_deallocatorproctor'
/ - - - - - - - - - - - - -
 'bslma_deallocatorproctor' provides a proctor class template to
 *conditionally* manage a block of (otherwise-unmanaged) memory.  If not
 explicitly released, the managed memory is deallocated automatically when the
 proctor object goes out of scope by freeing the memory using the parameterized
 'ALLOCATOR' (allocator or pool) supplied at construction.  This proctor
 mechanism is useful in guarding against memory leaks, e.g., when additional
 allocations may throw an exception.

/'bslma_default'
/- - - - - - - -
 'bslma_default' provides a namespace for a set of utility functions that
 manage the addresses of two static (global) memory allocator instances: the
 *default* allocator and the *global* allocator.  The default allocator is the
 allocator used by default by all BDE components.  The global allocator is the
 allocator used by default to construct global singleton objects.  Each of
 these allocators are of type derived from 'bslma::Allocator'.

/'bslma_defaultallocatorguard'
/- - - - - - - - - - - - - - -
 'bslma_defaultallocatorguard' provides a mechanism that serves as a "scoped
 guard" to enable the temporary replacement of the process-wide default
 allocator.  This functionality is intended for *testing* only, and in no
 event should this component be used except at the very beginning of 'main'.

/'bslma_deleterhelper'
/- - - - - - - - - - -
 'bslma_deleterhelper' provides non-primitive procedures used to delete objects
 of parameterized 'TYPE' by first calling the destructor of the object, and
 then freeing the memory footprint of the object using a parameterized
 'ALLOCATOR' (allocator or pool) provided as a second argument.

/'bslma_destructorguard'
/- - - - - - - - - - - -
 'bslma_destructorguard' provides a guard class template to *unconditionally*
 manage an (otherwise-unmanaged) object of parameterized 'TYPE' supplied at
 construction.  The managed object is destroyed automatically when the guard
 object goes out of scope by calling the (managed) object's destructor.  This
 guard mechanism is useful in ensuring that a dynamically allocated raw memory
 resource is safely deallocated in the presense of multiple return satements
 or exceptions.

/'bslma_destructorproctor'
/- - - - - - - - - - - - -
 'bslma_destructorproctor' provides a proctor class template to *conditionally*
 manage an (otherwise-unmanaged) object of parameterized 'TYPE' supplied at
 construction.  If not explicitly released, the managed object is destroyed
 automatically when the proctor object goes out of scope by calling the
 object's destructor.  This proctor mechanism is useful in guarding against
 memory leaks, e.g., when additional allocations may throw an exception.

/'bslma_infrequentdeleteblocklist'
/ - - - - - - - - - - - - - - - -
 'bslma_infrequentdeleteblocklist' provides a memory manager that allocates
 and manages a sequence of memory blocks, each potentially of a different size
 as specified in the 'allocate' method's invocation.  The
 'bslma::InfrequentDeleteBlockList' object's 'release' method deallocates the
 entire sequence of memory blocks, as does its destructor.  This component is
 *deprecated* and clients should use 'bdema_infrequentdeleteblocklist'
 instead.

/'bslma_mallocfreeallocator'
/- - - - - - - - - - - - - -
 'bslma_mallocfreeallocator' provides a wrapper around 'std::malloc' and
 'std::free' that adheres to the 'bslma::Allocator' protocol (i.e., provides
 'allocate' and 'deallocate' functions).

/'bslma_managedallocator'
/ - - - - - - - - - - - -
 'bslma_managedallocator' defines a protocol that extends the
 'bslma::Allocator' protocol with a 'release' function.  'release' indicates
 that all memory allocated since the previous 'release' call is to be
 deallocated.

/'bslma_newdeleteallocator'
/ - - - - - - - - - - - - -
 'bslma_newdeleteallocator' provides a wrapper around 'operator new' and
 'operator delete' that adheres to the 'bslma::Allocator' protocol (i.e.,
 provides an 'allocate' function and a 'deallocate' function).

/'bslma_rawdeleterguard'
/- - - - - - - - - - - -
 'bslma_rawdeleterguard' provides a guard class template to *unconditionally*
 manage an (otherwise-unmanaged) object of parameterized 'TYPE' supplied at
 construction.  The managed object is deleted automatically when the guard
 object goes out of scope by first calling the (managed) object's destructor,
 and then freeing the memory using the parameterized 'ALLOCATOR' (allocator or
 pool) also supplied at construction. This guard mechanism is useful in
 ensuring that a dynamically allocated raw memory resource is safely
 deallocated in the presense of multiple return satements or exceptions.

/'bslma_rawdeleterproctor'
/- - - - - - - - - - - - -
 'bslma_rawdeleterproctor' provides a proctor class template to conditionally
 manage an (otherwise-unmanaged) object of parameterized 'TYPE' supplied at
 construction.  If not explicitly released, the managed object is deleted
 automatically when the proctor object goes out of scope by first calling the
 (managed) object's destructor, and then freeing the memory using the
 parameterized 'ALLOCATOR' (allocator or pool) also supplied at construction.
 This proctor mechanism is useful in guarding against memory leaks, e.g., when
 additional allocations may throw an exception.

/'bslma_sequentialallocator'
/ - - - - - - - - - - - - -
 'bslma_sequentialallocator' provides an allocator that dispenses memory
 blocks of any requested size from an internal buffer or an optional
 user-supplied buffer.  If an allocation request exceeds the remaining free
 memory space in the pool, the pool either replenishes its buffer with new
 memory to satisfy the request, or returns a separate memory block, depending
 on whether the request size exceeds an optionally specified maximum buffer
 size.  By default, buffer growth is not capped.  The 'release' method
 releases all memory allocated through this pool, as does the destructor.
 Note, however, that individual allocated blocks of memory cannot be
 separately deallocated.  This component is *deprecated* and clients should
 use 'bdema_sequentialallocator' instead.

/'bslma_sequentialpool'
/ - - - - - - - - - - -
 'bslma_sequentialpool' provides a memory pool that dispenses memory blocks of
 any requested size from an internal buffer or an optional user-supplied
 buffer.  If an allocation request exceeds the remaining free memory space in
 the pool, the pool either replenishes its buffer with new memory to satisfy
 the request, or returns a separate memory block, depending on whether the
 request size exceeds an optionally specified maximum buffer size.  By
 default, buffer growth is not capped.  The 'release' method releases all
 memory allocated through this pool, as does the destructor.  Note, however,
 that individual allocated blocks of memory cannot be separately deallocated.
 This component is *deprecated* and clients should use 'bdema_sequentialpool'
 instead.

/'bslma_testallocator'
/- - - - - - - - - - -
 'bslma_testallocator' provides an instrumented allocator that implements the
 'bslma::Allocator' protocol and can be used to track various aspects of
 memory allocated from it.  This allocator memory allocator uses global
 functions 'std::malloc' and 'std::free' for allocations and deallocations.

/'bslma_testallocatorexception'
/ - - - - - - - - - - - - - - -
 'bslma_testallocatorexception' defines an exception object for use in testing
 exceptions during memory allocations.

/'bslma_testallocatormonitor'
/ - - - - - - - - - - - - - -
 'bslma_testallocatormonitor' provides a "monitor", a mechanism class, that
 allows concise tests of state change (or lack of change) in the test allocator
 provided at the monitor's construction.

/Why Use Allocators?
/-------------------
 Allocators were originally introduced into STL to provide containers an
 abstraction for the different pointer types on the Intel architecture (such as
 near and far pointers).  After the C++ standard (section 20.1.5 of the 1998
 standard) specified the requirements on an allocator type ('std::allocator')
 that use was rendered obsolete.  But the standard also specified that all
 standard containers be parameterized on an allocator type that provides users
 greater control over the memory usage of individual objects and allows an
 application to control from where that memory comes (for example: stack,
 heap, shared memory etc) and how it is distributed.  By using allocators, an
 application can ensure efficient memory usage by reducing the number of
 distinct calls to global operators 'new' and 'delete' (and functions
 'std::malloc' and 'std::free').

/Rationale for the BDE allocator model
/-------------------------------------
 Although C++ standard allocators ('std::allocator') provide users great
 control on how containers can allocate memory having a templated allocator
 argument introduces other problems.  Two containers instantiated with
 different allocator types refer to different types making interoperability
 between them difficult and limiting the allocator type to a per-class (as
 opposed to a per-instance) basis.  The standard's requirement of a templated
 allocator type is limited to containers and does not address other
 user-defined types that allocate memory. Although users can augment their
 types to take a templated allocator type such use is likely to be tedious and
 to result in significant object code increase. Finally, the standard is
 unclear with regards to the copy semantics of stateful allocators.

 The BDE allocator model provides a solution to these issues.  BDE provides an
 allocator protocol and concrete allocator implementations that can be passed
 as constructor arguments (not as template parameters) to all objects that
 allocate memory.  The type of an object is unaffected by the passed-in
 allocator and the user has full control over the scope of an allocator
 instance. As the model specifies a protocol it is easier to create concrete
 implementations and use them.  The allocator model requires all elements (data
 members) of a container (object) to use the same allocator as the container
 (object). Also the allocator is not transferred on copy construction.

/Allocators and Other Memory-Dispensing Mechanisms
/-------------------------------------------------
 An allocator is a memory manager that derives from the 'bslma::Allocator'
 protocol and provides an 'allocate' method for obtaining memory, and a
 'deallocate' method for returning memory (to the allocator).  'bslma' also
 provides many memory-dispensing mechanisms that also provide an 'allocate' and
 a 'deallocate' method, but these memory managers are not properly referred to
 as "allocators", since we reserve the term "allocator" for concrete memory
 dispensers that actually derive from 'bslma::Allocator' and are therefore
 usable anywhere that a 'bslma::Allocator *' is specified.  Objects that
 dispense memory but that are not actually "allocators" are sometimes called
 "end-point allocators", and may offer performance advantages to certain
 users.  Choosing an allocation mechanisms is complex, and many factors will
 influence the decision.  The discussions here are aimed at shedding light on
 this important selection process.

 Characteristics differentiating among 'bslma' memory-allocation objects *in*
 *general* are:

: o Whether or not the object isA 'bslma_Allocator'.
:
: o Whether or not the allocator supports memory reuse.
:
: o Whether allocation requests consume the exact amount of memory requested,
:   an additive number of additional bytes, or a non-additive number of
:   additional bytes (e.g., the smallest power of two that can satisfy the
:   request).
:
: o Whether allocation requests consume the exact amount of memory requested,
:
: o Whether or not the allocator supports multi-threading.

 All 'bslma' allocators (except 'bslma::TestAllocator') are fully thread-safe
 but not thread-enabled (see the 'bsldoc_glossary.h' for terminology).

 The BDE allocators have two more differentiating properties.  First, whether
 the allocator is intended to be part of a chain (or other grouping) of
 allocators, or is an "end-point" allocator.  The former kind support the
 'bslma::Allocator' protocol.  "End-point" allocators, such as a memory pool,
 are general-purpose mechamisms designed to minimize the runtime overhead of
 allocation and deallocation on a call-by-call basis and therefore do not
 derive from 'bslma::Allocator'.  The 'bslma' package does not provide any
 end-point allocators although such implementations may be provided in
 higher-level libraries.

 Supporting a common protocol (the 'bslma::Allocator' protocol) allows passing
 conformant allocators to BDE (and other) objects requiring an allocator at
 construction.  Support of this common protocol also facilitates grouping the
 memory used by an object into one allocator.

 The BDE libraries use allocators with all classes requiring dynamic memory
 allocation, allowing clients to fine-tune memory-related performance
 characteristics by replacing the established defaults with client-chosen
 alternatives.  Because the protocol is public, clients can even write their
 own, customized implementations, and use those.  But none of these actions are
 required.  BDE components all work with a (preset) default allocator, and
 clients without special requirements need never concern themselves with
 allocators.

/'Allocator' and 'ManagedAllocator'
/----------------------------------
 A differentiating property among 'bslma' allocators is whether the allocator
 is a "managed" or "unmanaged" allocator.  Unmanaged allocators, concrete
 implementations of 'bslma::Allocator', require every allocation to be matched
 by a deallocation, similar to 'malloc' and 'free', or 'new' and 'delete'.
 Managed allocators, concrete implementations of 'bslma::ManagedAllocator',
 in addition to implementing the 'bslma::Allocator' protocol, provide
 simultaneous deallocation of all memory with one call to 'release'.  This
 'release' optimization can provide significant performance improvements if
 the only system resource held by an object (and all the objects it manages)
 is memory.  The 'bslma' package does not provide any concrete managed
 allocator implementations although such implementations may be provided in
 higher-level libraries.

/Proctors and Guards
/-------------------
 The 'bslma' package contains many components for managing
 dynamically-allocated objects.  These components can be divided along two
 dimensions:

: o What their objects do on destruction: The objects of these managers can
:   either deallocate, destroy, or delete (destroy and then deallocate) the
:   memory or object under management.
:
: o Proctors or Guards: The object managers can be divided into guards that
:   *unconditionally* deallocate, destroy, or delete their managed objects on
:   destruction and proctors that *conditionally* do so.  Proctors provide a
:   'release' method that can be invoked to release their managed objects from
:   management.

The following table categorizes the various components along these dimensions:

                Deallocation          Destruction          Deletion
            +--------------------+-------------------+-------------------+
 Proctor    | DeallocatorProctor | DestructorProctor | RawDeleterProctor |
            +--------------------+-------------------+-------------------+
 Guard      | DeallocatorGuard   | DestructorGuard   | RawDeleterGuard   |
            +--------------------+-------------------+-------------------+

 Note that the components named "raw" ('bslma_rawdeleterproctor' and
 'bslma_rawdeleterguard') should be used only if we are sure that the supplied
 pointer is !not! of a type that is a secondary base class -- i.e., the
 (managed) object's address is (numerically) the same as when it was
 originally dispensed by 'ALLOCATOR'.

 All of the object managers specified above manage an individual object or a
 block of memory but three components, 'bslma_autodeallocator',
 'bslma_autodestructor' and 'bslma_autorawdeleter' allow users to manage a
 sequence of objects or memory blocks.

/Alignment
/---------
 Alignment of an *address* in memory refers to the relative position of that
 address with respect to specific (hardware-imposed) boundaries within the
 memory space.  Any one address can be said to be on a one-byte boundary, a
 two-byte boundary, a four-byte boundary, or an eight-byte boundary.  (Clearly,
 this sequence can be extended, but, as of this writing, boundaries beyond
 eight-byte boundaries are not relevant for these discussions on any hardware
 platform of interest.  In particular, "alignment" as we are using the term
 here does not deal with page boundaries or other larger memory structures,
 although these considerations are important elsewhere.)

 In general, we also speak about the alignment of (the *first* *byte* of) an
 entity (e.g., an 'int', a 'double', or a pointer) whose size is not
 necessarily one byte.  As a practical matter, for each entity separately, some
 alignments are "safe" and some are not.  By "not safe" we mean that, for most
 platforms (e.g., all of our Unix machines), attempting to access an entity at
 an address that is not safely aligned for that entity will cause a bus error,
 crashing the program on the spot.  In the very best case, the access will
 incur a performance penalty as the memory is shifted appropriately between its
 initial address and its target address (e.g., a register).

 The BDE memory managers provide three kinds of alignment: NATURAL, MAXIMAL,
 and BYTE -- but note that BYTE alignment is also referred to as "no alignment"
 or "none" in this document, since every address is aligned to *some* byte.

 A C/C++ variable is "naturally aligned" if its size divides the numerical
 value of its address.  An address is "maximally aligned" if it can serve as a
 naturally-aligned address no matter what type of object might be stored there.
 That is, it meets the alignment requirements of the type with the maximally
 restrictive needs.

 Accessing data stored at an aligned address is *faster* on Intel platforms and
 *required* on almost all Unix platforms.  Reading (or writing) a C/C++
 variable at an unaligned address will cause a Bus Error on these Unix
 platforms, and thus crash the program.

 Normally, programmers need not worry about alignment for dynamically allocated
 memory.  The runtime system's 'new' (or 'malloc', for C) automatically return
 memory blocks beginning at maximally-aligned addresses (the C++ standard
 requires it of 'new').  All memory managers in the 'bslma' package return
 maximally-aligned memory.

 The cost of obtaining aligned addresses is twofold: an increase in the memory
 used (allocators returning aligned addresses do so by skipping bytes that
 could otherwise be used, so as to return an appropriate address), and
 additional computation time to calculate the needed alignment and subsequent
 offset.

 See the 'bsls_alignment' component for further information on the various
 alignment strategies.

/Deallocation
/------------
 Some managers may not deallocate individual items.  (The 'deallocate'
 function is almost always provided, but in these managers it performs no
 action.)  Such managers provide a 'release' function instead, which
 relinquishes *all* memory allocated by that manager since the previous
 'release' call.  All memory managers in the 'bslma' package deallocate the
 specified memory during a 'deallocate' method invocation.

/Type and Origination
/--------------------
 Most managers provide variable-sized, untyped (i.e., 'void *') memory.

 Different components manage memory in different ways, but they necessarily
 *obtain* the memory that they manage from one of the two usual sources: the
 heap or the stack.  The 'bslma::NewDeleteAllocator' is hard-coded to obtain
 memory from the heap -- its underlying source is 'operator new'.

 The managers in the 'bslma' package are compared in the following tables:
..
                              PERFORMANCE CHARACTERISTICS

               Memory Source     Allocation   Alignment     Out-of-memory
                                 Cost OVER                     Handling
                                 Underlying
                                  Source
            +-----------------+--------------+---------+----------------------+
NewDelete   | 'operator new'  | 0 if inlined,|MAXIMAL  | Return value 0       |
Allocator   |                 |else vfn call+|         |                      |
            +-----------------+--------------+---------+----------------------+
MallocFree  | 'std::malloc'   | 0 if inlined,|MAXIMAL  | Return value 0       |
Allocator   |                 |else vfn call+|         |                      |
            +-----------------+--------------+---------+----------------------+
Test        | 'malloc'        |     N/A      |   None  | Return value 0       |
Allocator   |                 |              |         |                      |
            +-----------------+--------------+---------+----------------------+

                                     SEMANTICS

                      Deallocation             Storage Facility
                  +-----------------------+-------------------------+
Newdelete         | Single items only     | Untyped, varying sizes  |
Allocator         |                       |                         |
                  +-----------------------+-------------------------+
MallocFree        | Single items only     | Untyped, varying sizes  |
Allocator         |                       |                         |
                  +-----------------------+-------------------------+
Test              | Single items only     | Untyped, varying sizes  |
Allocator         |                       |                         |
                  +-----------------------+-------------------------+
..

/The Default Allocator
/---------------------
 All object types in BDE libraries needing dynamic memory require that an
 allocator be passed to their constructor.  They take a 'bslma::Allocator *'
 argument, which defaults to the value of 'bslma::Default::defaultAllocator()'.
 This value is set by BDE library code to be
 'bslma::NewDeleteAllocator::singleton()', but it can be changed:
 'bslma::Default::setDefaultAllocator' sets the value of the (global) default
 allocator (although this is *strongly* discouraged), and
 'bslma::Default::allocator' returns it.

/Interaction With Other Packages
/-------------------------------
 All BDE library objects needing dynamic memory require that an allocator be
 passed to their constructor, which defaults to the allocator currently
 installed as the default allocator.
